{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"faq/","text":"What is a test case or test scenario and why is it needed? A test case is a recorded user's work in the application, so that there is no need to perform the same actions by hand every time to test a new version of the application. It is enough to record a test scenario once, and each subsequent automatic scan will replay the recorded actions in the application. For more information, see the Test Cases section in the User Guide. What is the difference between manual and automatic scanning? In manual scanning, the user handles the application (button clicks, text input, etc.) and Mobix then analyzes the captured data and identifies vulnerabilities. In automatic mode, Mobix requires you to record a test scenario. It records all your actions in the application and then plays back all these actions independently in automatic scan mode to simulate the work of a real user. For more information on scan types, see the Scan Launch section in the User Guide. Is it possible to launch the automatic scanning mode without recording a test scenario? Yes, it can be done, using the CLI tool. In this case, dynamic and static checks are performed without analyzing the data generated when the user works with the application. For more information, see the Scan Launch from the Command Line section in the User Guide. When I run an auto-scan, the recorded test case does not play as it should. Why does this happen? Since the application being scanned is affected by external actions during the scan, its operation speed can be slightly reduced. For recording test scenarios, it is recommended to take a small delay of 2-3 seconds between actions in the application interface. The scan or test scenario is in the \"Created\" state and does not change. Why did this happen? Scanning agents are used to perform a scan and record a test scenario. The scanning agent can process one scan or one test scenario and cannot perform multiple tasks in parallel. If no agents are available, the scan or test scenario is queued and waits for a suitable agent to become available. To solve the problem, you need to check if scans are currently running or test scenarios are being recorded and stop them. For more information, see the Scan Results section in the User Guide. What do the \u00abMain Window lost focus\u00bb and \u00abToo much AN messages\u00bb errors mean? When starting a scan or recording a test scenario, a check is made before the start to ensure that the main window of the application is not overlapped by any messages, dialog boxes, etc. If the application was not loaded within the specified time interval and another application is displayed on the screen, the \"Main Window lost focus\" error occurs. If the overlapping window is a system error message and the number of these errors is higher than the specified number, the scan will not start with the \"Too many ANR messages\" error. In this case, it is recommended to restart the scanning agent. What kind of checks does Mobix do? Mobix currently implements SAST, DAST and IAST practices. This means checking decompiled sources, analyzing the interaction of the application with the system and third-party components, and simulating black-box attacks on applications. A complete list of all vulnerabilities that can be detected is available in the product documentation. Please refer to the Remediation Guide .","title":"FAQ"},{"location":"gi/","text":"General Information !!! note \"Note\" This section provides general information on the Mobix system and a description of its main functionalities. It also contains user workstation requirements and the glossary of terms.","title":"General Information"},{"location":"gi/#general-information","text":"!!! note \"Note\" This section provides general information on the Mobix system and a description of its main functionalities. It also contains user workstation requirements and the glossary of terms.","title":"General Information"},{"location":"gi/glossary/","text":"Glossary Project \u2014 a top-level entity that contains application-specific scan settings and profiles. Each project is explicitly linked to the application package to be scanned, either during project creation or during the first scan. At the project level, only the scan rules to be applied to that project can be redefined. The project name is unique within the system. Profile \u2014 a scan profile that contains the settings of each module, a list of standards and information security requirements to be checked. The profile name is unique within its project. Module \u2014 a component for collecting various information when scanning an application on the device (monitoring the system log, file usage, database operations, etc.). Each module has its own unique settings and may depend on the results of other modules. Test cases \u2014 a recorded scenario of the user interaction with the application. It includes all user actions (mouse clicks, text inputs, any interaction with the application interface, etc.). Test case is linked to a particular project and can only be reproduced within that project. A test case can only be executed if the name of the application under test (package_id) matches the name of the application used to record the test case. Scan \u2014 the process of application analysis, by manual interaction with the application by the user or by the system using pre-recorded test cases. During the scan, the system collects all available information about the application and then searches for vulnerabilities and checks for compliance with security standards. Scan/launch method \u2014 the method that determines whether to run the previously recorded test case or wait for manual operations on the application. There are two options: Auto \u2014 starts scanning and runs the selected test case. Manual \u2014 after starting a scan, you need to manually perform operations on the running application. Package name \u2014 the name of the package of the application to be scanned. Rules \u2014 the scan analysis rules used to search for part of the vulnerabilities. Rules are a set of strings or regular expressions to be searched in the collected data. For convenience, adding rules is designed as a constructor. In this constructor you have to specify what string to search for, the list of modules that collected data for the search, and the exact location of the data (XML tag, JSON value, etc.). Requirement \u2014 the application can be checked for compliance with the information security requirement. Each requirement has certain types of defects associated with it. If these defects are found in the application, the requirement is considered not fulfilled. Requirements can be grouped into categories or apply directly to standards. Category \u2014 a set of information security requirements grouped by specific criteria. Standard \u2014 a set of information security requirements or categories of information security requirements. The application can be checked for compliance with the information security standard. The standards can be either global or internal company standards. Defects \u2014 application security defects, i.e. vulnerabilities discovered during the scan. Each defect has a type, description and recommendations for remediation. Collected Data \u2014 all information collected during the scan about the operation of the application. The data is divided into modules. Each module is responsible for collecting specific information. This data can be downloaded and analyzed if required. CI/CD (Continuous Integration / Continuous Delivery) \u2014 systems for continuous integration and continuous delivery of the application. Examples of such systems are Jenkins, TeamCity, GitLab CI. Emulator \u2014 a virtual emulator that simulates a real Android device. It can have various architecture and version of operating system.","title":"Glossary"},{"location":"gi/glossary/#glossary","text":"Project \u2014 a top-level entity that contains application-specific scan settings and profiles. Each project is explicitly linked to the application package to be scanned, either during project creation or during the first scan. At the project level, only the scan rules to be applied to that project can be redefined. The project name is unique within the system. Profile \u2014 a scan profile that contains the settings of each module, a list of standards and information security requirements to be checked. The profile name is unique within its project. Module \u2014 a component for collecting various information when scanning an application on the device (monitoring the system log, file usage, database operations, etc.). Each module has its own unique settings and may depend on the results of other modules. Test cases \u2014 a recorded scenario of the user interaction with the application. It includes all user actions (mouse clicks, text inputs, any interaction with the application interface, etc.). Test case is linked to a particular project and can only be reproduced within that project. A test case can only be executed if the name of the application under test (package_id) matches the name of the application used to record the test case. Scan \u2014 the process of application analysis, by manual interaction with the application by the user or by the system using pre-recorded test cases. During the scan, the system collects all available information about the application and then searches for vulnerabilities and checks for compliance with security standards. Scan/launch method \u2014 the method that determines whether to run the previously recorded test case or wait for manual operations on the application. There are two options: Auto \u2014 starts scanning and runs the selected test case. Manual \u2014 after starting a scan, you need to manually perform operations on the running application. Package name \u2014 the name of the package of the application to be scanned. Rules \u2014 the scan analysis rules used to search for part of the vulnerabilities. Rules are a set of strings or regular expressions to be searched in the collected data. For convenience, adding rules is designed as a constructor. In this constructor you have to specify what string to search for, the list of modules that collected data for the search, and the exact location of the data (XML tag, JSON value, etc.). Requirement \u2014 the application can be checked for compliance with the information security requirement. Each requirement has certain types of defects associated with it. If these defects are found in the application, the requirement is considered not fulfilled. Requirements can be grouped into categories or apply directly to standards. Category \u2014 a set of information security requirements grouped by specific criteria. Standard \u2014 a set of information security requirements or categories of information security requirements. The application can be checked for compliance with the information security standard. The standards can be either global or internal company standards. Defects \u2014 application security defects, i.e. vulnerabilities discovered during the scan. Each defect has a type, description and recommendations for remediation. Collected Data \u2014 all information collected during the scan about the operation of the application. The data is divided into modules. Each module is responsible for collecting specific information. This data can be downloaded and analyzed if required. CI/CD (Continuous Integration / Continuous Delivery) \u2014 systems for continuous integration and continuous delivery of the application. Examples of such systems are Jenkins, TeamCity, GitLab CI. Emulator \u2014 a virtual emulator that simulates a real Android device. It can have various architecture and version of operating system.","title":"Glossary"},{"location":"gi/product_overview/","text":"Product Overview Purpose Mobix (the system) is a solution for finding vulnerabilities and automating regression testing of information security of mobile applications using machine learning technologies. The main feature that distinguishes Mobix is a unique mechanism for creating automated test cases. They are reproduced and adapted to the changes in the application interface with minimal user involvement. This significantly reduces the cost of human resources for testing and searching for vulnerabilities, and allows the security testing process to be implemented as part of a continuous development process (DevOps). Despite the complexity inside, creating a test case looks to the user like usual work with the application. There is no need to write scripts or build the application in a special way. Just perform the necessary steps in the application as if it were installed on a normal mobile device. The system supports Bytecode Analysis (BCA), Static Application Security Testing (SAST), Interactive Application Security Testing (IAST), Dynamic Application Security Testing (DAST) and Application Programming Interface Security Testing (API ST) technologies, raw data collection and provides complete information about the work of the application on the device. The system is capable of detecting more than 50 types of vulnerabilities and checking for compliance with regulatory and industry information security requirements: PCI DSS, OWASP Mobile Top-10, OWASP MASVS, as well as allows you to create your own internal security standards. Product Features Various scan modes Mobix has several application security analysis modes that are suitable for different testing scenarios. Manual analysis is good for one-time application testing, while the automatic mode is suitable for embedding into the development process. Flexible modification of analysis rules Changing the analysis rules allows you to achieve maximum efficiency in finding security defects. The system components responsible for data collection are presented in the form of modules with a simple and clear configuration. The modification of the rules is made in the form of a constructor, and therefore the change will not take much time. Integration into the CI/CD process The system has a fully functional REST API. In addition, integrations into mobile app distribution systems are also provided. Maximum flexibility and a wide range of settings allows you to use Mobix in the process already built for application development and inform developers about the existing vulnerabilities at the stage of first builds. Check of compliance with security standards The application analysis provides not only descriptions and recommendations for remediation of detected vulnerabilities, but also all collected information about the application and a detailed report on its compliance with the latest global information security standards. All collected information about operation of the application All data collected while the application is running on the device is stored, structured, analyzed during vulnerability detection, and made available as scan artifacts. Detailed recommendations for remediation of the detected vulnerabilities Mobix detects more than 50 types of vulnerabilities. The search technology is based on observing the behavior of the application on the device during various scanning modes. After all the analysis stages, the vulnerabilities identified during application scanning are displayed in the system UI, with detailed information about the location of the vulnerability, its severity, detailed recommendations for remediation and, most importantly, how to avoid similar vulnerabilities in the future. Recommendations are regularly updated with new protection methods and best practices from around the world. A unique mechanism for automation of regression testing To automate testing, Mobix has developed a unique mechanism for recording, replaying and adapting test cases. This mechanism is based on deep integration with the operating system and machine learning methods. Despite the complexity inside, creating a test case looks to the user like usual work with the application. There is no need to write scripts or build the application in a special way. Just perform the necessary steps in the application as if it were installed on a normal mobile device.Despite the complexity inside, creating a test case looks to the user like usual work with the application. There is no need to write scripts or build the application in a special way. Just perform the necessary steps in the application as if it were installed on a normal mobile device.","title":"Product Overview"},{"location":"gi/product_overview/#product-overview","text":"","title":"Product Overview"},{"location":"gi/product_overview/#purpose","text":"Mobix (the system) is a solution for finding vulnerabilities and automating regression testing of information security of mobile applications using machine learning technologies. The main feature that distinguishes Mobix is a unique mechanism for creating automated test cases. They are reproduced and adapted to the changes in the application interface with minimal user involvement. This significantly reduces the cost of human resources for testing and searching for vulnerabilities, and allows the security testing process to be implemented as part of a continuous development process (DevOps). Despite the complexity inside, creating a test case looks to the user like usual work with the application. There is no need to write scripts or build the application in a special way. Just perform the necessary steps in the application as if it were installed on a normal mobile device. The system supports Bytecode Analysis (BCA), Static Application Security Testing (SAST), Interactive Application Security Testing (IAST), Dynamic Application Security Testing (DAST) and Application Programming Interface Security Testing (API ST) technologies, raw data collection and provides complete information about the work of the application on the device. The system is capable of detecting more than 50 types of vulnerabilities and checking for compliance with regulatory and industry information security requirements: PCI DSS, OWASP Mobile Top-10, OWASP MASVS, as well as allows you to create your own internal security standards.","title":"Purpose"},{"location":"gi/product_overview/#product-features","text":"","title":"Product Features"},{"location":"gi/product_overview/#various-scan-modes","text":"Mobix has several application security analysis modes that are suitable for different testing scenarios. Manual analysis is good for one-time application testing, while the automatic mode is suitable for embedding into the development process.","title":"Various scan modes"},{"location":"gi/product_overview/#flexible-modification-of-analysis-rules","text":"Changing the analysis rules allows you to achieve maximum efficiency in finding security defects. The system components responsible for data collection are presented in the form of modules with a simple and clear configuration. The modification of the rules is made in the form of a constructor, and therefore the change will not take much time.","title":"Flexible modification of analysis rules"},{"location":"gi/product_overview/#integration-into-the-cicd-process","text":"The system has a fully functional REST API. In addition, integrations into mobile app distribution systems are also provided. Maximum flexibility and a wide range of settings allows you to use Mobix in the process already built for application development and inform developers about the existing vulnerabilities at the stage of first builds.","title":"Integration into the CI/CD process"},{"location":"gi/product_overview/#check-of-compliance-with-security-standards","text":"The application analysis provides not only descriptions and recommendations for remediation of detected vulnerabilities, but also all collected information about the application and a detailed report on its compliance with the latest global information security standards.","title":"Check of compliance with security standards"},{"location":"gi/product_overview/#all-collected-information-about-operation-of-the-application","text":"All data collected while the application is running on the device is stored, structured, analyzed during vulnerability detection, and made available as scan artifacts.","title":"All collected information about operation of the application"},{"location":"gi/product_overview/#detailed-recommendations-for-remediation-of-the-detected-vulnerabilities","text":"Mobix detects more than 50 types of vulnerabilities. The search technology is based on observing the behavior of the application on the device during various scanning modes. After all the analysis stages, the vulnerabilities identified during application scanning are displayed in the system UI, with detailed information about the location of the vulnerability, its severity, detailed recommendations for remediation and, most importantly, how to avoid similar vulnerabilities in the future. Recommendations are regularly updated with new protection methods and best practices from around the world.","title":"Detailed recommendations for remediation of the detected vulnerabilities"},{"location":"gi/product_overview/#a-unique-mechanism-for-automation-of-regression-testing","text":"To automate testing, Mobix has developed a unique mechanism for recording, replaying and adapting test cases. This mechanism is based on deep integration with the operating system and machine learning methods. Despite the complexity inside, creating a test case looks to the user like usual work with the application. There is no need to write scripts or build the application in a special way. Just perform the necessary steps in the application as if it were installed on a normal mobile device.Despite the complexity inside, creating a test case looks to the user like usual work with the application. There is no need to write scripts or build the application in a special way. Just perform the necessary steps in the application as if it were installed on a normal mobile device.","title":"A unique mechanism for automation of regression testing"},{"location":"gi/user_workplace_requirements/","text":"User Workplace Requirements Hardware Requirements To work with the system installed on-premises, you need a computer connected to the internal network of the company. To work with the system as a cloud service, you need a computer connected to Internet. Software Requirements You must have a web browser installed on your PC. Recommended web browsers are: Google Chrome (the best option). Mozilla Firefox.","title":"User Workplace Requirements"},{"location":"gi/user_workplace_requirements/#user-workplace-requirements","text":"","title":"User Workplace Requirements"},{"location":"gi/user_workplace_requirements/#hardware-requirements","text":"To work with the system installed on-premises, you need a computer connected to the internal network of the company. To work with the system as a cloud service, you need a computer connected to Internet.","title":"Hardware Requirements"},{"location":"gi/user_workplace_requirements/#software-requirements","text":"You must have a web browser installed on your PC. Recommended web browsers are: Google Chrome (the best option). Mozilla Firefox.","title":"Software Requirements"},{"location":"rg/","text":"\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u043f\u043e \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u0434\u043b\u044f Android \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0435 \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0432\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0433\u043e \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u043a\u043b\u044e\u0447\u0435\u0439 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Activity \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Activity \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0435\u0448\u043d\u044e\u044e Activity \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044e\u044e Activity \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Service \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Service \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0435\u0448\u043d\u0438\u0439 Service \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0439 Service \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043f\u043e \u0441\u0435\u0442\u0438 \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b GET-\u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTPS \u0437\u0430\u043f\u0440\u043e\u0441 \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u0435 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 sensitive \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTP-\u043e\u0442\u0432\u0435\u0442\u0435 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTPS-\u043e\u0442\u0432\u0435\u0442\u0435 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0430\u043c\u044f\u0442\u0438 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0439 \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043d\u0435\u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0439 \u043d\u0435\u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u043c \u043a\u043e\u0434\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0440\u0430\u043d\u0435\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043d\u043e\u0439 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043a\u044d\u0448\u0435 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0439/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430, \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430/\u043a\u043b\u044e\u0447\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041f\u0440\u043e\u0447\u0438\u0435 \u0412\u044b\u0432\u043e\u0434 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0439 \u043b\u043e\u0433 \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 BroadcastReceiver \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 private BroadcastReceiver \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u0445 SQL-\u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0439 \u043a\u043e\u043f\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u043e\u0431\u0444\u0443\u0441\u0446\u0438\u0440\u043e\u0432\u0430\u043d\u043e \u0421\u043b\u0430\u0431\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u041f\u0435\u0440\u0435\u0445\u0432\u0430\u0442 \u043f\u0430\u0440\u043e\u043b\u044f \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0430\u0435\u0442 \u0441\u0435\u0442\u0435\u0432\u044b\u0435 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u043f\u043e \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0443 HTTP \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u0435\u0442\u0435\u0432\u043e\u0433\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u041f\u043e\u0442\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430 \u0432 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 Cookies \u0432 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 WebView \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432 AndroidManifest.xml \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432 AndroidManifest.xml. \u0424\u043b\u0430\u0433 android:hasFragileUserData \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432 AndroidManifest.xml. \u0424\u043b\u0430\u0433 android:requestLegacyExternalStorage \u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0438\u043b\u0438 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d SSL-pinning \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043e\u043f\u043e\u0441\u0440\u0435\u0434\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0445 Activity \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u0434\u043c\u0435\u043d\u044b URL \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e URL \u0432 WebView \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0443 \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u043c\u0443 ContentProvider \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0443 \u0447\u0435\u0440\u0435\u0437 ContentProvider \u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u0434\u043b\u044f iOS \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0435 \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0432\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0433\u043e \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u043a\u043b\u044e\u0447\u0435\u0439 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0439/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430/\u043a\u043b\u044e\u0447\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041f\u0440\u043e\u0447\u0438\u0435 \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u043e\u0435 \u043a\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0435\u0442\u0435\u0432\u044b\u0445 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0412\u044b\u0432\u043e\u0434 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0439 \u043b\u043e\u0433 \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f App Transport Security \u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0437\u0430\u0449\u0438\u0442\u044b \u043e\u0442 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0439 \u041d\u0430\u043b\u0438\u0447\u0438\u0435 \u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0432 \u0441\u0431\u043e\u0440\u043a\u0438 \u0432 \u0441\u043e\u0431\u0440\u0430\u043d\u043d\u043e\u043c \u043f\u0430\u043a\u0435\u0442\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041d\u0430\u043b\u0438\u0447\u0438\u0435 Podfile \u0432 \u0441\u043e\u0431\u0440\u0430\u043d\u043d\u043e\u043c \u043f\u0430\u043a\u0435\u0442\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043a\u044d\u0448\u0435 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 NSUserDefaults \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u043c \u043a\u043e\u0434\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Binary Cookies \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0440\u0430\u043d\u0435\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043d\u043e\u0439 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438","title":"\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u043f\u043e \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439"},{"location":"rg/#_1","text":"","title":"\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u043f\u043e \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439"},{"location":"rg/#android","text":"","title":"\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u0434\u043b\u044f Android"},{"location":"rg/#_2","text":"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0433\u043e \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u043a\u043b\u044e\u0447\u0435\u0439 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c","title":"\u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0435 \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0432\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438"},{"location":"rg/#sensitive-activity","text":"\u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Activity \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0435\u0448\u043d\u044e\u044e Activity \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044e\u044e Activity","title":"\u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Activity"},{"location":"rg/#sensitive-service","text":"\u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Service \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0435\u0448\u043d\u0438\u0439 Service \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0439 Service","title":"\u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Service"},{"location":"rg/#sensitive-","text":"\u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b GET-\u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTPS \u0437\u0430\u043f\u0440\u043e\u0441 \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u0435 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 sensitive \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTP-\u043e\u0442\u0432\u0435\u0442\u0435 \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 HTTPS-\u043e\u0442\u0432\u0435\u0442\u0435","title":"\u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043f\u043e \u0441\u0435\u0442\u0438"},{"location":"rg/#sensitive-_1","text":"\u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0430\u043c\u044f\u0442\u0438 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0439 \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043d\u0435\u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043e\u0431\u0449\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0439 \u043d\u0435\u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u043c \u043a\u043e\u0434\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0440\u0430\u043d\u0435\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043d\u043e\u0439 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043a\u044d\u0448\u0435 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b","title":"\u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438"},{"location":"rg/#_3","text":"\u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430, \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430/\u043a\u043b\u044e\u0447\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f","title":"\u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0439/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432"},{"location":"rg/#_4","text":"\u0412\u044b\u0432\u043e\u0434 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0439 \u043b\u043e\u0433 \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 BroadcastReceiver \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 private BroadcastReceiver \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u0445 SQL-\u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0439 \u043a\u043e\u043f\u0438\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u043e\u0431\u0444\u0443\u0441\u0446\u0438\u0440\u043e\u0432\u0430\u043d\u043e \u0421\u043b\u0430\u0431\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u041f\u0435\u0440\u0435\u0445\u0432\u0430\u0442 \u043f\u0430\u0440\u043e\u043b\u044f \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0430\u0435\u0442 \u0441\u0435\u0442\u0435\u0432\u044b\u0435 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u043f\u043e \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0443 HTTP \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u0435\u0442\u0435\u0432\u043e\u0433\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u041f\u043e\u0442\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430 \u0432 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 Cookies \u0432 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0439 \u0431\u0430\u0437\u0435 WebView \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432 AndroidManifest.xml \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432 AndroidManifest.xml. \u0424\u043b\u0430\u0433 android:hasFragileUserData \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432 AndroidManifest.xml. \u0424\u043b\u0430\u0433 android:requestLegacyExternalStorage \u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0438\u043b\u0438 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d SSL-pinning \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043e\u043f\u043e\u0441\u0440\u0435\u0434\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0445 Activity \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u0434\u043c\u0435\u043d\u044b URL \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e URL \u0432 WebView \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0443 \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u043c\u0443 ContentProvider \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0443 \u0447\u0435\u0440\u0435\u0437 ContentProvider","title":"\u041f\u0440\u043e\u0447\u0438\u0435"},{"location":"rg/#ios","text":"","title":"\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u0434\u043b\u044f iOS"},{"location":"rg/#_5","text":"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0435 \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0433\u043e \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430 \u043a\u043b\u044e\u0447\u0435\u0439 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441\u043e \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0435 \u043a\u043b\u044e\u0447\u0438 \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438 \u043a\u043b\u044e\u0447\u0430\u043c\u0438, \u0437\u0430\u0449\u0438\u0449\u0451\u043d\u043d\u044b\u043c\u0438 \u0441\u043b\u0430\u0431\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c","title":"\u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0435 \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0432\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438"},{"location":"rg/#_6","text":"\u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430/\u043a\u043b\u044e\u0447\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0443\u0431\u043b\u0438\u0447\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u0435\u043c \u0432 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438/\u0440\u0435\u0441\u0443\u0440\u0441\u0430\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f","title":"\u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0439/\u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432"},{"location":"rg/#_7","text":"\u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u043e\u0435 \u043a\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0435\u0442\u0435\u0432\u044b\u0445 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0412\u044b\u0432\u043e\u0434 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0439 \u043b\u043e\u0433 \u041d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f App Transport Security \u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0437\u0430\u0449\u0438\u0442\u044b \u043e\u0442 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0439 \u041d\u0430\u043b\u0438\u0447\u0438\u0435 \u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0432 \u0441\u0431\u043e\u0440\u043a\u0438 \u0432 \u0441\u043e\u0431\u0440\u0430\u043d\u043d\u043e\u043c \u043f\u0430\u043a\u0435\u0442\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041d\u0430\u043b\u0438\u0447\u0438\u0435 Podfile \u0432 \u0441\u043e\u0431\u0440\u0430\u043d\u043d\u043e\u043c \u043f\u0430\u043a\u0435\u0442\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043a\u044d\u0448\u0435 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 NSUserDefaults \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 sensitive-\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u043c \u043a\u043e\u0434\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0432 Binary Cookies \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0440\u0430\u043d\u0435\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043d\u043e\u0439 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438","title":"\u041f\u0440\u043e\u0447\u0438\u0435"},{"location":"rg/en/android/","text":"Android Insecure storage of cryptographic key information A writable keystore A writable keystore protected by a weak password A readable file keystore A readable keystore, protected by a weak password, containing private keys A readable keystore, protected by a weak password, containing public keys A readable keystore containing private keys protected by a weak password Using a file keystore A keystore, protected by \u0430 weak password, containing private keys A keystore, protected by a weak password, containing public keys A keystore containing private keys protected by a weak password Transmission of sensitive information in Activity Insecure transmission of sensitive information in Activity Insecure transmission of sensitive information in external Activity Insecure transmission of sensitive information in private Activity Transmission of sensitive information in Service Insecure transmission of sensitive information in Service Insecure transmission of sensitive information in external Service Insecure transmission of sensitive information in internal Service Sending sensitive information over the network Including sensitive information into the GET request parameters Including sensitive information into an HTTPS request Sending sensitive information in an HTTP request Getting sensitive information in an HTTP response Getting sensitive information in an HTTPS response Storing sensitive information Storing sensitive information in memory Storing sensitive information in a public file outside the application's directory Storing sensitive information in a public file inside the application's directory Storing sensitive information in a private file outside the application's directory Storing sensitive information in a private file inside the application's directory Storing sensitive information in a public protected database Storing sensitive information in an unprotected database Storing sensitive information in a protected database Storing sensitive information in a public unprotected database Storing sensitive information in the application source code Storage or use of previously found sensitive information Storing sensitive information in the keyboard cache Output of sensitive information into the system log Insecure Signature Algorithm Insufficient length of a signature key Transmission of sensitive information in BroadcastReceiver Transmission of sensitive information in a private BroadcastReceiver Transmission of sensitive information in SQL query parameters Possibility to create a backup copy of the application Application is not obfuscated Weak database encryption password Interception of a database encryption password An application allows network connections via HTTP Insecure networking configuration Potential execution of arbitrary code within the application Storing Cookie values in the standard WebView database Storing a private key/certificate that is not protected by a password in the directory/resources of the application Storing a public key/certificate in the directory/resources of the application Storing a private key/certificate protected by a password in the directory/resources of the application Storing a key/certificate in the directory/resources of the application Insecure settings in AndroidManifest.xml Insecure settings in AndroidManifest.xml. The android:hasFragileUserData flag Insecure settings in AndroidManifest.xml. The android:requestLegacyExternalStorage flag SSL-Pinning is missing or incorrectly implemented","title":"Android"},{"location":"rg/en/android/#android","text":"Insecure storage of cryptographic key information A writable keystore A writable keystore protected by a weak password A readable file keystore A readable keystore, protected by a weak password, containing private keys A readable keystore, protected by a weak password, containing public keys A readable keystore containing private keys protected by a weak password Using a file keystore A keystore, protected by \u0430 weak password, containing private keys A keystore, protected by a weak password, containing public keys A keystore containing private keys protected by a weak password Transmission of sensitive information in Activity Insecure transmission of sensitive information in Activity Insecure transmission of sensitive information in external Activity Insecure transmission of sensitive information in private Activity Transmission of sensitive information in Service Insecure transmission of sensitive information in Service Insecure transmission of sensitive information in external Service Insecure transmission of sensitive information in internal Service Sending sensitive information over the network Including sensitive information into the GET request parameters Including sensitive information into an HTTPS request Sending sensitive information in an HTTP request Getting sensitive information in an HTTP response Getting sensitive information in an HTTPS response Storing sensitive information Storing sensitive information in memory Storing sensitive information in a public file outside the application's directory Storing sensitive information in a public file inside the application's directory Storing sensitive information in a private file outside the application's directory Storing sensitive information in a private file inside the application's directory Storing sensitive information in a public protected database Storing sensitive information in an unprotected database Storing sensitive information in a protected database Storing sensitive information in a public unprotected database Storing sensitive information in the application source code Storage or use of previously found sensitive information Storing sensitive information in the keyboard cache Output of sensitive information into the system log Insecure Signature Algorithm Insufficient length of a signature key Transmission of sensitive information in BroadcastReceiver Transmission of sensitive information in a private BroadcastReceiver Transmission of sensitive information in SQL query parameters Possibility to create a backup copy of the application Application is not obfuscated Weak database encryption password Interception of a database encryption password An application allows network connections via HTTP Insecure networking configuration Potential execution of arbitrary code within the application Storing Cookie values in the standard WebView database Storing a private key/certificate that is not protected by a password in the directory/resources of the application Storing a public key/certificate in the directory/resources of the application Storing a private key/certificate protected by a password in the directory/resources of the application Storing a key/certificate in the directory/resources of the application Insecure settings in AndroidManifest.xml Insecure settings in AndroidManifest.xml. The android:hasFragileUserData flag Insecure settings in AndroidManifest.xml. The android:requestLegacyExternalStorage flag SSL-Pinning is missing or incorrectly implemented","title":"Android"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys/","text":"A keystore, protected by \u0430 weak password, containing private keys Severity: LOW Detection method: DAST, KEY INFORMATION Description An application uses a key store protected by a weak password that contains private keys. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" --------------------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation --------------- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation --------------- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A keystore, protected by \u0430 weak password, containing private keys"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys/#a-keystore-protected-by-weak-password-containing-private-keys","text":"Severity: LOW Detection method: DAST, KEY INFORMATION","title":"A keystore, protected by \u0430 weak password, containing private keys"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys/#description","text":"An application uses a key store protected by a weak password that contains private keys. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" --------------------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation --------------- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation --------------- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys/","text":"A keystore, protected by a weak password, containing public keys Severity: LOW Detection method: DAST, KEY INFORMATION Description An application uses a key store protected by a weak password that contains public keys. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A keystore, protected by a weak password, containing public keys"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys/#a-keystore-protected-by-a-weak-password-containing-public-keys","text":"Severity: LOW Detection method: DAST, KEY INFORMATION","title":"A keystore, protected by a weak password, containing public keys"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys/#description","text":"An application uses a key store protected by a weak password that contains public keys. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/a_keystore_containing_private_keys_protected_by_a_weak_password/","text":"A keystore containing private keys protected by a weak password Severity: HIGH Detection method: DAST, KEY INFORMATION Description An application uses a key storage that contains private keys protected by a weak password. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" --------------------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation --------------- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation --------------- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A keystore containing private keys protected by a weak password"},{"location":"rg/en/android/a_keystore_containing_private_keys_protected_by_a_weak_password/#a-keystore-containing-private-keys-protected-by-a-weak-password","text":"Severity: HIGH Detection method: DAST, KEY INFORMATION","title":"A keystore containing private keys protected by a weak password"},{"location":"rg/en/android/a_keystore_containing_private_keys_protected_by_a_weak_password/#description","text":"An application uses a key storage that contains private keys protected by a weak password. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_keystore_containing_private_keys_protected_by_a_weak_password/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" --------------------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation --------------- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation --------------- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_keystore_containing_private_keys_protected_by_a_weak_password/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/a_keystore_with_write_permission_protected_by_a_weak_password/","text":"A writable keystore protected by a weak password Severity: MEDIUM Detection method: DAST, KEY INFORMATION Description An application uses a writable keystore protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" -------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation -- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation -- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a new key in KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A writable keystore protected by a weak password"},{"location":"rg/en/android/a_keystore_with_write_permission_protected_by_a_weak_password/#a-writable-keystore-protected-by-a-weak-password","text":"Severity: MEDIUM Detection method: DAST, KEY INFORMATION","title":"A writable keystore protected by a weak password"},{"location":"rg/en/android/a_keystore_with_write_permission_protected_by_a_weak_password/#description","text":"An application uses a writable keystore protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. A keystore and the keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_keystore_with_write_permission_protected_by_a_weak_password/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" -------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation -- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation -- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a new key in KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_keystore_with_write_permission_protected_by_a_weak_password/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys/","text":"A readable keystore, protected by a weak password, containing private keys Severity: CRITICAL Detection method: DAST, KEY INFORMATION Description An application uses a readable keystore, protected by a weak password, containing private keys. An encryption key must not be stored in a location with public access and a keystore and keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A readable keystore, protected by a weak password, containing private keys"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys/#a-readable-keystore-protected-by-a-weak-password-containing-private-keys","text":"Severity: CRITICAL Detection method: DAST, KEY INFORMATION","title":"A readable keystore, protected by a weak password, containing private keys"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys/#description","text":"An application uses a readable keystore, protected by a weak password, containing private keys. An encryption key must not be stored in a location with public access and a keystore and keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys/","text":"A readable keystore, protected by a weak password, containing public keys Severity: LOW Detection method: DAST, KEY INFORMATION Description An application uses a readable keystore, protected by a weak password, containing public keys. An encryption key must not be stored in a location with public access and a keystore and keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length At least one upper-case letter is required At least one lower-case letter is required At least one numeric character is required At least one special character is required Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ----------------------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ----------------- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ----------------- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A readable keystore, protected by a weak password, containing public keys"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys/#a-readable-keystore-protected-by-a-weak-password-containing-public-keys","text":"Severity: LOW Detection method: DAST, KEY INFORMATION","title":"A readable keystore, protected by a weak password, containing public keys"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys/#description","text":"An application uses a readable keystore, protected by a weak password, containing public keys. An encryption key must not be stored in a location with public access and a keystore and keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length At least one upper-case letter is required At least one lower-case letter is required At least one numeric character is required At least one special character is required Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ----------------------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ----------------- # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ----------------- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/a_readable_keystore_containing_private_keys_protected_by_a_weak_password/","text":"A readable keystore containing private keys protected by a weak password Severity: CRITICAL Detection method: DAST, KEY INFORMATION Description An application uses a readable keystore containing private keys protected by a weak password. An encryption key must not be stored in a location with public access and a keystore and keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A readable keystore containing private keys protected by a weak password"},{"location":"rg/en/android/a_readable_keystore_containing_private_keys_protected_by_a_weak_password/#a-readable-keystore-containing-private-keys-protected-by-a-weak-password","text":"Severity: CRITICAL Detection method: DAST, KEY INFORMATION","title":"A readable keystore containing private keys protected by a weak password"},{"location":"rg/en/android/a_readable_keystore_containing_private_keys_protected_by_a_weak_password/#description","text":"An application uses a readable keystore containing private keys protected by a weak password. An encryption key must not be stored in a location with public access and a keystore and keys stored in it must be protected by a strong password. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_readable_keystore_containing_private_keys_protected_by_a_weak_password/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_readable_keystore_containing_private_keys_protected_by_a_weak_password/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/a_writable_keystore/","text":"A writable keystore Severity: HIGH Detection method: DAST, KEY INFORMATION Description An application uses a writable keystore. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A writable keystore"},{"location":"rg/en/android/a_writable_keystore/#a-writable-keystore","text":"Severity: HIGH Detection method: DAST, KEY INFORMATION","title":"A writable keystore"},{"location":"rg/en/android/a_writable_keystore/#description","text":"An application uses a writable keystore. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/a_writable_keystore/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/a_writable_keystore/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/ability_to_access_an_arbitrary_file_via_contentprovider/","text":"Possibility to access an arbitrary file using ContentProvider Severity: MEDIUM Detection method: IAST Description This vulnerability allows access to application files using exported ContentProvider . The vulnerability is present in applications where implementation of the openFile method of a ContentProvider derived class does not properly check the Uri-parameter. A malicious application can specifically generate a Uri, pass it to this ContentProvider and gain access to an arbitrary file. An example of vulnerable code: @Override public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException { File file = new File(getContext().getFilesDir(), uri.getLastPathSegment()); return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_WRITE); } A malicious application can use such code: Uri uri = Uri.parse(\"content://vuln.app.pkg.some_authority/private_internal_file\"); try { Log.d(\"Evil\", IOUtils.toString(getContentResolver().openInputStream(uri), Charset.defaultCharset())); } catch (Throwable th) { Log.e(\"Evil\", \"Error was occured during openInputStream call\"); throw new RuntimeException(th); } As a result, a malicious application will access the private_internal_file file in the application directory of the vulnerable application ( vuln.app.pkg ). Recommendations To avoid such problems in the application, you need to make sure to follow a few rules: Implement private/in-house visibility in ContentProvider . As an example, declaring ContentProvider as internal: <provider android:name=\".PrivateProvider\" android:authorities=\"notvuln.app.pkg.some_authority\" android:exported=\"false\" /> In order to protect a ContentProvider from being used by third-party applications, you need to define a permission with protectionLevel=\"signature\" and put it in the declaration of that ContentProvider : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"notvuln.app.pkg\"> <!-- *** 1 *** \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u0435 in-house \u043f\u043e\u043b\u043d\u043e\u043c\u043e\u0447\u0438\u0435 (permission) \u0441 protectionLevel=\"signature\" --> <permission android:name=\"notvuln.app.pkg.inhouseprovider.MY_PERMISSION\" android:protectionLevel=\"signature\" /> <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- *** 2 *** \u041e\u0433\u0440\u0430\u043d\u0438\u0447\u044c\u0442\u0435 \u0434\u043e\u0441\u0442\u0443\u043f \u043a **ContentProvider** \u043f\u0440\u0438 \u0435\u0433\u043e \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e in-house \u043f\u043e\u043b\u043d\u043e\u043c\u043e\u0447\u0438\u044f --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <provider android:name=\".InhouseProvider\" android:authorities=\"notvuln.app.pkg.inhouseprovider\" android:permission=\"notvuln.app.pkg.inhouseprovider.MY_PERMISSION\" android:exported=\"true\" /> </application> </manifest> If a ContentProvider must remain public to third-party applications, you need to validate the canonical file path just before returning it to the requesting application: @Override public ParcelFileDescriptor openFile (Uri uri, String mode) throws FileNotFoundException { File file = new File(sdcardDir, uri.getLastPathSegment()); if (!file.getCanonicalPath().startsWith(sdcardDir)) { throw new IllegalArgumentException(); } return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY); }","title":"Possibility to access an arbitrary file using ContentProvider"},{"location":"rg/en/android/ability_to_access_an_arbitrary_file_via_contentprovider/#possibility-to-access-an-arbitrary-file-using-contentprovider","text":"Severity: MEDIUM Detection method: IAST","title":"Possibility to access an arbitrary file using ContentProvider"},{"location":"rg/en/android/ability_to_access_an_arbitrary_file_via_contentprovider/#description","text":"This vulnerability allows access to application files using exported ContentProvider . The vulnerability is present in applications where implementation of the openFile method of a ContentProvider derived class does not properly check the Uri-parameter. A malicious application can specifically generate a Uri, pass it to this ContentProvider and gain access to an arbitrary file. An example of vulnerable code: @Override public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException { File file = new File(getContext().getFilesDir(), uri.getLastPathSegment()); return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_WRITE); } A malicious application can use such code: Uri uri = Uri.parse(\"content://vuln.app.pkg.some_authority/private_internal_file\"); try { Log.d(\"Evil\", IOUtils.toString(getContentResolver().openInputStream(uri), Charset.defaultCharset())); } catch (Throwable th) { Log.e(\"Evil\", \"Error was occured during openInputStream call\"); throw new RuntimeException(th); } As a result, a malicious application will access the private_internal_file file in the application directory of the vulnerable application ( vuln.app.pkg ).","title":"Description"},{"location":"rg/en/android/ability_to_access_an_arbitrary_file_via_contentprovider/#recommendations","text":"To avoid such problems in the application, you need to make sure to follow a few rules: Implement private/in-house visibility in ContentProvider . As an example, declaring ContentProvider as internal: <provider android:name=\".PrivateProvider\" android:authorities=\"notvuln.app.pkg.some_authority\" android:exported=\"false\" /> In order to protect a ContentProvider from being used by third-party applications, you need to define a permission with protectionLevel=\"signature\" and put it in the declaration of that ContentProvider : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"notvuln.app.pkg\"> <!-- *** 1 *** \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u0435 in-house \u043f\u043e\u043b\u043d\u043e\u043c\u043e\u0447\u0438\u0435 (permission) \u0441 protectionLevel=\"signature\" --> <permission android:name=\"notvuln.app.pkg.inhouseprovider.MY_PERMISSION\" android:protectionLevel=\"signature\" /> <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- *** 2 *** \u041e\u0433\u0440\u0430\u043d\u0438\u0447\u044c\u0442\u0435 \u0434\u043e\u0441\u0442\u0443\u043f \u043a **ContentProvider** \u043f\u0440\u0438 \u0435\u0433\u043e \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e in-house \u043f\u043e\u043b\u043d\u043e\u043c\u043e\u0447\u0438\u044f --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <provider android:name=\".InhouseProvider\" android:authorities=\"notvuln.app.pkg.inhouseprovider\" android:permission=\"notvuln.app.pkg.inhouseprovider.MY_PERMISSION\" android:exported=\"true\" /> </application> </manifest> If a ContentProvider must remain public to third-party applications, you need to validate the canonical file path just before returning it to the requesting application: @Override public ParcelFileDescriptor openFile (Uri uri, String mode) throws FileNotFoundException { File file = new File(sdcardDir, uri.getLastPathSegment()); if (!file.getCanonicalPath().startsWith(sdcardDir)) { throw new IllegalArgumentException(); } return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY); }","title":"Recommendations"},{"location":"rg/en/android/ability_to_open_an_arbitrary_url_in_webview/","text":"Possibility to open an arbitrary URL in WebView Severity: MEDIUM Detection method: IAST Description Vulnerability allows to open arbitrary URLs in an application WebView . Depending on WebView settings, this vulnerability can be exploited in different attack vectors. The vulnerability is present in applications that use data from an untrusted source to form a URL, which is then used in calls to the WebView.loadUrl method. For example, a vulnerable application can use this code: WebView webView = findViewById(R.id.webview); setupWebView(webView); webView.loadUrl(getIntent().getStringExtra(\"url\")); Or this one: String url = uri.getQueryParameter(\"url\"); if(url != null) { webView.loadUrl(url); } Recommendations Do not use dynamically generated URLs for WebView . webView.loadUrl(\"https://url.to.your.contents/\"); Perform URL validation: Allow access only to company resources, i.e. maintain a white-list of URLs and check the URL passed to the loadUrl method against it. Allow access only to particular origin, i.e. check scheme and domain of the URL. List<String> whiteHosts = Arrays.asList(\"stackoverflow.com\", \"stackexchange.com\", \"google.com\"); public boolean isValid(String url) { String host = Uri.parse(url).getHost(); if(whiteHosts.contains(host) { return true; } return false; } Disable potentially dangerous settings for accessing application resources from WebView : WebSettings.setAllowContentAccess(false) WebSettings.setAllowFileAccess(false) WebSettings.setAllowFileAccessFromFileURLs(false) WebSettings.setAllowUniversalAccessFromFileURLs(false) WebSettings.setGeolocationEnabled(false) Links Android security checklist: WebView UrlQuerySanitizer | Android Developers","title":"Possibility to open an arbitrary URL in WebView"},{"location":"rg/en/android/ability_to_open_an_arbitrary_url_in_webview/#possibility-to-open-an-arbitrary-url-in-webview","text":"Severity: MEDIUM Detection method: IAST","title":"Possibility to open an arbitrary URL in WebView"},{"location":"rg/en/android/ability_to_open_an_arbitrary_url_in_webview/#description","text":"Vulnerability allows to open arbitrary URLs in an application WebView . Depending on WebView settings, this vulnerability can be exploited in different attack vectors. The vulnerability is present in applications that use data from an untrusted source to form a URL, which is then used in calls to the WebView.loadUrl method. For example, a vulnerable application can use this code: WebView webView = findViewById(R.id.webview); setupWebView(webView); webView.loadUrl(getIntent().getStringExtra(\"url\")); Or this one: String url = uri.getQueryParameter(\"url\"); if(url != null) { webView.loadUrl(url); }","title":"Description"},{"location":"rg/en/android/ability_to_open_an_arbitrary_url_in_webview/#recommendations","text":"Do not use dynamically generated URLs for WebView . webView.loadUrl(\"https://url.to.your.contents/\"); Perform URL validation: Allow access only to company resources, i.e. maintain a white-list of URLs and check the URL passed to the loadUrl method against it. Allow access only to particular origin, i.e. check scheme and domain of the URL. List<String> whiteHosts = Arrays.asList(\"stackoverflow.com\", \"stackexchange.com\", \"google.com\"); public boolean isValid(String url) { String host = Uri.parse(url).getHost(); if(whiteHosts.contains(host) { return true; } return false; } Disable potentially dangerous settings for accessing application resources from WebView : WebSettings.setAllowContentAccess(false) WebSettings.setAllowFileAccess(false) WebSettings.setAllowFileAccessFromFileURLs(false) WebSettings.setAllowUniversalAccessFromFileURLs(false) WebSettings.setGeolocationEnabled(false)","title":"Recommendations"},{"location":"rg/en/android/ability_to_open_an_arbitrary_url_in_webview/#links","text":"Android security checklist: WebView UrlQuerySanitizer | Android Developers","title":"Links"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/","text":"Possibility to run private Activity indirectly Severity: \u0421\u0420\u0415\u0414\u041d\u042f\u042f Detection method: IAST Description This vulnerability allows to start an internal non-exportable Activity of an application. This can cause quite a wide range of problems, from authentication bypass to compromising user data. The vulnerability is present in applications that use Intent from an untrusted source (for example, obtained from a third-party application using getIntent , getParcelableExtra or onActivityResult methods) to start ( startActivity , startActivityForResult ) their internal Activity. Hereinafter the \" to-be-redirected Intent \" term will be used, i.e. Intent obtained from an untrusted source and further used to start an Activity . For example, a malicious application can use such code: Intent intent = new Intent(\"vuln.app.pkg.LOGIN\"); Intent redirIntent = new Intent(); redirIntent.setComponent(new ComponentName(\"vuln.app.pkg\", \"vuln.app.pkg.PrivateActivity\")); intent.putExtra(\"redirect_intent\", redirIntent); startActivity(intent); Targeted application: Intent redirectIntent = getIntent().getParcelableExtra(\"redirect_intent\"); if(redirectIntent != null) { startActivity(redirectIntent); } else { startActivity(new Intent(this, MainActivity.class)); } finish(); Calling such code from a malicious application will launch the vulnerable application's internal Activity ( vuln.app.pkg.PrivateActivity ) Recommendations To avoid such problems in the application, you need to make sure to follow a few rules: Implement private/in-house visibility for components that accept \" to-be-redirected Intent \" and use it to later run private/in-house Activity . For example, declaration of Activity internal - no intent-filter or exported flag is set to false : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.privateactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Private activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> <!-- Public activity \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c\u0430\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e --> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Validate \" to-be-redirected Intent \" for maliciousness - it should not be sent to private/in-house Activity : Intent intent = getIntent(); Intent redirectIntent = (Intent) intent.getParcelableExtra(\u201credirect_intent\u201d); ComponentName name = redirectIntent.resolveActivity(getPackageManager()); // \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0446\u0435\u043b\u0435\u0432\u043e\u0435 \u0438\u043c\u044f \u043f\u0430\u043a\u0435\u0442\u0430 \u0438 \u043a\u043b\u0430\u0441\u0441\u0430 if(name.getPackageName().equals(\u201csafe_package\u201d) && name.getClassName().equals(\u201csafe_class\u201d)) { startActivity(redirectIntent); } Partner Activity Another way is to work with partner applications. They are applications that are used by collaborating companies that want to share information and functionality securely. Within this exchange, the concept of Partner Activity is introduced. This is an Activity that can only be shared from applications that are developed by partner companies. There is a risk that a third-party application will read contents of Intent used to start an Activity . So you need to make sure that if the Intent used to start an Activity includes sensitive information, protective measures are in place to prevent a malicious application from accessing it. Creating a Partner Activity There are several rules to follow when creating a Partner Activity : Do not use taskAffinity . Do not use launchMode . Do not declare intent-filter and explicitly specify the exported=\"true\" attribute. Make sure that a certificate of the calling application is included in the list of trusted application certificates. Verify and securely process received Intent , even though it was received from the same partner application. Return only information that the partner application has the right to access. To implement item 4, it is necessary to organize receipt of a fingerprint of certificates of trusted applications and their registration in our application. To do this, you can use the following code examples with detailed comments. AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.partneractivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Partner activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u041d\u0435 \u043e\u0431\u044c\u044f\u0432\u043b\u044f\u0439\u0442\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u044b \u0438 \u044f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PartnerActivity\" android:exported=\"true\" /> </application> </manifest> PartnerActivity.java package com.swordfishsecurity.appsec.android.activity.partneractivity; import com.swordfishsecurity.appsec.android.shared.PkgCertWhitelists; import com.swordfishsecurity.appsec.android.shared.Utils; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PartnerActivity extends Activity { // *** 4 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u0432 \u0441\u043f\u0438\u0441\u043a\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u0434\u043e\u0432\u0435\u0440\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 private static PkgCertWhitelists sWhitelists = null; private static void buildWhitelists(Context context) { boolean isdebug = Utils.isDebuggable(context); sWhitelists = new PkgCertWhitelists(); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneruser sWhitelists.add(\"com.swordfishsecurity.appsec.android.activity.partneruser\", isdebug ? // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \"androiddebugkey\" \u0438\u0437 debug.keystore. \"0EFB7236 328348A9 89718BAD DF57F544 D5CCB4AE B9DB34BC 1E29DD26 F77C8255\" : // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneruser \"1F039BB5 7861C27A 3916C778 8E78CE00 690B3974 3EB8259F E2627B8D 4C0EC35A\"); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0434\u0440\u0443\u0433\u0438\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u043e\u0432 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e } private static boolean checkPartner(Context context, String pkgname) { if (sWhitelists == null) buildWhitelists(context); return sWhitelists.test(context, pkgname); } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // *** 4 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u0432 \u0441\u043f\u0438\u0441\u043a\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u0434\u043e\u0432\u0435\u0440\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 if (!checkPartner(this, getCallingActivity().getPackageName())) { Toast.makeText(this, \"\u0412\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0430\u0440\u0442\u043d\u0451\u0440\u043e\u043c\", Toast.LENGTH_LONG).show(); finish(); return; } // *** 5 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" Toast.makeText(this, \"\u0417\u0430\u043f\u0443\u0449\u0435\u043d\u043e \u0438\u0437 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430\", Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 6 *** \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0439\u0442\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0443 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u043a \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435-\u043f\u0430\u0440\u0442\u043d\u0451\u0440 \u0438\u043c\u0435\u0435\u0442 \u043f\u0440\u0430\u0432\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f, \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430\"); setResult(RESULT_OK, intent); finish(); } } PkgCertWhitelist.java package com.swordfishsecurity.appsec.android.shared; import java.util.HashMap; import java.util.Map; import android.content.Context; public class PkgCertWhitelists { private Map<String, String> mWhitelists = new HashMap<String, String>(); public boolean add(String pkgname, String sha256) { if (pkgname == null) return false; if (sha256 == null) return false; sha256 = sha256.replaceAll(\" \", \"\"); if (sha256.length() != 64) return false; // SHA-256 -> 32 bytes -> 64 chars sha256 = sha256.toUpperCase(); if (sha256.replaceAll(\"[0-9A-F]+\", \"\").length() != 0) return false; // found non hex char mWhitelists.put(pkgname, sha256); return true; } public boolean test(Context ctx, String pkgname) { // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 String correctHash = mWhitelists.get(pkgname); // \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0441 \u0445\u0435\u0448\u0435\u043c \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 return PkgCert.test(ctx, pkgname, correctHash); } } PkgCert.java package com.swordfishsecurity.appsec.android.shared; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.PackageManager.NameNotFoundException; import android.content.pm.Signature; public class PkgCert { public static boolean test(Context ctx, String pkgname, String correctHash) { if (correctHash == null) return false; correctHash = correctHash.replaceAll(\" \", \"\"); return correctHash.equals(hash(ctx, pkgname)); } public static String hash(Context ctx, String pkgname) { if (pkgname == null) return null; try { PackageManager pm = ctx.getPackageManager(); PackageInfo pkginfo = pm.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES); if (pkginfo.signatures.length != 1) return null; Signature sig = pkginfo.signatures[0]; byte[] cert = sig.toByteArray(); byte[] sha256 = computeSha256(cert); return byte2hex(sha256); } catch (NameNotFoundException e) { return null; } } private static byte[] computeSha256(byte[] data) { try { return MessageDigest.getInstance(\"SHA-256\").digest(data); } catch (NoSuchAlgorithmException e) { return null; } } private static String byte2hex(byte[] data) { if (data == null) return null; final StringBuilder hexadecimal = new StringBuilder(); for (final byte b : data) { hexadecimal.append(String.format(\"%02X\", b)); } return hexadecimal.toString(); } } Using Partner Activity If you are going to use an Activity from a partner application, the following rules need to be followed: Verify that a target application's certificate is on the \"white list\". Do not set the FLAG_ACTIVITY_NEW_TASK flag in the Intent that will be used to start an Activity . Send ( using putExtra ) only information that the partner application has the right to access, no more. Use explicit Intent to start a Partner Activity . Use startActivityForResult() to start a Partner Activity . Verify the result data and process it securely, even though it was obtained from a partner application. To implement the first item, you can use the following code examples: AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.partneruser\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <activity android:name=\"com.swordfishsecurity.appsec.android.activity.partneruser.PartnerUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> PartnerUserActivity.java package com.swordfishsecurity.appsec.android.activity.partneruser; import com.swordfishsecurity.appsec.android.shared.PkgCertWhitelists; import com.swordfishsecurity.appsec.android.shared.Utils; import android.app.Activity; import android.content.ActivityNotFoundException; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PartnerUserActivity extends Activity { // *** 1 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \"\u0431\u0435\u043b\u043e\u043c \u0441\u043f\u0438\u0441\u043a\u0435\" private static PkgCertWhitelists sWhitelists = null; private static void buildWhitelists(Context context) { boolean isdebug = Utils.isDebuggable(context); sWhitelists = new PkgCertWhitelists(); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneractivity sWhitelists.add(\"com.swordfishsecurity.appsec.android.activity.partneractivity\", isdebug ? // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \"androiddebugkey\" \u0438\u0437 debug.keystore. \"0EFB7236 328348A9 89718BAD DF57F544 D5CCB4AE B9DB34BC 1E29DD26 F77C8255\" : // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneractivity \"D397D343 A5CBC10F 4EDDEB7C A10062DE 5690984F 1FB9E88B D7B3A7C2 42E142CA\"); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0434\u0440\u0443\u0433\u0438\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u043e\u0432 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e } private static boolean checkPartner(Context context, String pkgname) { if (sWhitelists == null) buildWhitelists(context); return sWhitelists.test(context, pkgname); } private static final int REQUEST_CODE = 1; // \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0446\u0435\u043b\u0435\u0432\u043e\u0439 partner Activity private static final String TARGET_PACKAGE = \"com.swordfishsecurity.appsec.android.activity.partneractivity\"; private static final String TARGET_ACTIVITY = \"com.swordfishsecurity.appsec.android.activity.partneractivity.PartnerActivity\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } public void onUseActivityClick(View view) { // *** 1 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \"\u0431\u0435\u043b\u043e\u043c \u0441\u043f\u0438\u0441\u043a\u0435\" if (!checkPartner(this, TARGET_PACKAGE)) { Toast.makeText(this, \"\u0426\u0435\u043b\u0435\u0432\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0441\u043a\u043e\u0435\", Toast.LENGTH_LONG).show(); return; } try { // *** 2 *** \u041d\u0435 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0439\u0442\u0435 \u0444\u043b\u0430\u0433 FLAG_ACTIVITY_NEW_TASK \u0432 Intent, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity Intent intent = new Intent(); // *** 3 *** \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0439\u0442\u0435 (\u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e `putExtra`) \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0443 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u043a \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435-\u043f\u0430\u0440\u0442\u043d\u0451\u0440 \u0438\u043c\u0435\u0435\u0442 \u043f\u0440\u0430\u0432\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f, \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 intent.putExtra(\"PARAM\", \"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430\"); // *** 4 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 partner Activity intent.setClassName(TARGET_PACKAGE, TARGET_ACTIVITY); // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 startActivityForResult() \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 partner Activity startActivityForResult(intent, REQUEST_CODE); } catch (ActivityNotFoundException e) { Toast.makeText(this, \"\u0426\u0435\u043b\u0435\u0432\u0430\u044f Actvity \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", Toast.LENGTH_LONG).show(); } } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode != RESULT_OK) return; switch (requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); // *** 6 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u0438\u0437 Activity \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" Toast.makeText(this, String.format(\"Received result: \\\"%s\\\"\", result), Toast.LENGTH_LONG).show(); break; } } } PkgCertWhitelist.java package com.swordfishsecurity.appsec.android.shared; import java.util.HashMap; import java.util.Map; import android.content.Context; public class PkgCertWhitelists { private Map<String, String> mWhitelists = new HashMap<String, String>(); public boolean add(String pkgname, String sha256) { if (pkgname == null) return false; if (sha256 == null) return false; sha256 = sha256.replaceAll(\" \", \"\"); if (sha256.length() != 64) return false; // SHA-256 -> 32 bytes -> 64 chars sha256 = sha256.toUpperCase(); if (sha256.replaceAll(\"[0-9A-F]+\", \"\").length() != 0) return false; // found non hex char mWhitelists.put(pkgname, sha256); return true; } public boolean test(Context ctx, String pkgname) { // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 String correctHash = mWhitelists.get(pkgname); // \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0441 \u0445\u0435\u0448\u0435\u043c \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 return PkgCert.test(ctx, pkgname, correctHash); } } PkgCert.java package com.swordfishsecurity.appsec.android.shared; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.PackageManager.NameNotFoundException; import android.content.pm.Signature; public class PkgCert { public static boolean test(Context ctx, String pkgname, String correctHash) { if (correctHash == null) return false; correctHash = correctHash.replaceAll(\" \", \"\"); return correctHash.equals(hash(ctx, pkgname)); } public static String hash(Context ctx, String pkgname) { if (pkgname == null) return null; try { PackageManager pm = ctx.getPackageManager(); PackageInfo pkginfo = pm.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES); if (pkginfo.signatures.length != 1) return null; Signature sig = pkginfo.signatures[0]; byte[] cert = sig.toByteArray(); byte[] sha256 = computeSha256(cert); return byte2hex(sha256); } catch (NameNotFoundException e) { return null; } } private static byte[] computeSha256(byte[] data) { try { return MessageDigest.getInstance(\"SHA-256\").digest(data); } catch (NoSuchAlgorithmException e) { return null; } } private static String byte2hex(byte[] data) { if (data == null) return null; final StringBuilder hexadecimal = new StringBuilder(); for (final byte b : data) { hexadecimal.append(String.format(\"%02X\", b)); } return hexadecimal.toString(); } } Links https://developer.android.com/guide/topics/manifest/activity-element#exported https://blog.oversecured.com/Android-Access-to-app-protected-components/","title":"Possibility to run private Activity indirectly"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/#possibility-to-run-private-activity-indirectly","text":"Severity: \u0421\u0420\u0415\u0414\u041d\u042f\u042f Detection method: IAST","title":"Possibility to run private Activity indirectly"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/#description","text":"This vulnerability allows to start an internal non-exportable Activity of an application. This can cause quite a wide range of problems, from authentication bypass to compromising user data. The vulnerability is present in applications that use Intent from an untrusted source (for example, obtained from a third-party application using getIntent , getParcelableExtra or onActivityResult methods) to start ( startActivity , startActivityForResult ) their internal Activity. Hereinafter the \" to-be-redirected Intent \" term will be used, i.e. Intent obtained from an untrusted source and further used to start an Activity . For example, a malicious application can use such code: Intent intent = new Intent(\"vuln.app.pkg.LOGIN\"); Intent redirIntent = new Intent(); redirIntent.setComponent(new ComponentName(\"vuln.app.pkg\", \"vuln.app.pkg.PrivateActivity\")); intent.putExtra(\"redirect_intent\", redirIntent); startActivity(intent); Targeted application: Intent redirectIntent = getIntent().getParcelableExtra(\"redirect_intent\"); if(redirectIntent != null) { startActivity(redirectIntent); } else { startActivity(new Intent(this, MainActivity.class)); } finish(); Calling such code from a malicious application will launch the vulnerable application's internal Activity ( vuln.app.pkg.PrivateActivity )","title":"Description"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/#recommendations","text":"To avoid such problems in the application, you need to make sure to follow a few rules: Implement private/in-house visibility for components that accept \" to-be-redirected Intent \" and use it to later run private/in-house Activity . For example, declaration of Activity internal - no intent-filter or exported flag is set to false : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.privateactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Private activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> <!-- Public activity \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c\u0430\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e --> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Validate \" to-be-redirected Intent \" for maliciousness - it should not be sent to private/in-house Activity : Intent intent = getIntent(); Intent redirectIntent = (Intent) intent.getParcelableExtra(\u201credirect_intent\u201d); ComponentName name = redirectIntent.resolveActivity(getPackageManager()); // \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0446\u0435\u043b\u0435\u0432\u043e\u0435 \u0438\u043c\u044f \u043f\u0430\u043a\u0435\u0442\u0430 \u0438 \u043a\u043b\u0430\u0441\u0441\u0430 if(name.getPackageName().equals(\u201csafe_package\u201d) && name.getClassName().equals(\u201csafe_class\u201d)) { startActivity(redirectIntent); }","title":"Recommendations"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/#partner-activity","text":"Another way is to work with partner applications. They are applications that are used by collaborating companies that want to share information and functionality securely. Within this exchange, the concept of Partner Activity is introduced. This is an Activity that can only be shared from applications that are developed by partner companies. There is a risk that a third-party application will read contents of Intent used to start an Activity . So you need to make sure that if the Intent used to start an Activity includes sensitive information, protective measures are in place to prevent a malicious application from accessing it.","title":"Partner Activity"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/#creating-a-partner-activity","text":"There are several rules to follow when creating a Partner Activity : Do not use taskAffinity . Do not use launchMode . Do not declare intent-filter and explicitly specify the exported=\"true\" attribute. Make sure that a certificate of the calling application is included in the list of trusted application certificates. Verify and securely process received Intent , even though it was received from the same partner application. Return only information that the partner application has the right to access. To implement item 4, it is necessary to organize receipt of a fingerprint of certificates of trusted applications and their registration in our application. To do this, you can use the following code examples with detailed comments. AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.partneractivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Partner activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u041d\u0435 \u043e\u0431\u044c\u044f\u0432\u043b\u044f\u0439\u0442\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u044b \u0438 \u044f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PartnerActivity\" android:exported=\"true\" /> </application> </manifest> PartnerActivity.java package com.swordfishsecurity.appsec.android.activity.partneractivity; import com.swordfishsecurity.appsec.android.shared.PkgCertWhitelists; import com.swordfishsecurity.appsec.android.shared.Utils; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PartnerActivity extends Activity { // *** 4 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u0432 \u0441\u043f\u0438\u0441\u043a\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u0434\u043e\u0432\u0435\u0440\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 private static PkgCertWhitelists sWhitelists = null; private static void buildWhitelists(Context context) { boolean isdebug = Utils.isDebuggable(context); sWhitelists = new PkgCertWhitelists(); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneruser sWhitelists.add(\"com.swordfishsecurity.appsec.android.activity.partneruser\", isdebug ? // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \"androiddebugkey\" \u0438\u0437 debug.keystore. \"0EFB7236 328348A9 89718BAD DF57F544 D5CCB4AE B9DB34BC 1E29DD26 F77C8255\" : // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneruser \"1F039BB5 7861C27A 3916C778 8E78CE00 690B3974 3EB8259F E2627B8D 4C0EC35A\"); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0434\u0440\u0443\u0433\u0438\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u043e\u0432 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e } private static boolean checkPartner(Context context, String pkgname) { if (sWhitelists == null) buildWhitelists(context); return sWhitelists.test(context, pkgname); } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // *** 4 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u0432 \u0441\u043f\u0438\u0441\u043a\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u0434\u043e\u0432\u0435\u0440\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 if (!checkPartner(this, getCallingActivity().getPackageName())) { Toast.makeText(this, \"\u0412\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0430\u0440\u0442\u043d\u0451\u0440\u043e\u043c\", Toast.LENGTH_LONG).show(); finish(); return; } // *** 5 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" Toast.makeText(this, \"\u0417\u0430\u043f\u0443\u0449\u0435\u043d\u043e \u0438\u0437 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430\", Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 6 *** \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0439\u0442\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0443 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u043a \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435-\u043f\u0430\u0440\u0442\u043d\u0451\u0440 \u0438\u043c\u0435\u0435\u0442 \u043f\u0440\u0430\u0432\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f, \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430\"); setResult(RESULT_OK, intent); finish(); } } PkgCertWhitelist.java package com.swordfishsecurity.appsec.android.shared; import java.util.HashMap; import java.util.Map; import android.content.Context; public class PkgCertWhitelists { private Map<String, String> mWhitelists = new HashMap<String, String>(); public boolean add(String pkgname, String sha256) { if (pkgname == null) return false; if (sha256 == null) return false; sha256 = sha256.replaceAll(\" \", \"\"); if (sha256.length() != 64) return false; // SHA-256 -> 32 bytes -> 64 chars sha256 = sha256.toUpperCase(); if (sha256.replaceAll(\"[0-9A-F]+\", \"\").length() != 0) return false; // found non hex char mWhitelists.put(pkgname, sha256); return true; } public boolean test(Context ctx, String pkgname) { // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 String correctHash = mWhitelists.get(pkgname); // \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0441 \u0445\u0435\u0448\u0435\u043c \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 return PkgCert.test(ctx, pkgname, correctHash); } } PkgCert.java package com.swordfishsecurity.appsec.android.shared; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.PackageManager.NameNotFoundException; import android.content.pm.Signature; public class PkgCert { public static boolean test(Context ctx, String pkgname, String correctHash) { if (correctHash == null) return false; correctHash = correctHash.replaceAll(\" \", \"\"); return correctHash.equals(hash(ctx, pkgname)); } public static String hash(Context ctx, String pkgname) { if (pkgname == null) return null; try { PackageManager pm = ctx.getPackageManager(); PackageInfo pkginfo = pm.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES); if (pkginfo.signatures.length != 1) return null; Signature sig = pkginfo.signatures[0]; byte[] cert = sig.toByteArray(); byte[] sha256 = computeSha256(cert); return byte2hex(sha256); } catch (NameNotFoundException e) { return null; } } private static byte[] computeSha256(byte[] data) { try { return MessageDigest.getInstance(\"SHA-256\").digest(data); } catch (NoSuchAlgorithmException e) { return null; } } private static String byte2hex(byte[] data) { if (data == null) return null; final StringBuilder hexadecimal = new StringBuilder(); for (final byte b : data) { hexadecimal.append(String.format(\"%02X\", b)); } return hexadecimal.toString(); } }","title":"Creating a Partner Activity"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/#using-partner-activity","text":"If you are going to use an Activity from a partner application, the following rules need to be followed: Verify that a target application's certificate is on the \"white list\". Do not set the FLAG_ACTIVITY_NEW_TASK flag in the Intent that will be used to start an Activity . Send ( using putExtra ) only information that the partner application has the right to access, no more. Use explicit Intent to start a Partner Activity . Use startActivityForResult() to start a Partner Activity . Verify the result data and process it securely, even though it was obtained from a partner application. To implement the first item, you can use the following code examples: AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.partneruser\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <activity android:name=\"com.swordfishsecurity.appsec.android.activity.partneruser.PartnerUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> PartnerUserActivity.java package com.swordfishsecurity.appsec.android.activity.partneruser; import com.swordfishsecurity.appsec.android.shared.PkgCertWhitelists; import com.swordfishsecurity.appsec.android.shared.Utils; import android.app.Activity; import android.content.ActivityNotFoundException; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PartnerUserActivity extends Activity { // *** 1 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \"\u0431\u0435\u043b\u043e\u043c \u0441\u043f\u0438\u0441\u043a\u0435\" private static PkgCertWhitelists sWhitelists = null; private static void buildWhitelists(Context context) { boolean isdebug = Utils.isDebuggable(context); sWhitelists = new PkgCertWhitelists(); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneractivity sWhitelists.add(\"com.swordfishsecurity.appsec.android.activity.partneractivity\", isdebug ? // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \"androiddebugkey\" \u0438\u0437 debug.keystore. \"0EFB7236 328348A9 89718BAD DF57F544 D5CCB4AE B9DB34BC 1E29DD26 F77C8255\" : // \u0425\u0435\u0448 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043a\u043b\u044e\u0447\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430 com.swordfishsecurity.appsec.android.activity.partneractivity \"D397D343 A5CBC10F 4EDDEB7C A10062DE 5690984F 1FB9E88B D7B3A7C2 42E142CA\"); // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0434\u0440\u0443\u0433\u0438\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u043e\u0432 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e } private static boolean checkPartner(Context context, String pkgname) { if (sWhitelists == null) buildWhitelists(context); return sWhitelists.test(context, pkgname); } private static final int REQUEST_CODE = 1; // \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0446\u0435\u043b\u0435\u0432\u043e\u0439 partner Activity private static final String TARGET_PACKAGE = \"com.swordfishsecurity.appsec.android.activity.partneractivity\"; private static final String TARGET_ACTIVITY = \"com.swordfishsecurity.appsec.android.activity.partneractivity.PartnerActivity\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } public void onUseActivityClick(View view) { // *** 1 *** \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0439\u0442\u0435, \u0447\u0442\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \"\u0431\u0435\u043b\u043e\u043c \u0441\u043f\u0438\u0441\u043a\u0435\" if (!checkPartner(this, TARGET_PACKAGE)) { Toast.makeText(this, \"\u0426\u0435\u043b\u0435\u0432\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0441\u043a\u043e\u0435\", Toast.LENGTH_LONG).show(); return; } try { // *** 2 *** \u041d\u0435 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0439\u0442\u0435 \u0444\u043b\u0430\u0433 FLAG_ACTIVITY_NEW_TASK \u0432 Intent, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity Intent intent = new Intent(); // *** 3 *** \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0439\u0442\u0435 (\u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e `putExtra`) \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0443 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u043a \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435-\u043f\u0430\u0440\u0442\u043d\u0451\u0440 \u0438\u043c\u0435\u0435\u0442 \u043f\u0440\u0430\u0432\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f, \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 intent.putExtra(\"PARAM\", \"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f-\u043f\u0430\u0440\u0442\u043d\u0451\u0440\u0430\"); // *** 4 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 partner Activity intent.setClassName(TARGET_PACKAGE, TARGET_ACTIVITY); // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 startActivityForResult() \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 partner Activity startActivityForResult(intent, REQUEST_CODE); } catch (ActivityNotFoundException e) { Toast.makeText(this, \"\u0426\u0435\u043b\u0435\u0432\u0430\u044f Actvity \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", Toast.LENGTH_LONG).show(); } } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode != RESULT_OK) return; switch (requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); // *** 6 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u0438\u0437 Activity \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" Toast.makeText(this, String.format(\"Received result: \\\"%s\\\"\", result), Toast.LENGTH_LONG).show(); break; } } } PkgCertWhitelist.java package com.swordfishsecurity.appsec.android.shared; import java.util.HashMap; import java.util.Map; import android.content.Context; public class PkgCertWhitelists { private Map<String, String> mWhitelists = new HashMap<String, String>(); public boolean add(String pkgname, String sha256) { if (pkgname == null) return false; if (sha256 == null) return false; sha256 = sha256.replaceAll(\" \", \"\"); if (sha256.length() != 64) return false; // SHA-256 -> 32 bytes -> 64 chars sha256 = sha256.toUpperCase(); if (sha256.replaceAll(\"[0-9A-F]+\", \"\").length() != 0) return false; // found non hex char mWhitelists.put(pkgname, sha256); return true; } public boolean test(Context ctx, String pkgname) { // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 String correctHash = mWhitelists.get(pkgname); // \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0445\u0435\u0448\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f pkgname \u0441 \u0445\u0435\u0448\u0435\u043c \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438\u0437 \u0431\u0435\u043b\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 return PkgCert.test(ctx, pkgname, correctHash); } } PkgCert.java package com.swordfishsecurity.appsec.android.shared; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.PackageManager.NameNotFoundException; import android.content.pm.Signature; public class PkgCert { public static boolean test(Context ctx, String pkgname, String correctHash) { if (correctHash == null) return false; correctHash = correctHash.replaceAll(\" \", \"\"); return correctHash.equals(hash(ctx, pkgname)); } public static String hash(Context ctx, String pkgname) { if (pkgname == null) return null; try { PackageManager pm = ctx.getPackageManager(); PackageInfo pkginfo = pm.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES); if (pkginfo.signatures.length != 1) return null; Signature sig = pkginfo.signatures[0]; byte[] cert = sig.toByteArray(); byte[] sha256 = computeSha256(cert); return byte2hex(sha256); } catch (NameNotFoundException e) { return null; } } private static byte[] computeSha256(byte[] data) { try { return MessageDigest.getInstance(\"SHA-256\").digest(data); } catch (NoSuchAlgorithmException e) { return null; } } private static String byte2hex(byte[] data) { if (data == null) return null; final StringBuilder hexadecimal = new StringBuilder(); for (final byte b : data) { hexadecimal.append(String.format(\"%02X\", b)); } return hexadecimal.toString(); } }","title":"Using Partner Activity"},{"location":"rg/en/android/ability_to_run_private_activity_indirectly/#links","text":"https://developer.android.com/guide/topics/manifest/activity-element#exported https://blog.oversecured.com/Android-Access-to-app-protected-components/","title":"Links"},{"location":"rg/en/android/access_to_an_arbitrary_contentprovider/","text":"Possibility to access an arbitrary ContentProvider Severity: MEDIUM Detection method: IAST Description This vulnerability allows access to an internal non-exportable ContentProvider . The vulnerability is present in applications that use Intent from an untrusted source (e.g. obtained from a third-party application using getIntent , getParcelableExtra or onActivityResult methods) to return data using the setResult method. For example, a malicious application can use such code: Intent intent = new Intent(); intent.setData(Uri.parse(\"content://com.victim.provider/secret_data.txt\")); intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.setClassName(\"vuln.app.pkg\", \"vuln.app.pkg.SomeActivity\"); startActivityForResult(intent, 0); Target vulnerable application ( SomeActivity.java ): super.onCreate(savedInstanceState); setResult(RESULT_OK, getIntent()); finish(); As a result, the malicious application will gain access to the ContentProvider com.victim.provider of the vulnerable application. Recommendations To avoid such problems in the application, you need to make sure to follow a few rules: Implement private/in-house visibility for components that accept Intent and use it in the setResult method. For example, declaration of Activity internal - no intent-filter or exported flag is set to false . <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.privateactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Private activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> <!-- Public activity \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c\u0430\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e --> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Validate Intent for maliciousness: Such Intent should not be directed to private/in-house components or components of external applications. Intent intent = getIntent(); Intent redirectIntent = (Intent) intent.getParcelableExtra(\u201credirect_intent\u201d); ComponentName name = redirectIntent.resolveActivity(getPackageManager()); // \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0446\u0435\u043b\u0435\u0432\u043e\u0435 \u0438\u043c\u044f \u043f\u0430\u043a\u0435\u0442\u0430 \u0438 \u043a\u043b\u0430\u0441\u0441\u0430 if(name.getPackageName().equals(\u201csafe_package\u201d) && name.getClassName().equals(\u201csafe_class\u201d)) { startActivity(redirectIntent); } If you still want to run an external application component, then you need to validate/sanitize Permissions passed into \" to-be-redirected Intent \". An example of validation: Intent resultIntent = (Intent) intent.getParcelableExtra(\u201cresult_intent\u201d); int flags = resultIntent.getFlags(); if((flags & Intent.FLAG_GRANT_READ_URI_PERMISSION == 0) && (flags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION == 0)) { setResult(RESULT_OK, resultIntent); } An example of sanitization: resultIntent.removeFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); resultIntent.removeFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); setResult(RESULT_OK, intent); Links https://developer.android.com/guide/topics/manifest/activity-element#exported https://blog.oversecured.com/Android-Access-to-app-protected-components/","title":"Possibility to access an arbitrary ContentProvider"},{"location":"rg/en/android/access_to_an_arbitrary_contentprovider/#possibility-to-access-an-arbitrary-contentprovider","text":"Severity: MEDIUM Detection method: IAST","title":"Possibility to access an arbitrary ContentProvider"},{"location":"rg/en/android/access_to_an_arbitrary_contentprovider/#description","text":"This vulnerability allows access to an internal non-exportable ContentProvider . The vulnerability is present in applications that use Intent from an untrusted source (e.g. obtained from a third-party application using getIntent , getParcelableExtra or onActivityResult methods) to return data using the setResult method. For example, a malicious application can use such code: Intent intent = new Intent(); intent.setData(Uri.parse(\"content://com.victim.provider/secret_data.txt\")); intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.setClassName(\"vuln.app.pkg\", \"vuln.app.pkg.SomeActivity\"); startActivityForResult(intent, 0); Target vulnerable application ( SomeActivity.java ): super.onCreate(savedInstanceState); setResult(RESULT_OK, getIntent()); finish(); As a result, the malicious application will gain access to the ContentProvider com.victim.provider of the vulnerable application.","title":"Description"},{"location":"rg/en/android/access_to_an_arbitrary_contentprovider/#recommendations","text":"To avoid such problems in the application, you need to make sure to follow a few rules: Implement private/in-house visibility for components that accept Intent and use it in the setResult method. For example, declaration of Activity internal - no intent-filter or exported flag is set to false . <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.swordfishsecurity.appsec.android.activity.privateactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Private activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> <!-- Public activity \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c\u0430\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e --> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Validate Intent for maliciousness: Such Intent should not be directed to private/in-house components or components of external applications. Intent intent = getIntent(); Intent redirectIntent = (Intent) intent.getParcelableExtra(\u201credirect_intent\u201d); ComponentName name = redirectIntent.resolveActivity(getPackageManager()); // \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0446\u0435\u043b\u0435\u0432\u043e\u0435 \u0438\u043c\u044f \u043f\u0430\u043a\u0435\u0442\u0430 \u0438 \u043a\u043b\u0430\u0441\u0441\u0430 if(name.getPackageName().equals(\u201csafe_package\u201d) && name.getClassName().equals(\u201csafe_class\u201d)) { startActivity(redirectIntent); } If you still want to run an external application component, then you need to validate/sanitize Permissions passed into \" to-be-redirected Intent \". An example of validation: Intent resultIntent = (Intent) intent.getParcelableExtra(\u201cresult_intent\u201d); int flags = resultIntent.getFlags(); if((flags & Intent.FLAG_GRANT_READ_URI_PERMISSION == 0) && (flags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION == 0)) { setResult(RESULT_OK, resultIntent); } An example of sanitization: resultIntent.removeFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); resultIntent.removeFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); setResult(RESULT_OK, intent);","title":"Recommendations"},{"location":"rg/en/android/access_to_an_arbitrary_contentprovider/#links","text":"https://developer.android.com/guide/topics/manifest/activity-element#exported https://blog.oversecured.com/Android-Access-to-app-protected-components/","title":"Links"},{"location":"rg/en/android/access_to_an_arbitrary_file/","text":"Possibility to access an arbitrary file Severity: MEDIUM Detection method: IAST Description This vulnerability allows to get access to arbitrary application files. The vulnerability is present in applications that do not properly validate the input Uri-parameter and use it to access file handling methods. A malicious application can specifically generate a Uri, pass it in one way or another to a vulnerable application, and gain access to an arbitrary file. An example of vulnerable code: private void takeSomeSharedFile() { Intent interceptableIntent = new Intent(\"vuln.app.pkg.INTERCAPTABLE\"); startActivityForResult(interceptableIntent, 1001); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if(resultCode == -1 && data != null) { if(requestCode == 1001) { copyToCache(data.getData()); } } } public static File copyToCache(Uri uri) { try { File out = new File(getExternalCacheDir(), \"\" + System.currentTimeMillis()); InputStream i = getContentResolver().openInputStream(uri); OutputStream o = new FileOutputStream(out); IOUtils.copy(i, o); i.close(); o.close(); return out; } catch (Exception e) { return null; } } A malicious application can use such code: Intent intent = new Intent(); File privFile = new File(\"/data/data/vuln.app.pkg/databases/main.db\"); intent.setData(Uri.fromFile(privFile)); setResult(RESULT_OK, intent); finish(); As a result, the vulnerable application will copy the main.db file to the /storage/emulated/0/Android/data/vuln.app.pkg/1650464271 file, which can be accessed by the malicious application. Recommendations It is necessary to validate the canonical path of a file just before calling file operation methods on that file: File file = new File(uri); if (!file.getCanonicalPath().startsWith(sdcardDir)) { throw new IllegalArgumentException(); } .","title":"Possibility to access an arbitrary file"},{"location":"rg/en/android/access_to_an_arbitrary_file/#possibility-to-access-an-arbitrary-file","text":"Severity: MEDIUM Detection method: IAST","title":"Possibility to access an arbitrary file"},{"location":"rg/en/android/access_to_an_arbitrary_file/#description","text":"This vulnerability allows to get access to arbitrary application files. The vulnerability is present in applications that do not properly validate the input Uri-parameter and use it to access file handling methods. A malicious application can specifically generate a Uri, pass it in one way or another to a vulnerable application, and gain access to an arbitrary file. An example of vulnerable code: private void takeSomeSharedFile() { Intent interceptableIntent = new Intent(\"vuln.app.pkg.INTERCAPTABLE\"); startActivityForResult(interceptableIntent, 1001); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if(resultCode == -1 && data != null) { if(requestCode == 1001) { copyToCache(data.getData()); } } } public static File copyToCache(Uri uri) { try { File out = new File(getExternalCacheDir(), \"\" + System.currentTimeMillis()); InputStream i = getContentResolver().openInputStream(uri); OutputStream o = new FileOutputStream(out); IOUtils.copy(i, o); i.close(); o.close(); return out; } catch (Exception e) { return null; } } A malicious application can use such code: Intent intent = new Intent(); File privFile = new File(\"/data/data/vuln.app.pkg/databases/main.db\"); intent.setData(Uri.fromFile(privFile)); setResult(RESULT_OK, intent); finish(); As a result, the vulnerable application will copy the main.db file to the /storage/emulated/0/Android/data/vuln.app.pkg/1650464271 file, which can be accessed by the malicious application.","title":"Description"},{"location":"rg/en/android/access_to_an_arbitrary_file/#recommendations","text":"It is necessary to validate the canonical path of a file just before calling file operation methods on that file: File file = new File(uri); if (!file.getCanonicalPath().startsWith(sdcardDir)) { throw new IllegalArgumentException(); } .","title":"Recommendations"},{"location":"rg/en/android/an_application_allows_network_connections_via_http/","text":"An application allows network connections via HTTP Severity: HIGH Detection method: SAST, MANIFEST Description The AndroidManifest settings have the android:usesCleartextTraffic=true attribute, allowing the application to communicate with any servers via the unsecured HTTP protocol. This setting depends on several parameters and its default value also depends on targetSDK specified in the application manifest: If the android:networkSecurityConfig attribute is present in AndroidManifest, the android:usesCleartextTraffic value is ignored, since all network settings are defined inside the network configuration file. If targetSDK =\\< 27, the default attribute value is true (if not specified in the manifest). If targetSDK >= 28, the default attribute value is false (if not specified in the manifest). An example of a vulnerable configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:usesCleartextTraffic=\"true\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest> Recommendations It is recommended to explicitly disable the ability to transfer data over an unsecured HTTP protocol by setting the android:usesCleartextTraffic attribute to false . An example of a secure configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:usesCleartextTraffic=\"false\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest> Links https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic https://imstudio.medium.com/android-8-cleartext-http-traffic-not-permitted-73c1c9e3b803","title":"An application allows network connections via HTTP"},{"location":"rg/en/android/an_application_allows_network_connections_via_http/#an-application-allows-network-connections-via-http","text":"Severity: HIGH Detection method: SAST, MANIFEST","title":"An application allows network connections via HTTP"},{"location":"rg/en/android/an_application_allows_network_connections_via_http/#description","text":"The AndroidManifest settings have the android:usesCleartextTraffic=true attribute, allowing the application to communicate with any servers via the unsecured HTTP protocol. This setting depends on several parameters and its default value also depends on targetSDK specified in the application manifest: If the android:networkSecurityConfig attribute is present in AndroidManifest, the android:usesCleartextTraffic value is ignored, since all network settings are defined inside the network configuration file. If targetSDK =\\< 27, the default attribute value is true (if not specified in the manifest). If targetSDK >= 28, the default attribute value is false (if not specified in the manifest). An example of a vulnerable configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:usesCleartextTraffic=\"true\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest>","title":"Description"},{"location":"rg/en/android/an_application_allows_network_connections_via_http/#recommendations","text":"It is recommended to explicitly disable the ability to transfer data over an unsecured HTTP protocol by setting the android:usesCleartextTraffic attribute to false . An example of a secure configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:usesCleartextTraffic=\"false\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest>","title":"Recommendations"},{"location":"rg/en/android/an_application_allows_network_connections_via_http/#links","text":"https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic https://imstudio.medium.com/android-8-cleartext-http-traffic-not-permitted-73c1c9e3b803","title":"Links"},{"location":"rg/en/android/application_is_not_obfuscated/","text":"Application is not obfuscated Severity: LOW Detection method: SAST, APK Description The source code of the application is not obfuscated or is obfuscated with insufficient coverage. Weak or no obfuscation of the application leads to easier examination of the code after decompilation. This allows an attacker to easily analyze the application code to find vulnerabilities or ways to bypass security. Recommendations Before publishing an application, make sure that rules for obfuscation are enabled in the release version of the application and that they are configured properly. One common solution is to use the ProGuard built-in obfuscator rules to automatically enable/disable obfuscation depending on the build type (release/debug). An example of ProGuard settings: optimizationpasses 5 -dontusemixedcaseclassnames -dontskipnonpubliclibraryclasses -dontskipnonpubliclibraryclassmembers -dontpreverify -verbose -dump class_files.txt -printseeds seeds.txt -printusage unused.txt -printmapping mapping.txt -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* -allowaccessmodification -keepattributes *Annotation* -renamesourcefileattribute SourceFile -keepattributes SourceFile,LineNumberTable -repackageclasses '' Enabling the use of ProGuard for the release build of an application: buildTypes { ... release { minifyEnabled true proguardFiles 'proguard-rules.pro', getDefaultProguardFile('proguard-android.txt') } } It is also good practice to obfuscate the open source libraries used in the project. Recently, more and more libraries are distributed with ready-made configuration files for obfuscation. ProGuard knows how to look inside the archive, find the library configuration files and add it to the rest of the options. Check every library you use for such a file. If the authors of the library do not pack the config file in the archive, maybe they took care and wrote the rules on their website, the repository page or in the README file. Try to find the config file for the version of the library you are using yourself. Links https://habr.com/ru/post/415499/ https://developer.android.com/studio/build/shrink-code https://www.guardsquare.com/en/products/proguard/manual/examples https://github.com/OWASP/owasp-stg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#make-sure-that-free-security-features-are-activated-mstg-code-9","title":"Application is not obfuscated"},{"location":"rg/en/android/application_is_not_obfuscated/#application-is-not-obfuscated","text":"Severity: LOW Detection method: SAST, APK","title":"Application is not obfuscated"},{"location":"rg/en/android/application_is_not_obfuscated/#description","text":"The source code of the application is not obfuscated or is obfuscated with insufficient coverage. Weak or no obfuscation of the application leads to easier examination of the code after decompilation. This allows an attacker to easily analyze the application code to find vulnerabilities or ways to bypass security.","title":"Description"},{"location":"rg/en/android/application_is_not_obfuscated/#recommendations","text":"Before publishing an application, make sure that rules for obfuscation are enabled in the release version of the application and that they are configured properly. One common solution is to use the ProGuard built-in obfuscator rules to automatically enable/disable obfuscation depending on the build type (release/debug). An example of ProGuard settings: optimizationpasses 5 -dontusemixedcaseclassnames -dontskipnonpubliclibraryclasses -dontskipnonpubliclibraryclassmembers -dontpreverify -verbose -dump class_files.txt -printseeds seeds.txt -printusage unused.txt -printmapping mapping.txt -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* -allowaccessmodification -keepattributes *Annotation* -renamesourcefileattribute SourceFile -keepattributes SourceFile,LineNumberTable -repackageclasses '' Enabling the use of ProGuard for the release build of an application: buildTypes { ... release { minifyEnabled true proguardFiles 'proguard-rules.pro', getDefaultProguardFile('proguard-android.txt') } } It is also good practice to obfuscate the open source libraries used in the project. Recently, more and more libraries are distributed with ready-made configuration files for obfuscation. ProGuard knows how to look inside the archive, find the library configuration files and add it to the rest of the options. Check every library you use for such a file. If the authors of the library do not pack the config file in the archive, maybe they took care and wrote the rules on their website, the repository page or in the README file. Try to find the config file for the version of the library you are using yourself.","title":"Recommendations"},{"location":"rg/en/android/application_is_not_obfuscated/#links","text":"https://habr.com/ru/post/415499/ https://developer.android.com/studio/build/shrink-code https://www.guardsquare.com/en/products/proguard/manual/examples https://github.com/OWASP/owasp-stg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#make-sure-that-free-security-features-are-activated-mstg-code-9","title":"Links"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_request/","text":"Including sensitive information into an HTTPS request Severity: INFO Detection method: DAST, SENSITIVE INFO Description Transfer of confidential information in an HTTPS request is not a vulnerability provided that a communication channel is properly protected, i.e. using correctly implemented SSL-Pinning. Incorrectly implemented protection of the communication channel, however, can be susceptible to a MiTM (\u201cMan in the Middle\u201d) attack. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication. Recommendations Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! note \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly. Example: Correct implementation of SSL-Pinning PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher. Links http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Including sensitive information into an HTTPS request"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_request/#including-sensitive-information-into-an-https-request","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Including sensitive information into an HTTPS request"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_request/#description","text":"Transfer of confidential information in an HTTPS request is not a vulnerability provided that a communication channel is properly protected, i.e. using correctly implemented SSL-Pinning. Incorrectly implemented protection of the communication channel, however, can be susceptible to a MiTM (\u201cMan in the Middle\u201d) attack. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication.","title":"Description"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_request/#recommendations","text":"Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! note \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly.","title":"Recommendations"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_request/#example-correct-implementation-of-ssl-pinning","text":"PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher.","title":"Example: Correct implementation of SSL-Pinning"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_request/#links","text":"http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Links"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_response/","text":"Getting sensitive information in an HTTPS response Severity: INFO Detection method: DAST, NETWORKING Description Transfer of confidential information in an HTTPS request is not a vulnerability provided that a communication channel is properly protected, i.e. using correctly implemented SSL-Pinning. Incorrectly implemented protection of the communication channel, however, can be susceptible to a MiTM (\u201cMan in the Middle\u201d) attack. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication. Recommendations Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! name \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly. Example: Correct implementation of SSL-Pinning PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher. Links http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Getting sensitive information in an HTTPS response"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_response/#getting-sensitive-information-in-an-https-response","text":"Severity: INFO Detection method: DAST, NETWORKING","title":"Getting sensitive information in an HTTPS response"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_response/#description","text":"Transfer of confidential information in an HTTPS request is not a vulnerability provided that a communication channel is properly protected, i.e. using correctly implemented SSL-Pinning. Incorrectly implemented protection of the communication channel, however, can be susceptible to a MiTM (\u201cMan in the Middle\u201d) attack. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication.","title":"Description"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_response/#recommendations","text":"Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! name \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly. Example: Correct implementation of SSL-Pinning PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher.","title":"Recommendations"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_an_https_response/#links","text":"http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Links"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_the_get_request_parameters/","text":"Including sensitive information into the GET request parameters Severity: HIGH Detection method: DAST, NETWORKING Description Some applications use the GET method for passing confidential information (such as passwords, session identifiers etc.) which is displayed in a URL as parameters. Confidential information from URLs might be registered in a variety of places including: Web servers; Any forward or reverse proxy servers between two endpoints; Referrer headers; Web server logs; Browser history; Browser cache. URLs can also be shown on a display, added to bookmarks, or sent to a user via email. They can be passed to third parties in a Referrer header when a user follows external links. Placing confidential information into URL adds up to a risk of a security breach. Vulnerabilities that lead to disclosure of a user's confidential information can also lead to compromises that are very difficult to research. Even if the application itself handles non-sensitive information only, disclosure of information such as passwords put users at risk if they re-use this password in a different application. Recommendations All requests containing sensitive information must use the POST-method; the confidential information must be put into the request body to ensure that the information doesn't get into web server logs or other places accessible by many users. If it's not possible to change the GET-method to POST, additional encryption or hashing of confidential information can be used to prevent data compromisation. Links https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url#:~:text=Description,any%20other%20potentially%20sensitive%20data. https://cwe.mitre.org/data/definitions/598.html https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method","title":"Including sensitive information into the GET request parameters"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_the_get_request_parameters/#including-sensitive-information-into-the-get-request-parameters","text":"Severity: HIGH Detection method: DAST, NETWORKING","title":"Including sensitive information into the GET request parameters"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_the_get_request_parameters/#description","text":"Some applications use the GET method for passing confidential information (such as passwords, session identifiers etc.) which is displayed in a URL as parameters. Confidential information from URLs might be registered in a variety of places including: Web servers; Any forward or reverse proxy servers between two endpoints; Referrer headers; Web server logs; Browser history; Browser cache. URLs can also be shown on a display, added to bookmarks, or sent to a user via email. They can be passed to third parties in a Referrer header when a user follows external links. Placing confidential information into URL adds up to a risk of a security breach. Vulnerabilities that lead to disclosure of a user's confidential information can also lead to compromises that are very difficult to research. Even if the application itself handles non-sensitive information only, disclosure of information such as passwords put users at risk if they re-use this password in a different application.","title":"Description"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_the_get_request_parameters/#recommendations","text":"All requests containing sensitive information must use the POST-method; the confidential information must be put into the request body to ensure that the information doesn't get into web server logs or other places accessible by many users. If it's not possible to change the GET-method to POST, additional encryption or hashing of confidential information can be used to prevent data compromisation.","title":"Recommendations"},{"location":"rg/en/android/inclusion_of_sensitive_information_into_the_get_request_parameters/#links","text":"https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url#:~:text=Description,any%20other%20potentially%20sensitive%20data. https://cwe.mitre.org/data/definitions/598.html https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method","title":"Links"},{"location":"rg/en/android/insecure_networking_configuration/","text":"Insecure networking configuration Severity: HIGH Detection method: SAST, NETWORK Description The application uses insecurely tuned networking configuration. With the release of Android 6.0 Marshmallow, Google introduced the manifest attribute: android: usesCleartextTraffic , to protect against accidental use of the HTTP protocol. Android 7.0 Nougat expanded this attribute by introducing an Android networking security configuration feature that allows developers to more clearly define connection settings. The network communication configuration is an XML file that configures the network security settings for the Android application. This setting is specified by a special attribute in AndroidManifest.xml \u2014 android:networkSecurityConfig . Connection example: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest ... > <application android:networkSecurityConfig=\"@xml/network_security_config\" ... > ... </application> </manifest> Recommendations The Network Security Config feature allows you to configure network communication settings in a declarative configuration file without changing the application code. These settings can be configured for specific domains and for a specific application. The key opportunities provided by this approach: Custom trust anchors: Configure the certification authorities (CA) that the application will trust during network communication. For example, trusting certain self-signed certificates or restricting the set of public CAs that the application trusts (those added to the trusted ones by the user or those CAs that the system trusts). Debug-only overrides: Configuring connections specifically for the debug version of the application. This allows you to distinguish between development and production environments. Cleartext traffic: Settings to allow or deny connections via HTTP. Certificate pinning: Configuration for SSL Pinning implementation. In the configuration file, you can apply settings for the application in the base-config block, only for specific domains and subdomains in the domain-config block and separately for the debug build of the application in the debug-overrides block. Let's consider examples of settings that are available for customization: Custom trust anchors: Configuring trust to certification authorities Android\u2019s network security configuration gives developers several options for choosing which CAs to trust. By default in Android 7+ (Nougat, Oreo and Pie), the application will only trust certificates that are marked as system: <network-security-config> <base-config> <trust-anchors> <certificates src=\"system\"/> </trust-anchors> </base-config> </network-security-config> In Android 6 (Marshmallow) and lower, the application also trusts the certificates installed by the user. With this setting it is possible to perform a MiTM (man in the middle) attack if the user installs his certificate: <network-security-config> <base-config> <trust-anchors> <certificates src=\"system\"/> <certificates src=\"user\"/> </trust-anchors> </base-config> </network-security-config> It is also possible to enable trust in certificates located in the application's assets: <network-security-config> <base-config> <trust-anchors> <certificates src=\"@raw/my_custom_ca\"/> </trust-anchors> </base-config> </network-security-config> The most secure option is the first one, where the application trusts only the system certificates. Configuring HTTP communication By splitting into separate configurations for the entire application, individual domains, and the debug version, it is possible to control the permissions for using HTTP at each level. Let's take a closer look: in the first example, HTTP data transfer is forbidden at the application level (this is the most secure option): <network-security-config> <base-config cleartextTrafficPermitted=\"false\" /> ... </network-security-config> In some exceptional cases it is necessary to connect via HTTP to certain domains. Exactly for this case there is an opportunity to specify separately what is allowed for different domains: <network-security-config> <domain-config cleartextTrafficPermitted=\"true\"> <domain includeSubdomains=\"true\">insecure.example.com</domain> <domain includeSubdomains=\"true\">insecure.cdn.example2.com</domain> </domain-config> <base-config cleartextTrafficPermitted=\"false\" /> </network-security-config> This setting will only allow HTTPS access for all network connections except for the two that are allowed to communicate over HTTP ( insecure.example.com and insecure.cdn.example2.com ), including their subdomains. The includeSubdomains setting is responsible for enabling subdomains. Certificate Pinning settings Network Security Config allows you to easily connect the Certificate Pinning mechanism to the application. However, it is worth to take into account certain nuances. Let's look at a configuration that at first glance looks like a properly configured one and see how it can be slightly improved: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> </pin-set> </domain-config> </network-security-config> This example has two small disadvantages: The certificate fingerprint (pin-set) does not have an expiration date. There is no backup certificate. If your certificate is about to expire and no expiration date is specified in the settings, the application will stop connecting to the server and generate an error. However, if an expiration date has been set and it expires, the application will switch to the trusted certificate authorities installed in the system. Instead of getting a non-functional application, you will get no SSL Pinning for some time until you update the certificate in the application. To avoid this, if you know the certificate to be used on your server after the current one expires, you can specify it immediately in the \"backup certificates\" settings. Here is an example of the most correct use of the Certificate Pinning functionality: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set expiration=\"2021-01-01\"> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> <!-- backup pin --> <pin digest=\"SHA-256\">fwza0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM1oE=</pin> </pin-set> </domain-config> </network-security-config> Despite all the conveniences of using the Network Security Config, some checks should be performed internally in the application code. For example, you still need to determine if your application performs hostname validation, because Network Security Config does not protect against this type of issue. !!! note \"Note\" Also, before implementation, make sure that third-party libraries support Network Security Config. Otherwise, these security measures may cause problems in your application. Besides, Network Security Config is not supported by lower-level network connections, such as web sockets. Links https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic https://developer.android.com/training/articles/security-config https://www.nowsecure.com/blog/2018/08/15/a-security-analysts-guide-to-network-security-configuration-in-android-p/","title":"Insecure networking configuration"},{"location":"rg/en/android/insecure_networking_configuration/#insecure-networking-configuration","text":"Severity: HIGH Detection method: SAST, NETWORK","title":"Insecure networking configuration"},{"location":"rg/en/android/insecure_networking_configuration/#description","text":"The application uses insecurely tuned networking configuration. With the release of Android 6.0 Marshmallow, Google introduced the manifest attribute: android: usesCleartextTraffic , to protect against accidental use of the HTTP protocol. Android 7.0 Nougat expanded this attribute by introducing an Android networking security configuration feature that allows developers to more clearly define connection settings. The network communication configuration is an XML file that configures the network security settings for the Android application. This setting is specified by a special attribute in AndroidManifest.xml \u2014 android:networkSecurityConfig . Connection example: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest ... > <application android:networkSecurityConfig=\"@xml/network_security_config\" ... > ... </application> </manifest>","title":"Description"},{"location":"rg/en/android/insecure_networking_configuration/#recommendations","text":"The Network Security Config feature allows you to configure network communication settings in a declarative configuration file without changing the application code. These settings can be configured for specific domains and for a specific application. The key opportunities provided by this approach: Custom trust anchors: Configure the certification authorities (CA) that the application will trust during network communication. For example, trusting certain self-signed certificates or restricting the set of public CAs that the application trusts (those added to the trusted ones by the user or those CAs that the system trusts). Debug-only overrides: Configuring connections specifically for the debug version of the application. This allows you to distinguish between development and production environments. Cleartext traffic: Settings to allow or deny connections via HTTP. Certificate pinning: Configuration for SSL Pinning implementation. In the configuration file, you can apply settings for the application in the base-config block, only for specific domains and subdomains in the domain-config block and separately for the debug build of the application in the debug-overrides block. Let's consider examples of settings that are available for customization: Custom trust anchors: Configuring trust to certification authorities Android\u2019s network security configuration gives developers several options for choosing which CAs to trust. By default in Android 7+ (Nougat, Oreo and Pie), the application will only trust certificates that are marked as system: <network-security-config> <base-config> <trust-anchors> <certificates src=\"system\"/> </trust-anchors> </base-config> </network-security-config> In Android 6 (Marshmallow) and lower, the application also trusts the certificates installed by the user. With this setting it is possible to perform a MiTM (man in the middle) attack if the user installs his certificate: <network-security-config> <base-config> <trust-anchors> <certificates src=\"system\"/> <certificates src=\"user\"/> </trust-anchors> </base-config> </network-security-config> It is also possible to enable trust in certificates located in the application's assets: <network-security-config> <base-config> <trust-anchors> <certificates src=\"@raw/my_custom_ca\"/> </trust-anchors> </base-config> </network-security-config> The most secure option is the first one, where the application trusts only the system certificates. Configuring HTTP communication By splitting into separate configurations for the entire application, individual domains, and the debug version, it is possible to control the permissions for using HTTP at each level. Let's take a closer look: in the first example, HTTP data transfer is forbidden at the application level (this is the most secure option): <network-security-config> <base-config cleartextTrafficPermitted=\"false\" /> ... </network-security-config> In some exceptional cases it is necessary to connect via HTTP to certain domains. Exactly for this case there is an opportunity to specify separately what is allowed for different domains: <network-security-config> <domain-config cleartextTrafficPermitted=\"true\"> <domain includeSubdomains=\"true\">insecure.example.com</domain> <domain includeSubdomains=\"true\">insecure.cdn.example2.com</domain> </domain-config> <base-config cleartextTrafficPermitted=\"false\" /> </network-security-config> This setting will only allow HTTPS access for all network connections except for the two that are allowed to communicate over HTTP ( insecure.example.com and insecure.cdn.example2.com ), including their subdomains. The includeSubdomains setting is responsible for enabling subdomains. Certificate Pinning settings Network Security Config allows you to easily connect the Certificate Pinning mechanism to the application. However, it is worth to take into account certain nuances. Let's look at a configuration that at first glance looks like a properly configured one and see how it can be slightly improved: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> </pin-set> </domain-config> </network-security-config> This example has two small disadvantages: The certificate fingerprint (pin-set) does not have an expiration date. There is no backup certificate. If your certificate is about to expire and no expiration date is specified in the settings, the application will stop connecting to the server and generate an error. However, if an expiration date has been set and it expires, the application will switch to the trusted certificate authorities installed in the system. Instead of getting a non-functional application, you will get no SSL Pinning for some time until you update the certificate in the application. To avoid this, if you know the certificate to be used on your server after the current one expires, you can specify it immediately in the \"backup certificates\" settings. Here is an example of the most correct use of the Certificate Pinning functionality: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set expiration=\"2021-01-01\"> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> <!-- backup pin --> <pin digest=\"SHA-256\">fwza0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM1oE=</pin> </pin-set> </domain-config> </network-security-config> Despite all the conveniences of using the Network Security Config, some checks should be performed internally in the application code. For example, you still need to determine if your application performs hostname validation, because Network Security Config does not protect against this type of issue. !!! note \"Note\" Also, before implementation, make sure that third-party libraries support Network Security Config. Otherwise, these security measures may cause problems in your application. Besides, Network Security Config is not supported by lower-level network connections, such as web sockets.","title":"Recommendations"},{"location":"rg/en/android/insecure_networking_configuration/#links","text":"https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic https://developer.android.com/training/articles/security-config https://www.nowsecure.com/blog/2018/08/15/a-security-analysts-guide-to-network-security-configuration-in-android-p/","title":"Links"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_hasfragileuserdata_flag/","text":"Insecure settings in AndroidManifest.xml. The android:hasFragileUserData flag Severity: LOW Detection method: SAST, APK Description The android:hasFragileUserData attribute determines whether to show the user a request to save the application data when the user deletes it. The default value is false . Works with android>=10 (sdk version: sdk: compileSdkVersion>=29 ). An application built without the explicitly defined android:hasFragileUserData flag in AndroidManifest.xml does not make it clear if it handles important user data or not. If the flag is set to true , but the application stores important data, there is a risk that it will be left on the device after deletion. To do this, the user must turn on the Keep app data toggle switch when uninstalling the application. As a result, the data in both the internal storage ( /data/data/<package_name> ) and the external storage (in general case /storage/sdcard0/Android/data/<package_name>/ ) will not be deleted. It is convenient to use the android:hasFragileUserData flag if you want to temporarily remove an application from the device and then install it back later and get the same state. However, a malefactor who installed a re-signed apk file with the same package name will have access to this data. Recommendations It is recommended to explicitly specify this value to clearly determine whether the application processes important user data or not. An example of secure code (the AndroidManifest.xml file) <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:hasFragileUserData=\"false\" > </application> </manifest> Links https://developer.android.com/guide/topics/manifest/application-element https://gist.github.com/agnostic-apollo/58def38fdb1c90563454974108ae52df https://www.xda-developers.com/android-10-manifest-flag-developers-retain-app-data-before-uninstalling/","title":"Insecure settings in AndroidManifest.xml. The android:hasFragileUserData flag"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_hasfragileuserdata_flag/#insecure-settings-in-androidmanifestxml-the-androidhasfragileuserdata-flag","text":"Severity: LOW Detection method: SAST, APK","title":"Insecure settings in AndroidManifest.xml. The android:hasFragileUserData flag"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_hasfragileuserdata_flag/#description","text":"The android:hasFragileUserData attribute determines whether to show the user a request to save the application data when the user deletes it. The default value is false . Works with android>=10 (sdk version: sdk: compileSdkVersion>=29 ). An application built without the explicitly defined android:hasFragileUserData flag in AndroidManifest.xml does not make it clear if it handles important user data or not. If the flag is set to true , but the application stores important data, there is a risk that it will be left on the device after deletion. To do this, the user must turn on the Keep app data toggle switch when uninstalling the application. As a result, the data in both the internal storage ( /data/data/<package_name> ) and the external storage (in general case /storage/sdcard0/Android/data/<package_name>/ ) will not be deleted. It is convenient to use the android:hasFragileUserData flag if you want to temporarily remove an application from the device and then install it back later and get the same state. However, a malefactor who installed a re-signed apk file with the same package name will have access to this data.","title":"Description"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_hasfragileuserdata_flag/#recommendations","text":"It is recommended to explicitly specify this value to clearly determine whether the application processes important user data or not. An example of secure code (the AndroidManifest.xml file) <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:hasFragileUserData=\"false\" > </application> </manifest>","title":"Recommendations"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_hasfragileuserdata_flag/#links","text":"https://developer.android.com/guide/topics/manifest/application-element https://gist.github.com/agnostic-apollo/58def38fdb1c90563454974108ae52df https://www.xda-developers.com/android-10-manifest-flag-developers-retain-app-data-before-uninstalling/","title":"Links"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_requestlegacyexternalstorage_flag/","text":"Insecure settings in AndroidManifest.xml. The android:requestLegacyExternalStorage flag Severity: LOW Detection method: SAST, APK Description The Android application built with the android:requestLegacyExternalStorage=true attribute in AndroidManifest.xml provides access to directories and various types of media files stored in external storage. This flag is used in the old file access model, which is not supported in new versions of Android. If the android:requestLegacyExternalStorage=true attribute is present in AndroidManifest and targetSDK >=30 , this attribute is ignored by the system because, starting from Android 11, only scoped storage is supported. If targetSDK = 29 , then the default attribute value is false (if not specified in the manifest). If targetSDK >= 28 , then the default attribute value is true (if not specified in the manifest). An example of vulnerable configuration (AndroidManifest.xml file): <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application android:icon=\"@drawable/ic_launcher\" android:requestLegacyExternalStorage=\"true\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest> Recommendations It is recommended not to set the android:requestLegacyExternalStorage attribute and only use scoped storage to guarantee better protection of applications and user data on external storage. Links https://developer.android.com/training/data-storage/use-cases https://commonsware.com/blog/2019/06/07/death-external-storage-end-saga.html https://medium.com/mindful-engineering/scoped-storage-in-android-d52460630d6a https://blog.mindorks.com/understanding-the-scoped-storage-in-android","title":"Insecure settings in AndroidManifest.xml. The android:requestLegacyExternalStorage flag"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_requestlegacyexternalstorage_flag/#insecure-settings-in-androidmanifestxml-the-androidrequestlegacyexternalstorage-flag","text":"Severity: LOW Detection method: SAST, APK","title":"Insecure settings in AndroidManifest.xml. The android:requestLegacyExternalStorage flag"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_requestlegacyexternalstorage_flag/#description","text":"The Android application built with the android:requestLegacyExternalStorage=true attribute in AndroidManifest.xml provides access to directories and various types of media files stored in external storage. This flag is used in the old file access model, which is not supported in new versions of Android. If the android:requestLegacyExternalStorage=true attribute is present in AndroidManifest and targetSDK >=30 , this attribute is ignored by the system because, starting from Android 11, only scoped storage is supported. If targetSDK = 29 , then the default attribute value is false (if not specified in the manifest). If targetSDK >= 28 , then the default attribute value is true (if not specified in the manifest). An example of vulnerable configuration (AndroidManifest.xml file): <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application android:icon=\"@drawable/ic_launcher\" android:requestLegacyExternalStorage=\"true\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest>","title":"Description"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_requestlegacyexternalstorage_flag/#recommendations","text":"It is recommended not to set the android:requestLegacyExternalStorage attribute and only use scoped storage to guarantee better protection of applications and user data on external storage.","title":"Recommendations"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml._the_android_requestlegacyexternalstorage_flag/#links","text":"https://developer.android.com/training/data-storage/use-cases https://commonsware.com/blog/2019/06/07/death-external-storage-end-saga.html https://medium.com/mindful-engineering/scoped-storage-in-android-d52460630d6a https://blog.mindorks.com/understanding-the-scoped-storage-in-android","title":"Links"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml/","text":"Insecure settings in AndroidManifest.xml Severity: HIGH Detection method: SAST, APK Description An Android application that has been built with an enabled debug mode (flag android:debuggable = True in AndroidManifest.xml ) can provide a malicious person with access to confidential information, with possibility to control the application's run and to execute code in the application's context. Example of vulnerable code (AndroidManifest.xml) <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest> Recommendations While building a release version of an application, ensure that the debug mode is disabled. You can disable the debug mode by deleting the android:debuggable attribute from an \\ tag in the manifest file, or by setting the android:debuggable value for the false attribute in the manifest. Example of secure code <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest> It is also possible to set up the debug mode for different builds using specific configurations in the build.gradle file: android { defaultConfig { ... ... } buildTypes { release { // *** \u041e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0434\u043b\u044f \u0440\u0435\u043b\u0438\u0437\u043d\u043e\u0439 \u0441\u0431\u043e\u0440\u043a\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f *** // debuggable false minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } debug { applicationIdSuffix \".debug\" // *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0434\u043b\u044f \u0446\u0435\u043b\u0435\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 *** // debuggable true } Links https://developer.android.com/studio/build/build-variants#build-types https://developer.android.com/studio/publish/preparing#publishing-configure https://resources.infosecinstitute.com/android-hacking-security-part-6-exploiting-debuggable-android-applications/ https://securitygrind.com/how-to-exploit-a-debuggable-android-application/ https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md","title":"Insecure settings in AndroidManifest.xml"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml/#insecure-settings-in-androidmanifestxml","text":"Severity: HIGH Detection method: SAST, APK","title":"Insecure settings in AndroidManifest.xml"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml/#description","text":"An Android application that has been built with an enabled debug mode (flag android:debuggable = True in AndroidManifest.xml ) can provide a malicious person with access to confidential information, with possibility to control the application's run and to execute code in the application's context. Example of vulnerable code (AndroidManifest.xml) <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest>","title":"Description"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml/#recommendations","text":"While building a release version of an application, ensure that the debug mode is disabled. You can disable the debug mode by deleting the android:debuggable attribute from an \\ tag in the manifest file, or by setting the android:debuggable value for the false attribute in the manifest. Example of secure code <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application <!-- *** \u0412\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 *** --> android:debuggable=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> </application> </manifest> It is also possible to set up the debug mode for different builds using specific configurations in the build.gradle file: android { defaultConfig { ... ... } buildTypes { release { // *** \u041e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0434\u043b\u044f \u0440\u0435\u043b\u0438\u0437\u043d\u043e\u0439 \u0441\u0431\u043e\u0440\u043a\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f *** // debuggable false minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } debug { applicationIdSuffix \".debug\" // *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043e\u0442\u043b\u0430\u0434\u043e\u0447\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0434\u043b\u044f \u0446\u0435\u043b\u0435\u0439 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 *** // debuggable true }","title":"Recommendations"},{"location":"rg/en/android/insecure_settings_in_androidmanifest.xml/#links","text":"https://developer.android.com/studio/build/build-variants#build-types https://developer.android.com/studio/publish/preparing#publishing-configure https://resources.infosecinstitute.com/android-hacking-security-part-6-exploiting-debuggable-android-applications/ https://securitygrind.com/how-to-exploit-a-debuggable-android-application/ https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md","title":"Links"},{"location":"rg/en/android/insecure_signature_algorithm/","text":"Insecure Signature Algorithm Severity: LOW Detection method: SAST, APK Description Algorithm used to sign an APK file is considered insecure. Signature algorithms ( MD2withRSA , MD5withRSA , SHA1withRSA , SHA1withDSA , SHA1withECDSA ) based on hash functions MD2 , MD5 , SHA1 and other outdated encryption algorithms contain known vulnerabilities and are prone to collisions. The main risk in using of a weak key is that a malicious person could break it to forge APK signatures. Thereafter, the malicious APK signed with your key could be installed as an update for your application. Depending on how a key is used in an application, there are other possible attacks involving a compromised key. Also, some application stores (for example, by Huawei ) don't recommend signing an application using such algorithms. Moreover, they don't allow uploading such applications. Recommendations To repair this vulnerability, you need to sign an application using up-to-date algorithms, such as SHA256withRSA or SHA512withRSA. Note, that earlier Android versions may not support algorithms beyond SHA1. This article highlights the above problem and provides guidance through the process of signature changing. Example: Generation of key using SHA512withRSA keytool -genkey -v -keystore test.keystore -alias testkey -keyalg RSA -keysize 4096 -sigalg SHA512withRSA -dname \"cn=Test,ou=Test,c=CA\" -validity 10000 Example: Signature with a generated key jarsigner -verbose -sigalg SHA512withRSA -digestalg SHA512 -keystore test.keystore test.apk testkey Links https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/ https://developer.android.com/studio/publish/app-signing https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md https://sites.google.com/site/itstheshappening/","title":"Insecure Signature Algorithm"},{"location":"rg/en/android/insecure_signature_algorithm/#insecure-signature-algorithm","text":"Severity: LOW Detection method: SAST, APK","title":"Insecure Signature Algorithm"},{"location":"rg/en/android/insecure_signature_algorithm/#description","text":"Algorithm used to sign an APK file is considered insecure. Signature algorithms ( MD2withRSA , MD5withRSA , SHA1withRSA , SHA1withDSA , SHA1withECDSA ) based on hash functions MD2 , MD5 , SHA1 and other outdated encryption algorithms contain known vulnerabilities and are prone to collisions. The main risk in using of a weak key is that a malicious person could break it to forge APK signatures. Thereafter, the malicious APK signed with your key could be installed as an update for your application. Depending on how a key is used in an application, there are other possible attacks involving a compromised key. Also, some application stores (for example, by Huawei ) don't recommend signing an application using such algorithms. Moreover, they don't allow uploading such applications.","title":"Description"},{"location":"rg/en/android/insecure_signature_algorithm/#recommendations","text":"To repair this vulnerability, you need to sign an application using up-to-date algorithms, such as SHA256withRSA or SHA512withRSA. Note, that earlier Android versions may not support algorithms beyond SHA1. This article highlights the above problem and provides guidance through the process of signature changing. Example: Generation of key using SHA512withRSA keytool -genkey -v -keystore test.keystore -alias testkey -keyalg RSA -keysize 4096 -sigalg SHA512withRSA -dname \"cn=Test,ou=Test,c=CA\" -validity 10000 Example: Signature with a generated key jarsigner -verbose -sigalg SHA512withRSA -digestalg SHA512 -keystore test.keystore test.apk testkey","title":"Recommendations"},{"location":"rg/en/android/insecure_signature_algorithm/#links","text":"https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/ https://developer.android.com/studio/publish/app-signing https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md https://sites.google.com/site/itstheshappening/","title":"Links"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_activity/","text":"Insecure transmission of sensitive information in Activity Severity: CRITICAL Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into an implicit Intent to launch an Activity . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations Don't include sensitive information into parameters when using implicit Intents (when a user defines what application will handle a message). Risks from using an Activity and corresponding countermeasures vary depending on the ways this Activity is used. We have classified 4 types of Activities based on how the Activity is used. To find out which type of Activity you are supposed to create, follow through the table and chart below. Creating and using a public Activity**** As an example we will follow the process of creation of a public Activity and its usage. Public Activity is an Activity that can be used by any external application. It is worth mentioning that: Public Activity can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a public Activity and/or read its data. Rules (creating a public Activity) Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicActivity.java package com.appsec.android.activity.publicactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u0435\u043c Intent'a \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = getIntent().getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 3 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u0432 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u0435\u043b\u0435\u043c Intent'a \u0431\u0443\u0434\u0435\u0442 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"Not Sensitive Info\"); setResult(RESULT_OK, intent); finish(); } } Rules (using a public Activity): Do not include sensitive information into the Intent used for launching an Activity . Verify the received resulting data and handle it in a secure manner. PublicUserActivity.java package com.appsec.android.activity.publicuser; import android.app.Activity; import android.content.ActivityNotFoundException; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicUserActivity extends Activity { private static final int REQUEST_CODE = 1; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } public void onUseActivityClick(View view) { try { // *** 1 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 Intent, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity Intent intent = new Intent(\"org.jssec.android.activity.MY_ACTION\"); intent.putExtra(\"PARAM\", \"Not Sensitive Info\"); startActivityForResult(intent, REQUEST_CODE); } catch (ActivityNotFoundException e) { Toast.makeText(this, \"Target activity not found.\", Toast.LENGTH_LONG).show(); } } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" if (resultCode != RESULT_OK) return; switch (requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); Toast.makeText(this, String.format(\"Received result: \\\"%s\\\"\", result), Toast.LENGTH_LONG).show(); break; } } } Also, be very careful when using an implicit Intent! !!! note \"Note!\" The following scenario is possible: there is no application on a user's device that can answer the implicit Intent sent by you to the startActivity() method. In this case the call will fail and the application will terminate abnormally. To check if the Intent will be received by an operation, call the resolveActivity() method for your Intent object. If the resulting value is not null, this means that there is at least one application able to answer the Intent object and you can call startActivity() . If the resulting value is null, the Intent object shouldn't be used; if possible, you should turn off the function that produces the Intent object. Links https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Insecure transmission of sensitive information in Activity"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_activity/#insecure-transmission-of-sensitive-information-in-activity","text":"Severity: CRITICAL Detection method: DAST, SENSITIVE INFO","title":"Insecure transmission of sensitive information in Activity"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_activity/#description","text":"An application puts sensitive information into an implicit Intent to launch an Activity . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_activity/#recommendations","text":"Don't include sensitive information into parameters when using implicit Intents (when a user defines what application will handle a message). Risks from using an Activity and corresponding countermeasures vary depending on the ways this Activity is used. We have classified 4 types of Activities based on how the Activity is used. To find out which type of Activity you are supposed to create, follow through the table and chart below. Creating and using a public Activity**** As an example we will follow the process of creation of a public Activity and its usage. Public Activity is an Activity that can be used by any external application. It is worth mentioning that: Public Activity can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a public Activity and/or read its data. Rules (creating a public Activity) Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicActivity.java package com.appsec.android.activity.publicactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u0435\u043c Intent'a \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = getIntent().getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 3 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u0432 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u0435\u043b\u0435\u043c Intent'a \u0431\u0443\u0434\u0435\u0442 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"Not Sensitive Info\"); setResult(RESULT_OK, intent); finish(); } } Rules (using a public Activity): Do not include sensitive information into the Intent used for launching an Activity . Verify the received resulting data and handle it in a secure manner. PublicUserActivity.java package com.appsec.android.activity.publicuser; import android.app.Activity; import android.content.ActivityNotFoundException; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicUserActivity extends Activity { private static final int REQUEST_CODE = 1; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } public void onUseActivityClick(View view) { try { // *** 1 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 Intent, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity Intent intent = new Intent(\"org.jssec.android.activity.MY_ACTION\"); intent.putExtra(\"PARAM\", \"Not Sensitive Info\"); startActivityForResult(intent, REQUEST_CODE); } catch (ActivityNotFoundException e) { Toast.makeText(this, \"Target activity not found.\", Toast.LENGTH_LONG).show(); } } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" if (resultCode != RESULT_OK) return; switch (requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); Toast.makeText(this, String.format(\"Received result: \\\"%s\\\"\", result), Toast.LENGTH_LONG).show(); break; } } } Also, be very careful when using an implicit Intent! !!! note \"Note!\" The following scenario is possible: there is no application on a user's device that can answer the implicit Intent sent by you to the startActivity() method. In this case the call will fail and the application will terminate abnormally. To check if the Intent will be received by an operation, call the resolveActivity() method for your Intent object. If the resulting value is not null, this means that there is at least one application able to answer the Intent object and you can call startActivity() . If the resulting value is null, the Intent object shouldn't be used; if possible, you should turn off the function that produces the Intent object.","title":"Recommendations"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_activity/#links","text":"https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Links"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_activity/","text":"Insecure transmission of sensitive information in external Activity Severity: HIGH Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into an Intent to launch an external Activity . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations When calling external (not related to the application under development) Activity, do not include sensitive information in the parameters. This can compromise such information. Risks from using an Activity and corresponding countermeasures vary depending on the ways this Activity is used. We have classified 4 types of Activities based on how the Activity is used. To find out which type of Activity you are supposed to create, follow through the table and chart below. Creating and using a public Activity As an example we will follow the process of creation of a public Activity and its usage. Public Activity is an Activity that can be used by any external application. It is worth mentioning that: Public Activity can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a public Activity and/or read its data. Rules (creating a public Activity) Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicActivity.java package com.appsec.android.activity.publicactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u0435\u043c Intent'a \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = getIntent().getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 3 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u0432 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u0435\u043b\u0435\u043c Intent'a \u0431\u0443\u0434\u0435\u0442 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"Not Sensitive Info\"); setResult(RESULT_OK, intent); finish(); } } Rules (using a public Activity): Do not include sensitive information into the Intent used for launching an Activity . Verify the received resulting data and handle it in a secure manner. PublicUserActivity.java package com.appsec.android.activity.publicuser; import android.app.Activity; import android.content.ActivityNotFoundException; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicUserActivity extends Activity { private static final int REQUEST_CODE = 1; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } public void onUseActivityClick(View view) { try { // *** 1 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 Intent, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity Intent intent = new Intent(\"org.jssec.android.activity.MY_ACTION\"); intent.putExtra(\"PARAM\", \"Not Sensitive Info\"); startActivityForResult(intent, REQUEST_CODE); } catch (ActivityNotFoundException e) { Toast.makeText(this, \"Target activity not found.\", Toast.LENGTH_LONG).show(); } } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" if (resultCode != RESULT_OK) return; switch (requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); Toast.makeText(this, String.format(\"Received result: \\\"%s\\\"\", result), Toast.LENGTH_LONG).show(); break; } } } Links https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Insecure transmission of sensitive information in external Activity"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_activity/#insecure-transmission-of-sensitive-information-in-external-activity","text":"Severity: HIGH Detection method: DAST, SENSITIVE INFO","title":"Insecure transmission of sensitive information in external Activity"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_activity/#description","text":"An application puts sensitive information into an Intent to launch an external Activity . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_activity/#recommendations","text":"When calling external (not related to the application under development) Activity, do not include sensitive information in the parameters. This can compromise such information. Risks from using an Activity and corresponding countermeasures vary depending on the ways this Activity is used. We have classified 4 types of Activities based on how the Activity is used. To find out which type of Activity you are supposed to create, follow through the table and chart below. Creating and using a public Activity As an example we will follow the process of creation of a public Activity and its usage. Public Activity is an Activity that can be used by any external application. It is worth mentioning that: Public Activity can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a public Activity and/or read its data. Rules (creating a public Activity) Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicActivity.java package com.appsec.android.activity.publicactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u0435\u043c Intent'a \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = getIntent().getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 3 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u0432 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e // \u0422.\u043a. \u044d\u0442\u043e Public Activity, \u0442\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0447\u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u0435\u043b\u0435\u043c Intent'a \u0431\u0443\u0434\u0435\u0442 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"Not Sensitive Info\"); setResult(RESULT_OK, intent); finish(); } } Rules (using a public Activity): Do not include sensitive information into the Intent used for launching an Activity . Verify the received resulting data and handle it in a secure manner. PublicUserActivity.java package com.appsec.android.activity.publicuser; import android.app.Activity; import android.content.ActivityNotFoundException; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PublicUserActivity extends Activity { private static final int REQUEST_CODE = 1; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } public void onUseActivityClick(View view) { try { // *** 1 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 Intent, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity Intent intent = new Intent(\"org.jssec.android.activity.MY_ACTION\"); intent.putExtra(\"PARAM\", \"Not Sensitive Info\"); startActivityForResult(intent, REQUEST_CODE); } catch (ActivityNotFoundException e) { Toast.makeText(this, \"Target activity not found.\", Toast.LENGTH_LONG).show(); } } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" if (resultCode != RESULT_OK) return; switch (requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); Toast.makeText(this, String.format(\"Received result: \\\"%s\\\"\", result), Toast.LENGTH_LONG).show(); break; } } }","title":"Recommendations"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_activity/#links","text":"https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Links"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_service/","text":"Insecure transmission of sensitive information in external Service Severity: HIGH Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into Intent to launch an external Service . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations When calling external public Service , do not include sensitive information in Intent . Risks from using a Service and corresponding countermeasures vary depending on the ways this Service is used. To find out what type of a Service you are supposed to create, follow the table and chart below. There are various implementations of a Service . Possible combinations of an implementation method and a service type are shown in the table below. OK stands for possible combination. A circle means impossible combination. The example below shows how to properly create and use an external service. It is important to remember that sensitive information must not be sent when using external public Service . !!! note \"Note!\" To ensure security of your application, always use an explicit Intent object for starting a Service , and don't declare Intent filters for your services. Starting a service using an implicit Intent bears security risks, because there is no certainty in what service will react to the Intent , and a user doesn't see what service launches. Starting from Android 5.0 (API level 21) the system throws an exception by calling the bindService() method using an implicit Intent object. Creating and using a public Service Public Service is a Service that can be used by any external application. It is worth mentioning that: Public Service can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a Public Service and/or read its data. Rules (creating a Public Service): Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicClientService.java package com.appsec.android.service.publicservice; import android.app.IntentService; import android.content.Intent; import android.widget.Toast; public class PublicIntentService extends IntentService{ /** * \u041a\u043e\u0433\u0434\u0430 \u043d\u0430\u0441\u043b\u0435\u0434\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 IntentService, \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u0438\u043d\u0430\u0447\u0435 \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0430 */ public PublicIntentService() { super(\"CreatingService\"); } @Override public void onCreate() { super.onCreate(); Toast.makeText(this, this.getClass().getSimpleName() + \" - onCreate()\", Toast.LENGTH_SHORT).show(); } @Override protected void onHandleIntent(Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Recieved parameter \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } @Override public void onDestroy() { Toast.makeText(this, this.getClass().getSimpleName() + \" - onDestroy()\", Toast.LENGTH_SHORT).show(); } } Rules (using a public Service): !!! note \"Note!\" To avoid an accidental launch of another application's Service always use explicit Intent objects for starting your own services and don't declare Intent filters for them. Use an explicit Intent . Do not include sensitive information into the data to be sent. package com.appsec.android.service.publicserviceuser; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; public class PublicUserActivity extends Activity { // \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0446\u0435\u043b\u0435\u0432\u043e\u043c \u0441\u0435\u0440\u0432\u0438\u0441\u0435 private static final String TARGET_PACKAGE = \"com.appsec.android.service.publicservice\"; private static final String TARGET_START_CLASS = \"com.appsec.android.service.publicservice.PublicStartService\"; private static final String TARGET_INTENT_CLASS = \"com.appsec.android.service.publicservice.PublicIntentService\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.publicservice_activity); } public void onStopServiceClick(View v) { doStopService(); } // \u0417\u0430\u043f\u0443\u0441\u043a IntentService public void onIntentServiceClick(View v) { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.intentservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_INTENT_CLASS); // *** 2 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 intent.putExtra(\"PARAM\", \"Not sensitive information\"); startService(intent); } @Override public void onStop(){ super.onStop(); doStopService(); } private void doStopService() { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.startservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_START_CLASS); stopService(intent); } } Links https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Insecure transmission of sensitive information in external Service"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_service/#insecure-transmission-of-sensitive-information-in-external-service","text":"Severity: HIGH Detection method: DAST, SENSITIVE INFO","title":"Insecure transmission of sensitive information in external Service"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_service/#description","text":"An application puts sensitive information into Intent to launch an external Service . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_service/#recommendations","text":"When calling external public Service , do not include sensitive information in Intent . Risks from using a Service and corresponding countermeasures vary depending on the ways this Service is used. To find out what type of a Service you are supposed to create, follow the table and chart below. There are various implementations of a Service . Possible combinations of an implementation method and a service type are shown in the table below. OK stands for possible combination. A circle means impossible combination. The example below shows how to properly create and use an external service. It is important to remember that sensitive information must not be sent when using external public Service . !!! note \"Note!\" To ensure security of your application, always use an explicit Intent object for starting a Service , and don't declare Intent filters for your services. Starting a service using an implicit Intent bears security risks, because there is no certainty in what service will react to the Intent , and a user doesn't see what service launches. Starting from Android 5.0 (API level 21) the system throws an exception by calling the bindService() method using an implicit Intent object. Creating and using a public Service Public Service is a Service that can be used by any external application. It is worth mentioning that: Public Service can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a Public Service and/or read its data. Rules (creating a Public Service): Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicClientService.java package com.appsec.android.service.publicservice; import android.app.IntentService; import android.content.Intent; import android.widget.Toast; public class PublicIntentService extends IntentService{ /** * \u041a\u043e\u0433\u0434\u0430 \u043d\u0430\u0441\u043b\u0435\u0434\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 IntentService, \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u0438\u043d\u0430\u0447\u0435 \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0430 */ public PublicIntentService() { super(\"CreatingService\"); } @Override public void onCreate() { super.onCreate(); Toast.makeText(this, this.getClass().getSimpleName() + \" - onCreate()\", Toast.LENGTH_SHORT).show(); } @Override protected void onHandleIntent(Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Recieved parameter \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } @Override public void onDestroy() { Toast.makeText(this, this.getClass().getSimpleName() + \" - onDestroy()\", Toast.LENGTH_SHORT).show(); } } Rules (using a public Service): !!! note \"Note!\" To avoid an accidental launch of another application's Service always use explicit Intent objects for starting your own services and don't declare Intent filters for them. Use an explicit Intent . Do not include sensitive information into the data to be sent. package com.appsec.android.service.publicserviceuser; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; public class PublicUserActivity extends Activity { // \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0446\u0435\u043b\u0435\u0432\u043e\u043c \u0441\u0435\u0440\u0432\u0438\u0441\u0435 private static final String TARGET_PACKAGE = \"com.appsec.android.service.publicservice\"; private static final String TARGET_START_CLASS = \"com.appsec.android.service.publicservice.PublicStartService\"; private static final String TARGET_INTENT_CLASS = \"com.appsec.android.service.publicservice.PublicIntentService\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.publicservice_activity); } public void onStopServiceClick(View v) { doStopService(); } // \u0417\u0430\u043f\u0443\u0441\u043a IntentService public void onIntentServiceClick(View v) { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.intentservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_INTENT_CLASS); // *** 2 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 intent.putExtra(\"PARAM\", \"Not sensitive information\"); startService(intent); } @Override public void onStop(){ super.onStop(); doStopService(); } private void doStopService() { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.startservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_START_CLASS); stopService(intent); } }","title":"Recommendations"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_external_service/#links","text":"https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Links"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_internal_service/","text":"Insecure transmission of sensitive information in internal Service Severity: INFO Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into Intent to launch an internal Service . Generally this is not a vulnerability, but with root access such information can be intercepted. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations When calling external public Service , do not include sensitive information in Intent . Risks from using a Service and corresponding countermeasures vary depending on the ways this Service is used. To find out what type of a Service you are supposed to create, follow the table and chart below. There are various implementations of a Service . Possible combinations of an implementation method and a service type are shown in the table below. OK stands for possible combination. A circle means impossible combination. The example below shows how to properly create and use an internal service. It is important to remember that sensitive information must not be sent when using external public Service . !!! note \"Note!\" To ensure security of your application, always use an explicit Intent object for starting a Service , and don't declare Intent filters for your services. Starting a service using an implicit Intent bears security risks, because there is no certainty in what service will react to the Intent , and a user doesn't see what service launches. Starting from Android 5.0 (API level 21) the system throws an exception by calling the bindService() method using an implicit Intent object. Creating and using a private Service Private Service cannot be launched by other applications and, therefore, is the most secure. When using Private Services that are only used within the application, as long as you use explicit Intents to the class then you do not have to worry about sending it to any other application. Rules (creating a Private Service): Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can include sensitive information in the result Intent because it is sent and received within the application. AndroidManifest.xml <!--?xml version=\"1.0\" encoding=\"utf-8\"?--> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.service.privateservice\"></manifest> <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:allowbackup=\"false\"> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <intent-filter> <action android:name=\"android.intent.action.MAIN\"></action> <category android:name=\"android.intent.category.LAUNCHER\"></category> </intent-filter> </activity></application> <!-- Private Service \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043e\u0442 \u043a\u043b\u0430\u0441\u0441\u0430 Service --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <service android:name=\".PrivateStartService\" android:exported=\"false\"></service> PrivateStartService.java package com.appsec.android.service.privateservice; import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.widget.Toast; public class PrivateStartService extends Service { @Override public void onCreate() { Toast.makeText(this, \"PrivateStartService - onCreate()\", Toast.LENGTH_SHORT).show(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"PrivateStartService\\n\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b: \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); return Service.START_NOT_STICKY; } @Override public void onDestroy() { Toast.makeText(this, \"PrivateStartService - onDestroy()\", Toast.LENGTH_SHORT).show(); } @Override public IBinder onBind(Intent intent) { return null; } } Rules (using a private Service): !!! note \"Note!\" To avoid an accidental launch of another application's Service always use explicit Intent objects for starting your own services and don't declare Intent filters for them. Use the explicit Intent with class specified to call a Service within the application. Sensitive information can be included in the data being sent because it is sent and received within the application. Handle the received result data carefully and securely, even though the data came from a Service in the same application. PrivateUserActivity.java package com.appsec.android.service.privateservice; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; public class PrivateUserActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.privateservice_activity); } // StartService public void onStartServiceClick(View v) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 Service \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateStartService.class); // *** 2 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0438\u0445 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u0444\u043d\u043e\u0440\u043c\u0430\u0446\u0438\u044f\"); startService(intent); } public void onStopServiceClick(View v) { doStopService(); } @Override public void onStop() { super.onStop(); doStopService(); } private void doStopService() { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 Service \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateStartService.class); stopService(intent); } } Links https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Insecure transmission of sensitive information in internal Service"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_internal_service/#insecure-transmission-of-sensitive-information-in-internal-service","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Insecure transmission of sensitive information in internal Service"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_internal_service/#description","text":"An application puts sensitive information into Intent to launch an internal Service . Generally this is not a vulnerability, but with root access such information can be intercepted. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_internal_service/#recommendations","text":"When calling external public Service , do not include sensitive information in Intent . Risks from using a Service and corresponding countermeasures vary depending on the ways this Service is used. To find out what type of a Service you are supposed to create, follow the table and chart below. There are various implementations of a Service . Possible combinations of an implementation method and a service type are shown in the table below. OK stands for possible combination. A circle means impossible combination. The example below shows how to properly create and use an internal service. It is important to remember that sensitive information must not be sent when using external public Service . !!! note \"Note!\" To ensure security of your application, always use an explicit Intent object for starting a Service , and don't declare Intent filters for your services. Starting a service using an implicit Intent bears security risks, because there is no certainty in what service will react to the Intent , and a user doesn't see what service launches. Starting from Android 5.0 (API level 21) the system throws an exception by calling the bindService() method using an implicit Intent object. Creating and using a private Service Private Service cannot be launched by other applications and, therefore, is the most secure. When using Private Services that are only used within the application, as long as you use explicit Intents to the class then you do not have to worry about sending it to any other application. Rules (creating a Private Service): Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can include sensitive information in the result Intent because it is sent and received within the application. AndroidManifest.xml <!--?xml version=\"1.0\" encoding=\"utf-8\"?--> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.service.privateservice\"></manifest> <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:allowbackup=\"false\"> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <intent-filter> <action android:name=\"android.intent.action.MAIN\"></action> <category android:name=\"android.intent.category.LAUNCHER\"></category> </intent-filter> </activity></application> <!-- Private Service \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043e\u0442 \u043a\u043b\u0430\u0441\u0441\u0430 Service --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <service android:name=\".PrivateStartService\" android:exported=\"false\"></service> PrivateStartService.java package com.appsec.android.service.privateservice; import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.widget.Toast; public class PrivateStartService extends Service { @Override public void onCreate() { Toast.makeText(this, \"PrivateStartService - onCreate()\", Toast.LENGTH_SHORT).show(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"PrivateStartService\\n\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b: \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); return Service.START_NOT_STICKY; } @Override public void onDestroy() { Toast.makeText(this, \"PrivateStartService - onDestroy()\", Toast.LENGTH_SHORT).show(); } @Override public IBinder onBind(Intent intent) { return null; } } Rules (using a private Service): !!! note \"Note!\" To avoid an accidental launch of another application's Service always use explicit Intent objects for starting your own services and don't declare Intent filters for them. Use the explicit Intent with class specified to call a Service within the application. Sensitive information can be included in the data being sent because it is sent and received within the application. Handle the received result data carefully and securely, even though the data came from a Service in the same application. PrivateUserActivity.java package com.appsec.android.service.privateservice; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; public class PrivateUserActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.privateservice_activity); } // StartService public void onStartServiceClick(View v) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 Service \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateStartService.class); // *** 2 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0438\u0445 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u0444\u043d\u043e\u0440\u043c\u0430\u0446\u0438\u044f\"); startService(intent); } public void onStopServiceClick(View v) { doStopService(); } @Override public void onStop() { super.onStop(); doStopService(); } private void doStopService() { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 Service \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateStartService.class); stopService(intent); } }","title":"Recommendations"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_internal_service/#links","text":"https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Links"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_private_activity/","text":"Insecure transmission of sensitive information in private Activity Severity: INFO Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into an Intent to launch a private Activity . Generally, this is not a vulnerability, but with root access on the device, this method of data transfer may be considered insecure. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations Don't include sensitive information into parameters when using implicit Intents (when a user defines what application will handle a message). Risks from using an Activity and corresponding countermeasures vary depending on the ways this Activity is used. We have classified 4 types of Activities based on how the Activity is used. To find out which type of Activity you are supposed to create, follow through the table and chart below. Creating and using a private Activity Private Activity cannot be launched by other applications and, therefore, is the most secure. An explicit Intent (with the class name) is used to run a Private Activity , so there is no need to worry about the possibility of accidentally sending data to a third-party application. However, there is a risk that a third-party application can read an Intent that is used to start the Activity . Therefore it is necessary to make sure that if you are putting sensitive information inside an Intent used to start an Activity that you take countermeasures to make sure that it cannot be read by a malicious third-party application. Rules (creating a private Activity) Do not use taskAffinity . Do not use launchMode . Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can include sensitive information in the result Intent because it is sent and received within the application. AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Private activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> <!-- Public activity \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c\u0430\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e --> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> PrivateActivity.java package com.appsec.android.activity.privateactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PrivateActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.private_activity); // *** 4 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u0434\u0430\u0436\u0435 \u0435\u0441\u043b\u0438 \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = getIntent().getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Received param: %s\", param), Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 5 *** \u0412 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"Sensitive Info\"); setResult(RESULT_OK, intent); finish(); } } Rules (using a private Activity): Do not set the FLAG_ACTIVITY_NEW_TASK flag in the Intent that will be used to start an Activity . Use explicit Intent with the name of the Activity class inside the application. You can include sensitive information in the Intent used to start an Activity (but only using the putExtra method), since it is sent and received inside the application. Verify the received result data and handle it in a secure manner despite the fact that it was sent from Activity of the same application. PrivateUserActivity.java package com.appsec.android.activity.privateactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PrivateUserActivity extends Activity { private static final int REQUEST_CODE = 1; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.user_activity); } public void onUseActivityClick(View view) { // *** 1 *** \u041d\u0435 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0439\u0442\u0435 \u0444\u043b\u0430\u0433 FLAG_ACTIVITY_NEW_TASK \u0432 **Intent**, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 Activity \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateActivity.class); // *** 3 *** \u0412 Intent, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity, // \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043d\u043e \u0442\u043e\u043b\u044c\u043a\u043e \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0435\u0442\u043e\u0434\u0430 `putExtra`), // \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f intent.putExtra(\"PARAM\", \"Sensitive Info\"); startActivityForResult(intent, REQUEST_CODE); } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if(resultCode != RESULT_OK) return; switch(requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); // *** POINT 4 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, // \u0434\u0430\u0436\u0435 \u0435\u0441\u043b\u0438 \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 Activity \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" Toast.makeText(this, String.format(\"Received result: %s, result), Toast.LENGTH_LONG).show(); break; } } } Links https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Insecure transmission of sensitive information in private Activity"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_private_activity/#insecure-transmission-of-sensitive-information-in-private-activity","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Insecure transmission of sensitive information in private Activity"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_private_activity/#description","text":"An application puts sensitive information into an Intent to launch a private Activity . Generally, this is not a vulnerability, but with root access on the device, this method of data transfer may be considered insecure. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_private_activity/#recommendations","text":"Don't include sensitive information into parameters when using implicit Intents (when a user defines what application will handle a message). Risks from using an Activity and corresponding countermeasures vary depending on the ways this Activity is used. We have classified 4 types of Activities based on how the Activity is used. To find out which type of Activity you are supposed to create, follow through the table and chart below. Creating and using a private Activity Private Activity cannot be launched by other applications and, therefore, is the most secure. An explicit Intent (with the class name) is used to run a Private Activity , so there is no need to worry about the possibility of accidentally sending data to a third-party application. However, there is a risk that a third-party application can read an Intent that is used to start the Activity . Therefore it is necessary to make sure that if you are putting sensitive information inside an Intent used to start an Activity that you take countermeasures to make sure that it cannot be read by a malicious third-party application. Rules (creating a private Activity) Do not use taskAffinity . Do not use launchMode . Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can include sensitive information in the result Intent because it is sent and received within the application. AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.privateactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Private activity --> <!-- *** 1 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 taskAffinity --> <!-- *** 2 *** \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 launchMode --> <!-- *** 3 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <activity android:name=\".PrivateActivity\" android:label=\"@string/app_name\" android:exported=\"false\" /> <!-- Public activity \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c\u0430\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e --> <activity android:name=\".PrivateUserActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> PrivateActivity.java package com.appsec.android.activity.privateactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PrivateActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.private_activity); // *** 4 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u0434\u0430\u0436\u0435 \u0435\u0441\u043b\u0438 \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = getIntent().getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Received param: %s\", param), Toast.LENGTH_LONG).show(); } public void onReturnResultClick(View view) { // *** 5 *** \u0412 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. Intent intent = new Intent(); intent.putExtra(\"RESULT\", \"Sensitive Info\"); setResult(RESULT_OK, intent); finish(); } } Rules (using a private Activity): Do not set the FLAG_ACTIVITY_NEW_TASK flag in the Intent that will be used to start an Activity . Use explicit Intent with the name of the Activity class inside the application. You can include sensitive information in the Intent used to start an Activity (but only using the putExtra method), since it is sent and received inside the application. Verify the received result data and handle it in a secure manner despite the fact that it was sent from Activity of the same application. PrivateUserActivity.java package com.appsec.android.activity.privateactivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Toast; public class PrivateUserActivity extends Activity { private static final int REQUEST_CODE = 1; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.user_activity); } public void onUseActivityClick(View view) { // *** 1 *** \u041d\u0435 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0439\u0442\u0435 \u0444\u043b\u0430\u0433 FLAG_ACTIVITY_NEW_TASK \u0432 **Intent**, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 Activity \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateActivity.class); // *** 3 *** \u0412 Intent, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 Activity, // \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043d\u043e \u0442\u043e\u043b\u044c\u043a\u043e \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0435\u0442\u043e\u0434\u0430 `putExtra`), // \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f intent.putExtra(\"PARAM\", \"Sensitive Info\"); startActivityForResult(intent, REQUEST_CODE); } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if(resultCode != RESULT_OK) return; switch(requestCode) { case REQUEST_CODE: String result = data.getStringExtra(\"RESULT\"); // *** POINT 4 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, // \u0434\u0430\u0436\u0435 \u0435\u0441\u043b\u0438 \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 Activity \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" Toast.makeText(this, String.format(\"Received result: %s, result), Toast.LENGTH_LONG).show(); break; } } }","title":"Recommendations"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_private_activity/#links","text":"https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Links"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_service/","text":"Insecure transmission of sensitive information in Service Severity: CRITICAL Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into an implicit Intent to launch a Service . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations Don't include sensitive information into parameters when using implicit Intent. Risks from using a Service and corresponding countermeasures vary depending on the ways this Service is used. To find out what type of a Service you are supposed to create, follow the table and chart below. There are various implementations of a Service . Possible combinations of an implementation method and a service type are shown in the table below. OK stands for possible combination. A circle means impossible combination. The example below shows how to properly create and use an external service. It is important to remember that sensitive information must not be sent when using external public Service . !!! note \"Note!\" To ensure security of your application, always use an explicit Intent object for starting a Service , and don't declare Intent filters for your services. Starting a service using an implicit Intent bears security risks, because there is no certainty in what service will react to the Intent , and a user doesn't see what service launches. Starting from Android 5.0 (API level 21) the system throws an exception by calling the bindService() method using an implicit Intent object. Creating and using a public Service Public Service is a Service that can be used by any external application. It is worth mentioning that: Public Service can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a Public Service and/or read its data. Rules (creating a Public Service): Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicClientService.java package com.appsec.android.service.publicservice; import android.app.IntentService; import android.content.Intent; import android.widget.Toast; public class PublicIntentService extends IntentService{ /** * \u041a\u043e\u0433\u0434\u0430 \u043d\u0430\u0441\u043b\u0435\u0434\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 IntentService, \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u0438\u043d\u0430\u0447\u0435 \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0430 */ public PublicIntentService() { super(\"CreatingService\"); } @Override public void onCreate() { super.onCreate(); Toast.makeText(this, this.getClass().getSimpleName() + \" - onCreate()\", Toast.LENGTH_SHORT).show(); } @Override protected void onHandleIntent(Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Recieved parameter \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } @Override public void onDestroy() { Toast.makeText(this, this.getClass().getSimpleName() + \" - onDestroy()\", Toast.LENGTH_SHORT).show(); } } Rules (using a public Service): !!! note \"Note!\" To avoid an accidental launch of another application's Service always use explicit Intent objects for starting your own services and don't declare Intent filters for them. Use an explicit Intent . Do not include sensitive information into the data to be sent. package com.appsec.android.service.publicserviceuser; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; public class PublicUserActivity extends Activity { // \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0446\u0435\u043b\u0435\u0432\u043e\u043c \u0441\u0435\u0440\u0432\u0438\u0441\u0435 private static final String TARGET_PACKAGE = \"com.appsec.android.service.publicservice\"; private static final String TARGET_START_CLASS = \"com.appsec.android.service.publicservice.PublicStartService\"; private static final String TARGET_INTENT_CLASS = \"com.appsec.android.service.publicservice.PublicIntentService\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.publicservice_activity); } public void onStopServiceClick(View v) { doStopService(); } // \u0417\u0430\u043f\u0443\u0441\u043a IntentService public void onIntentServiceClick(View v) { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.intentservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_INTENT_CLASS); // *** 2 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 intent.putExtra(\"PARAM\", \"Not sensitive information\"); startService(intent); } @Override public void onStop(){ super.onStop(); doStopService(); } private void doStopService() { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.startservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_START_CLASS); stopService(intent); } } Links https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Insecure transmission of sensitive information in Service"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_service/#insecure-transmission-of-sensitive-information-in-service","text":"Severity: CRITICAL Detection method: DAST, SENSITIVE INFO","title":"Insecure transmission of sensitive information in Service"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_service/#description","text":"An application puts sensitive information into an implicit Intent to launch a Service . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used, i.e. an Intent that does not specify a component; instead, it generally defines an action to be conducted, and lets the system determine which of the available components is best to run for that Intent. For example, if there is a need to display a place on a map, the implicit Intent object can request another application, which has such feature, to provide this information. Data in such messages could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_service/#recommendations","text":"Don't include sensitive information into parameters when using implicit Intent. Risks from using a Service and corresponding countermeasures vary depending on the ways this Service is used. To find out what type of a Service you are supposed to create, follow the table and chart below. There are various implementations of a Service . Possible combinations of an implementation method and a service type are shown in the table below. OK stands for possible combination. A circle means impossible combination. The example below shows how to properly create and use an external service. It is important to remember that sensitive information must not be sent when using external public Service . !!! note \"Note!\" To ensure security of your application, always use an explicit Intent object for starting a Service , and don't declare Intent filters for your services. Starting a service using an implicit Intent bears security risks, because there is no certainty in what service will react to the Intent , and a user doesn't see what service launches. Starting from Android 5.0 (API level 21) the system throws an exception by calling the bindService() method using an implicit Intent object. Creating and using a public Service Public Service is a Service that can be used by any external application. It is worth mentioning that: Public Service can receive an Intent from a malicious application. A malicious application can receive an Intent sent to a Public Service and/or read its data. Rules (creating a Public Service): Explicitly set the \"exported\" attribute to \"true\": exported=\"true\" . Verify the received Intent and handle it in a secure manner. Do not include sensitive information into the resulting Intent . AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.activity.publicactivity\" > <application android:allowBackup=\"false\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" > <!-- Public Activity --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"true\" --> <activity android:name=\".PublicActivity\" android:label=\"@string/app_name\" android:exported=\"true\"> <!-- \u041e\u0431\u044c\u044f\u0432\u043b\u0435\u043d\u0438\u0435 intent \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u044f\u0432\u043d\u044b\u0445 Intent'\u043e\u0432 \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u043c Action --> <intent-filter> <action android:name=\"com.appsec.android.activity.MY_ACTION\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> </activity> </application> </manifest> PublicClientService.java package com.appsec.android.service.publicservice; import android.app.IntentService; import android.content.Intent; import android.widget.Toast; public class PublicIntentService extends IntentService{ /** * \u041a\u043e\u0433\u0434\u0430 \u043d\u0430\u0441\u043b\u0435\u0434\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 IntentService, \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u0438\u043d\u0430\u0447\u0435 \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0430 */ public PublicIntentService() { super(\"CreatingService\"); } @Override public void onCreate() { super.onCreate(); Toast.makeText(this, this.getClass().getSimpleName() + \" - onCreate()\", Toast.LENGTH_SHORT).show(); } @Override protected void onHandleIntent(Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(this, String.format(\"Recieved parameter \\\"%s\\\"\", param), Toast.LENGTH_LONG).show(); } @Override public void onDestroy() { Toast.makeText(this, this.getClass().getSimpleName() + \" - onDestroy()\", Toast.LENGTH_SHORT).show(); } } Rules (using a public Service): !!! note \"Note!\" To avoid an accidental launch of another application's Service always use explicit Intent objects for starting your own services and don't declare Intent filters for them. Use an explicit Intent . Do not include sensitive information into the data to be sent. package com.appsec.android.service.publicserviceuser; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; public class PublicUserActivity extends Activity { // \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0446\u0435\u043b\u0435\u0432\u043e\u043c \u0441\u0435\u0440\u0432\u0438\u0441\u0435 private static final String TARGET_PACKAGE = \"com.appsec.android.service.publicservice\"; private static final String TARGET_START_CLASS = \"com.appsec.android.service.publicservice.PublicStartService\"; private static final String TARGET_INTENT_CLASS = \"com.appsec.android.service.publicservice.PublicIntentService\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.publicservice_activity); } public void onStopServiceClick(View v) { doStopService(); } // \u0417\u0430\u043f\u0443\u0441\u043a IntentService public void onIntentServiceClick(View v) { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.intentservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_INTENT_CLASS); // *** 2 *** \u041d\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0432 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 intent.putExtra(\"PARAM\", \"Not sensitive information\"); startService(intent); } @Override public void onStop(){ super.onStop(); doStopService(); } private void doStopService() { Intent intent = new Intent(\"com.appsec.android.service.publicservice.action.startservice\"); // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent intent.setClassName(TARGET_PACKAGE, TARGET_START_CLASS); stopService(intent); } }","title":"Recommendations"},{"location":"rg/en/android/insecure_transmission_of_sensitive_information_in_service/#links","text":"https://developer.android.com/guide/components/intents-filters?hl=ru https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md https://developer.android.com/training/basics/intents/index.html","title":"Links"},{"location":"rg/en/android/insufficient_length_of_a_signature_key/","text":"Insufficient length of a signature key Severity: LOW Detection method: SAST, APK Description The length of the key used for signing an APK file is insufficient. Official NIST recommendations (PDF, pages 64 and 67) qualify 1024-bit RSA keys as insecure (starting from 2013). This doesn't mean that 1024-bit RSA has been compromised, this is more of a preventive measure in order to be a step ahead of attackers. The main risk in using of a weak key is that a malicious person could break it to forge APK signatures. Thereafter, the malicious APK signed with your key could be installed as an update for your application. Depending on how a key is used in an application, there are other possible attacks involving a compromised key. Also, some app stores, such as Huawei , do not recommend signing applications with a key length shorter than 2048 bits. Moreover, they don't allow uploading such applications. Recommendations To remediate this vulnerability, you need to sign the application using modern algorithms, such as SHA256withRSA or SHA512withRSA , using a key with a minimum length of 2048 bits (the recommended length is 4096 bits). Note that early versions of Android may not support algorithms higher than SHA1. This article highlights the above problem and provides guidance through the process of signature changing. Example: Generation of key using SHA512withRSA keytool -genkey -v -keystore test.keystore -alias testkey -keyalg RSA -keysize 4096 -sigalg SHA512withRSA -dname \"cn=Test,ou=Test,c=CA\" -validity 10000 Example: Signature with a generated key jarsigner -verbose -sigalg SHA512withRSA -digestalg SHA512 -keystore test.keystore test.apk testkey Links https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/ https://developer.android.com/studio/publish/app-signing https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md https://sites.google.com/site/itstheshappening/ https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/","title":"Insufficient length of a signature key"},{"location":"rg/en/android/insufficient_length_of_a_signature_key/#insufficient-length-of-a-signature-key","text":"Severity: LOW Detection method: SAST, APK","title":"Insufficient length of a signature key"},{"location":"rg/en/android/insufficient_length_of_a_signature_key/#description","text":"The length of the key used for signing an APK file is insufficient. Official NIST recommendations (PDF, pages 64 and 67) qualify 1024-bit RSA keys as insecure (starting from 2013). This doesn't mean that 1024-bit RSA has been compromised, this is more of a preventive measure in order to be a step ahead of attackers. The main risk in using of a weak key is that a malicious person could break it to forge APK signatures. Thereafter, the malicious APK signed with your key could be installed as an update for your application. Depending on how a key is used in an application, there are other possible attacks involving a compromised key. Also, some app stores, such as Huawei , do not recommend signing applications with a key length shorter than 2048 bits. Moreover, they don't allow uploading such applications.","title":"Description"},{"location":"rg/en/android/insufficient_length_of_a_signature_key/#recommendations","text":"To remediate this vulnerability, you need to sign the application using modern algorithms, such as SHA256withRSA or SHA512withRSA , using a key with a minimum length of 2048 bits (the recommended length is 4096 bits). Note that early versions of Android may not support algorithms higher than SHA1. This article highlights the above problem and provides guidance through the process of signature changing. Example: Generation of key using SHA512withRSA keytool -genkey -v -keystore test.keystore -alias testkey -keyalg RSA -keysize 4096 -sigalg SHA512withRSA -dname \"cn=Test,ou=Test,c=CA\" -validity 10000 Example: Signature with a generated key jarsigner -verbose -sigalg SHA512withRSA -digestalg SHA512 -keystore test.keystore test.apk testkey","title":"Recommendations"},{"location":"rg/en/android/insufficient_length_of_a_signature_key/#links","text":"https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/ https://developer.android.com/studio/publish/app-signing https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md https://sites.google.com/site/itstheshappening/ https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/","title":"Links"},{"location":"rg/en/android/interception_of_the_database_encryption_password/","text":"Interception of a database encryption password Severity: INFO Detection method: DAST, API Description The application uses the SQLCipher library to encrypt the database. When creating or opening a database, a password is used, which is then used to encrypt the data. Password interception is not a vulnerability if measures to detect application tooling are used with tools such as Frida or Xposed and the root access check is performed. The intercepted password is used by Mobix to determine its reliability and search for its value in the collected data . Recommendations To protect against runtime password interception, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult. Links https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Interception of a database encryption password"},{"location":"rg/en/android/interception_of_the_database_encryption_password/#interception-of-a-database-encryption-password","text":"Severity: INFO Detection method: DAST, API","title":"Interception of a database encryption password"},{"location":"rg/en/android/interception_of_the_database_encryption_password/#description","text":"The application uses the SQLCipher library to encrypt the database. When creating or opening a database, a password is used, which is then used to encrypt the data. Password interception is not a vulnerability if measures to detect application tooling are used with tools such as Frida or Xposed and the root access check is performed. The intercepted password is used by Mobix to determine its reliability and search for its value in the collected data .","title":"Description"},{"location":"rg/en/android/interception_of_the_database_encryption_password/#recommendations","text":"To protect against runtime password interception, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult.","title":"Recommendations"},{"location":"rg/en/android/interception_of_the_database_encryption_password/#links","text":"https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Links"},{"location":"rg/en/android/output_of_sensitive_information_into_the_system_log/","text":"Output of sensitive information into the system log Severity: HIGH Detection method: DAST, SENSITIVE INFO Description Android provides an option for applications to output information into the system log. Applications can send information into a log file using the android.util.Log class. Before Android 4.0, any app with READ_LOGS permission could access the entire system log, including system logs and logs of other apps. After Android 4.1, the READ_LOGS permission specification has been changed and an application can only access its own data. However, by connecting an Android device to a PC, you can retrieve system log data from other applications. This is why it is so important to ensure that applications do not send confidential information into the system log. The android.util.Log class provides a number of possibilities to output information: Log.d (Debug). Log.e (Error). Log.i (Info). Log.v (Verbose). Log.w (Warn). Also, libraries with similar functionality can be used. One of them is Timber . Example of vulnerable code Log.d(\"authorize\", \"Login Success! access_token=\" + getAccessToken() + \" expires=\" + getAccessExpires()); Recommendations Before publishing an application you need to ensure that confidential information does not go into the system log. Also, if an application uses third-party libraries, you must make sure that these libraries also do not send confidential information and are configured accordingly (a release version of each library is used or correct attributes are set). One of the well-known solutions is to declare and use a user class of logging to automatically include / exclude the information into the system log in accordance with its build type (release / debug). if (BuildConfig.DEBUG) { ... serverEditText.setText(\"http://test.test\"); loginEditText.setText(\"user_test\"); passwordEditText.setText(\"12345\"); ... } It is also good practice to use ProGuard to delete particular logging calls. And to exclude during the release build logging from Timber and android.util.Log libraries. Example of ProGuard settings -assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...); } -assumenosideeffects class timber.log.Timber* { public static *** v(...); public static *** d(...); public static *** i(...); public static *** e(...); public static *** w(...); } Enabling use of ProGuard for a release build of an application buildTypes { releaseSomeBuildType { ... proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'your-proguard-file.pro' } } Links https://www.owasp.org/index.php/Poor_Logging_Practice https://cwe.mitre.org/data/definitions/778.html https://source.android.com/setup/contribute/code-style#log-sparingly","title":"Output of sensitive information into the system log"},{"location":"rg/en/android/output_of_sensitive_information_into_the_system_log/#output-of-sensitive-information-into-the-system-log","text":"Severity: HIGH Detection method: DAST, SENSITIVE INFO","title":"Output of sensitive information into the system log"},{"location":"rg/en/android/output_of_sensitive_information_into_the_system_log/#description","text":"Android provides an option for applications to output information into the system log. Applications can send information into a log file using the android.util.Log class. Before Android 4.0, any app with READ_LOGS permission could access the entire system log, including system logs and logs of other apps. After Android 4.1, the READ_LOGS permission specification has been changed and an application can only access its own data. However, by connecting an Android device to a PC, you can retrieve system log data from other applications. This is why it is so important to ensure that applications do not send confidential information into the system log. The android.util.Log class provides a number of possibilities to output information: Log.d (Debug). Log.e (Error). Log.i (Info). Log.v (Verbose). Log.w (Warn). Also, libraries with similar functionality can be used. One of them is Timber . Example of vulnerable code Log.d(\"authorize\", \"Login Success! access_token=\" + getAccessToken() + \" expires=\" + getAccessExpires());","title":"Description"},{"location":"rg/en/android/output_of_sensitive_information_into_the_system_log/#recommendations","text":"Before publishing an application you need to ensure that confidential information does not go into the system log. Also, if an application uses third-party libraries, you must make sure that these libraries also do not send confidential information and are configured accordingly (a release version of each library is used or correct attributes are set). One of the well-known solutions is to declare and use a user class of logging to automatically include / exclude the information into the system log in accordance with its build type (release / debug). if (BuildConfig.DEBUG) { ... serverEditText.setText(\"http://test.test\"); loginEditText.setText(\"user_test\"); passwordEditText.setText(\"12345\"); ... } It is also good practice to use ProGuard to delete particular logging calls. And to exclude during the release build logging from Timber and android.util.Log libraries. Example of ProGuard settings -assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...); } -assumenosideeffects class timber.log.Timber* { public static *** v(...); public static *** d(...); public static *** i(...); public static *** e(...); public static *** w(...); } Enabling use of ProGuard for a release build of an application buildTypes { releaseSomeBuildType { ... proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'your-proguard-file.pro' } }","title":"Recommendations"},{"location":"rg/en/android/output_of_sensitive_information_into_the_system_log/#links","text":"https://www.owasp.org/index.php/Poor_Logging_Practice https://cwe.mitre.org/data/definitions/778.html https://source.android.com/setup/contribute/code-style#log-sparingly","title":"Links"},{"location":"rg/en/android/possibility_to_create_a_backup_copy_of_the_application/","text":"Possibility to create a backup copy of the application Severity: MEDIUM Detection method: DAST, APK Description An Android application built with the backup option enabled (the android:allowBackup = True flag in AndroidManifest.xml ) can allow an attacker with physical access to the device to create an application backup with all the data stored in the internal directory of the application. In addition to the access to the information, it is possible to change the information contained in the files and restore the settings from the modified backup. This type of exploitation, in some cases, can lead to the compromise of user data. Please note that this option is enabled by default. An example of vulnerable code (AndroidManifest.xml file): <?xml version=\u00bb1.0\u2033 encoding=\u00bbutf-8\u2033?> <manifest xmlns:android=\u00bbhttp://schemas.android.com/apk/res/android\u00bb package=\u00bbcom.appsec.android.activity.privateactivity\u00bb > <application <!\u2014 *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0439 \u043a\u043e\u043f\u0438\u0438 *** \u2014> android:allowBackup=\u00bbtrue\u00bb android:icon=\u00bb@drawable/ic_launcher\u00bb android:label=\u00bb@string/app_name\u00bb > <activity android:name=\u00bb.PrivateActivity\u00bb android:label=\u00bb@string/app_name\u00bb android:exported=\u00bbfalse\u00bb /> </application> </manifest> An example of a command that creates a backup of an application: adb backup -f com.appsec.android Next, using scripts or the android-backup-extractor utility, you need to convert from the Android Backup format to a regular archive and access the data. Or, you can use an alternative command: dd if=mybackup.ab bs=24 skip=1| openssl zlib -d > mybackup.tar # \u0418\u043b\u0438 \u0432\u043e\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f abe abe unpack mybackup.ab mybackup.tar If necessary, you can change the contents of the files, and use the same android-backup-extractor utility to create an Android Backup archive and restore it to the device: abe pack mybackup.tar mybackup.adb restore mybackup.ab Recommendations When building the release version of the application, make sure that the backup option is disabled. You can disable this option by setting the android:allowBackup attribute to false in the manifest file. An example of a secure code: <?xml version=\u00bb1.0\u2033 encoding=\u00bbutf-8\u2033?> <manifest xmlns:android=\u00bbhttp://schemas.android.com/apk/res/android\u00bb package=\u00bbcom.appsec.android.activity.privateactivity\u00bb > <application <!\u2014 *** \u0412\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0439 \u043a\u043e\u043f\u0438\u0438 *** \u2014> android:allowBackup=\u00bbfalse\u00bb android:icon=\u00bb@drawable/ic_launcher\u00bb android:label=\u00bb@string/app_name\u00bb > <activity android:name=\u00bb.PrivateActivity\u00bb android:label=\u00bb@string/app_name\u00bb android:exported=\u00bbfalse\u00bb /> </application> </manifest> Links https://developer.android.com/guide/topics/manifest/application-element#allowbackup https://github.com/nelenkov/android-backup-extractor https://securitygrind.com/exploiting-android-backup/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#local https://resources.infosecinstitute.com/topic/android-hacking-security-part-15-hacking-android-apps-using-backup-techniques/","title":"Possibility to create a backup copy of the application"},{"location":"rg/en/android/possibility_to_create_a_backup_copy_of_the_application/#possibility-to-create-a-backup-copy-of-the-application","text":"Severity: MEDIUM Detection method: DAST, APK","title":"Possibility to create a backup copy of the application"},{"location":"rg/en/android/possibility_to_create_a_backup_copy_of_the_application/#description","text":"An Android application built with the backup option enabled (the android:allowBackup = True flag in AndroidManifest.xml ) can allow an attacker with physical access to the device to create an application backup with all the data stored in the internal directory of the application. In addition to the access to the information, it is possible to change the information contained in the files and restore the settings from the modified backup. This type of exploitation, in some cases, can lead to the compromise of user data. Please note that this option is enabled by default. An example of vulnerable code (AndroidManifest.xml file): <?xml version=\u00bb1.0\u2033 encoding=\u00bbutf-8\u2033?> <manifest xmlns:android=\u00bbhttp://schemas.android.com/apk/res/android\u00bb package=\u00bbcom.appsec.android.activity.privateactivity\u00bb > <application <!\u2014 *** \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0439 \u043a\u043e\u043f\u0438\u0438 *** \u2014> android:allowBackup=\u00bbtrue\u00bb android:icon=\u00bb@drawable/ic_launcher\u00bb android:label=\u00bb@string/app_name\u00bb > <activity android:name=\u00bb.PrivateActivity\u00bb android:label=\u00bb@string/app_name\u00bb android:exported=\u00bbfalse\u00bb /> </application> </manifest> An example of a command that creates a backup of an application: adb backup -f com.appsec.android Next, using scripts or the android-backup-extractor utility, you need to convert from the Android Backup format to a regular archive and access the data. Or, you can use an alternative command: dd if=mybackup.ab bs=24 skip=1| openssl zlib -d > mybackup.tar # \u0418\u043b\u0438 \u0432\u043e\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f abe abe unpack mybackup.ab mybackup.tar If necessary, you can change the contents of the files, and use the same android-backup-extractor utility to create an Android Backup archive and restore it to the device: abe pack mybackup.tar mybackup.adb restore mybackup.ab","title":"Description"},{"location":"rg/en/android/possibility_to_create_a_backup_copy_of_the_application/#recommendations","text":"When building the release version of the application, make sure that the backup option is disabled. You can disable this option by setting the android:allowBackup attribute to false in the manifest file. An example of a secure code: <?xml version=\u00bb1.0\u2033 encoding=\u00bbutf-8\u2033?> <manifest xmlns:android=\u00bbhttp://schemas.android.com/apk/res/android\u00bb package=\u00bbcom.appsec.android.activity.privateactivity\u00bb > <application <!\u2014 *** \u0412\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u0438\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0439 \u043a\u043e\u043f\u0438\u0438 *** \u2014> android:allowBackup=\u00bbfalse\u00bb android:icon=\u00bb@drawable/ic_launcher\u00bb android:label=\u00bb@string/app_name\u00bb > <activity android:name=\u00bb.PrivateActivity\u00bb android:label=\u00bb@string/app_name\u00bb android:exported=\u00bbfalse\u00bb /> </application> </manifest>","title":"Recommendations"},{"location":"rg/en/android/possibility_to_create_a_backup_copy_of_the_application/#links","text":"https://developer.android.com/guide/topics/manifest/application-element#allowbackup https://github.com/nelenkov/android-backup-extractor https://securitygrind.com/exploiting-android-backup/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#local https://resources.infosecinstitute.com/topic/android-hacking-security-part-15-hacking-android-apps-using-backup-techniques/","title":"Links"},{"location":"rg/en/android/potential_execution_of_arbitrary_code_within_the_application/","text":"Potential execution of arbitrary code within the application Severity: CRITICAL Detection method: DAST, IAST Description The application uses a publicly available archive, that can be replaced by an attacker and used to execute arbitrary code. To implement this vulnerability and execute arbitrary code within the application, several conditions should be met: The application uses native code (loads binary libraries with the .so extension when starting or working). The application interacts with an archive (zip, 7zip, etc.) available in public directories (that is, it can be replaced by an attacker). When working with the archive, there are no checks for special characters in the file name (e.g., zipFile.getName().contains(\"../\") ). If there are no such checks, it means that it is possible to overwrite arbitrary files when unzipping the file. The vulnerability is implemented in the following way: The attacker identifies the native libraries loaded into the application and which archive the application communicates with. An attacker prepares a native library containing code that performs certain actions when JNI_OnLoad is loaded ( for example, changing the permissions on a directory to 777, making the directory accessible to everyone). The name of the file must match one of the libraries loaded by the application. Code Example: #include <jni.h> #include <string.h> #include <stdlib.h> JNIEXPORT jint **JNI_OnLoad**(JavaVM* vm, void* reserved) { system(\"chmod -R 777 /data/user/0/com.example.app/\"); JNIEnv* env; if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } return JNI_VERSION_1_6; } Using special tools ( like this script ) prepares an archive that contains the library written inside. When working with an application (or when calling methods that work with archives, such as the Content Provider), the function to unpack the previously created archive is called. The application unzips the archive containing the navigation elements into the directory above (../../) and the path of the directory inside the application sandbox where you want to place the file. As a result of unpacking such an archive, the application replaces the library inside its directory with a library from the archive. The next time the application is run or the library is loaded, the code from the attacker's library will be executed. Recommendations When using any file handling mechanism that can potentially be controlled by an attacker or when implementing interprocess communication mechanisms using files (Content Providers, etc.) it is necessary to validate file names for special characters that can be used for path traversal. A simple example of such a check could be a code fragment for unpacking an archive or a file name/path analysis passed to the IPC mechanisms: zipFile.getName().contains(\"../\") Links https://blog.oversecured.com/Oversecured-detects-dangerous-vulnerabilities-in-the-TikTok-Android-app/ https://github.com/ptoomey3/evilarc https://twitter.com/_bagipro/status/1319365830728208386https://developer.android.com/reference/javax/crypto/KeyGenerator.html","title":"Potential execution of arbitrary code within the application"},{"location":"rg/en/android/potential_execution_of_arbitrary_code_within_the_application/#potential-execution-of-arbitrary-code-within-the-application","text":"Severity: CRITICAL Detection method: DAST, IAST","title":"Potential execution of arbitrary code within the application"},{"location":"rg/en/android/potential_execution_of_arbitrary_code_within_the_application/#description","text":"The application uses a publicly available archive, that can be replaced by an attacker and used to execute arbitrary code. To implement this vulnerability and execute arbitrary code within the application, several conditions should be met: The application uses native code (loads binary libraries with the .so extension when starting or working). The application interacts with an archive (zip, 7zip, etc.) available in public directories (that is, it can be replaced by an attacker). When working with the archive, there are no checks for special characters in the file name (e.g., zipFile.getName().contains(\"../\") ). If there are no such checks, it means that it is possible to overwrite arbitrary files when unzipping the file. The vulnerability is implemented in the following way: The attacker identifies the native libraries loaded into the application and which archive the application communicates with. An attacker prepares a native library containing code that performs certain actions when JNI_OnLoad is loaded ( for example, changing the permissions on a directory to 777, making the directory accessible to everyone). The name of the file must match one of the libraries loaded by the application. Code Example: #include <jni.h> #include <string.h> #include <stdlib.h> JNIEXPORT jint **JNI_OnLoad**(JavaVM* vm, void* reserved) { system(\"chmod -R 777 /data/user/0/com.example.app/\"); JNIEnv* env; if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } return JNI_VERSION_1_6; } Using special tools ( like this script ) prepares an archive that contains the library written inside. When working with an application (or when calling methods that work with archives, such as the Content Provider), the function to unpack the previously created archive is called. The application unzips the archive containing the navigation elements into the directory above (../../) and the path of the directory inside the application sandbox where you want to place the file. As a result of unpacking such an archive, the application replaces the library inside its directory with a library from the archive. The next time the application is run or the library is loaded, the code from the attacker's library will be executed.","title":"Description"},{"location":"rg/en/android/potential_execution_of_arbitrary_code_within_the_application/#recommendations","text":"When using any file handling mechanism that can potentially be controlled by an attacker or when implementing interprocess communication mechanisms using files (Content Providers, etc.) it is necessary to validate file names for special characters that can be used for path traversal. A simple example of such a check could be a code fragment for unpacking an archive or a file name/path analysis passed to the IPC mechanisms: zipFile.getName().contains(\"../\")","title":"Recommendations"},{"location":"rg/en/android/potential_execution_of_arbitrary_code_within_the_application/#links","text":"https://blog.oversecured.com/Oversecured-detects-dangerous-vulnerabilities-in-the-TikTok-Android-app/ https://github.com/ptoomey3/evilarc https://twitter.com/_bagipro/status/1319365830728208386https://developer.android.com/reference/javax/crypto/KeyGenerator.html","title":"Links"},{"location":"rg/en/android/readable_file_keystore/","text":"A readable file keystore Severity: MEDIUM Detection method: DAST, KEY INFORMATION Description An application uses a readable file key storage. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" --------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation --- -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation --- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"A readable file keystore"},{"location":"rg/en/android/readable_file_keystore/#a-readable-file-keystore","text":"Severity: MEDIUM Detection method: DAST, KEY INFORMATION","title":"A readable file keystore"},{"location":"rg/en/android/readable_file_keystore/#description","text":"An application uses a readable file key storage. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/readable_file_keystore/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" --------------------------------------------------------------------------------------- openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation --- -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation --- keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/readable_file_keystore/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/","text":"SSL-Pinning is missing or incorrectly implemented Severity: \u0412\u042b\u0421\u041e\u041a\u0410\u042f Detection method: SAST, APK Description Insufficient attention to setting up proper client-server communication can lead to interception of traffic between application and server. The attacker model in this case can be very different. For example, public Wi-Fi networks, compromised network devices, an attacker on the same network as the device, etc. In absence or improper implementation of protection against traffic interception, a classic MiTM (\"Man in the middle\") attack can occur. The process of this attack is shown in the picture below: \u0420\u0438\u0441. 1. \u0421\u0445\u0435\u043c\u0430 \u0430\u0442\u0430\u043a\u0438 Man-In-The-Middle This scheme shows the following: Application accesses its server via an access point controlled by the attacker. A Proxy server is deployed on this access point. All traffic goes through it. When connecting to this access point, the client is prompted to install a root CA certificate in order to use Internet (via the Captive portal functionality). For each request that passes through the Proxy, it generates its own certificate signed by its root certificate. The same certificate is already installed on the client device. In this configuration, all app traffic will be available to the attacker, as he or she pretends to be the end destination of the mobile device and gives his or her certificate with his or her key when establishing a \"secure\" connection. A secure connection is established with the Proxy server according to the classic scheme below. The server in this case is the attacker's Proxy: \u0420\u0438\u0441. 2. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 SSL-Handshake On the other hand, the Proxy server makes a similar connection to the mobile application backend and sends it data coming from the client. But at that point, the Proxy server can fully read or modify the data that came to it from the mobile app. This attack is only possible if the application trusts the certificates stored in the user storage and if no SSL-Pinning protection is implemented. Nevertheless, such attacks are quite common. Recommendations The main recommendation in this case is to use SSL-Pinning. The essence of this method is as follows. In the SSL-Handshake phase, after the second step, when the server sends us its public key certificate, the application verifies that certain parameters of this certificate match what the application expects to receive. This is some data that is \"hardwired\" into the application. And this is the data we expect to get from our server. This is shown schematically in the picture below. \u0420\u0438\u0441. 3. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 SSL-Pinning In order to understand more precisely implementation details, it is necessary to understand what exactly and at what stages can be checked, and how it can be implemented. What is a certificate A certificate is an electronic document that allows you to verify the authenticity of its owner (user, service, system). It usually contains owner's public key, summary information about the certificate (owner's name, expiration date, etc.) and information about who issued the certificate. All data is cryptographically signed by the issuing organization (usually large trusted companies) and can therefore be verified at any time. What kinds of SSL-Pinning exist Certificate Pinning The first implementation is Certificate Pinning. In this case, the certificate itself is checked, including the metadata (to whom the certificate was issued, expiration date, owner data, etc.). This implementation is the most secure because even a minor change in the certificate will cause a mismatch and will make it impossible to establish a connection. A certificate has an expiration date. Therefore, every time a new certificate is issued, a new version of the application must be released. Public key Pinning This is a simplified implementation of certificate check. During this check, only the public key is checked instead of the entire certificate. Since it is possible to update certificate without changing the public key, this way you do not have to update the application every time you change the certificate. However, companies should have a rotation policy for such keys, so that sooner or later the key will be updated. What certificates can be checked Certificate of the destination server to connect. Guarantees almost 100% that it is your certificate, even if the root certificate authority has been compromised. If a certificate becomes invalid for any reason (either expired or compromised), it will not be possible to connect to the server until the application is updated. Allows the use of self-signed certificates. This can be useful during development. Certificate of an intermediate certification authority. By checking the intermediate certificate, you are trusting the intermediate CA. As long as you use the same certificate provider, any changes to the destination server certificates will work without updating the application. Certificate authority (CA) certificate (root certificate). Checking root certificate means that you trust the root certificate authority and any intermediaries using that certificate authority. If the root certificate is compromised, connection cannot be considered secure and all certificates must be changed immediately. The entire certificate chain. This is the most reliable check from a security point of view, because all possible changes in any of the certificates are checked. At the same time, this verification is the most difficult to maintain, because if any of the certificates involved in the chain change, the application must be updated. How to check For different libraries implementation will be its own, depending on the specific library and its version. But Android has a built-in mechanism for implementing Pinning at the system level, namely the networking configuration. The network communication configuration is an XML file that configures the network security settings for the Android application. This setting is specified by a special attribute in AndroidManifest.xml \u2014 android:networkSecurityConfig . Connection example: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest ... > <application android:networkSecurityConfig=\"@xml/network_security_config\" ... > ... </application> </manifest> Network Security Config allows you to easily enable the Certificate Pinning mechanism in your application. However, it is worth to take into account certain nuances. Let's look at a configuration that at first glance looks like a properly configured one and see how it can be slightly improved: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> </pin-set> </domain-config> </network-security-config> This example has two small disadvantages: The certificate fingerprint (pin-set) does not have an expiration date. There is no backup certificate. If your certificate is about to expire and no expiration date is specified in the settings, the application will stop connecting to the server and generate an error. However, if an expiration date has been set and it expires, the application will switch to the trusted certificate authorities installed in the system. Instead of getting a non-functional application, you will get no SSL Pinning for some time until you update the certificate in the application. To avoid this, if you know the certificate to be used on your server after the current one expires, you can specify it immediately in the \"backup certificates\" settings. Here is an example of the most correct use of the Certificate Pinning functionality: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set expiration=\"2021-01-01\"> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> <!-- backup pin --> <pin digest=\"SHA-256\">fwza0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM1oE=</pin> </pin-set> </domain-config> </network-security-config> Despite all the conveniences of using the Network Security Config, some checks should be performed internally in the application code. For example, you still need to determine if your application performs hostname validation, because Network Security Config does not protect against this type of issue. Also, before implementation, make sure that third-party libraries support Network Security Config. Otherwise, these security measures may cause problems in your application. Besides, Network Security Config is not supported by lower-level network connections, such as web sockets. Here are some examples of the most popular networking libraries and how SSL Pinning can be implemented inside each of them. OkHttp When implementing in OkHttp, you can use the class CertificatePinner class. CertificatePinner certPinner = new CertificatePinner.Builder() .add(\"appmattus.com\", \"sha256/4hw5tz+scE+TW+mlai5YipDfFWn1dqvfLG+nU7tq1V8=\") .build(); OkHttpClient okHttpClient = new OkHttpClient.Builder() .certificatePinner(certPinner) .build(); **In OkHttp you can use this functionality starting from version 2.1. But unfortunately, earlier versions are affected by the vulnerability , fixed only in versions higher than 2.7.5 and higher than 3.2.0. Make sure that the version of the library you are using is not affected by this vulnerability. ** Retrofit Retrofit is used on top of OkHttp, so its use is similar to operations with OkHttpClient , as shown in the example above. Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://appmattus.com\") .addConverterFactory(GsonConverterFactory.create()) .client(okHttpClient) .build(); Picasso For Picasso, if you use OkHttp, similar to the example above, you must configure OkHttpClient. Picasso 2 does not currently support OkHttp 3, so an additional library Picasso 2 OkHttp3 may be required. Picasso picasso = new Picasso.Builder(getApplicationContext()) .downloader(new OkHttpDownloader(okHttpClient)) .build(); Picasso.setSingletonInstance(picasso); Implementation using UrlConnectionDownloader is a bit more complicated. However, it is possible to implement a similar method as in the Volley library (described below) by overloading the openConnection method of the downloader and overriding HostnameVerifier . HttpUrlConnection If HttpUrlConnection is used, it is recommended to reconsider in favor of OkHttp. The version of HttpUrlConnection built into Android is fixed, so updates can be difficult. In the Android document \" Security with HTTPS and SSL \", the proposed implementation is based on pinning certificates with its own TrustManager and SSLSocketFactory . However, as with other APIs, this recommendation will include examples using SPKI. private void validatePinning( X509TrustManagerExtensions trustManagerExt, HttpsURLConnection conn, Set<String> validPins) throws SSLException { String certChainMsg = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); List<X509Certificate> trustedChain = trustedChain(trustManagerExt, conn); for (X509Certificate cert : trustedChain) { byte[] publicKey = cert.getPublicKey().getEncoded(); md.update(publicKey, 0, publicKey.length); String pin = Base64.encodeToString(md.digest(), Base64.NO_WRAP); certChainMsg += \" sha256/\" + pin + \" : \" + cert.getSubjectDN().toString() + \"\\n\"; if (validPins.contains(pin)) { return; } } } catch (NoSuchAlgorithmException e) { throw new SSLException(e); } throw new SSLPeerUnverifiedException(\"Certificate pinning \" + \"failure\\n Peer certificate chain:\\n\" + certChainMsg); } private List<X509Certificate> trustedChain( X509TrustManagerExtensions trustManagerExt, HttpsURLConnection conn) throws SSLException { Certificate[] serverCerts = conn.getServerCertificates(); X509Certificate[] untrustedCerts = Arrays.copyOf(serverCerts, serverCerts.length, X509Certificate[].class); String host = conn.getURL().getHost(); try { return trustManagerExt.checkServerTrusted(untrustedCerts, \"RSA\", host); } catch (CertificateException e) { throw new SSLException(e); } } This implementation shall be called like this: TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init((KeyStore) null); // Find first X509TrustManager in the TrustManagerFactory X509TrustManager x509TrustManager = null; for (TrustManager trustManager : trustManagerFactory.getTrustManagers()) { if (trustManager instanceof X509TrustManager) { x509TrustManager = (X509TrustManager) trustManager; break; } } X509TrustManagerExtensions trustManagerExt = new X509TrustManagerExtensions(x509TrustManager); ... URL url = new URL(\"https://www.appmattus.com/\"); HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); urlConnection.connect(); Set<String> validPins = Collections.singleton (\"4hw5tz+scE+TW+mlai5YipDfFWn1dqvfLG+nU7tq1V8=\"); validatePinning(trustManagerExt, urlConnection, validPins); In this case, the call of urlConnection.connect() performs SSL Handshake, but does not transfer any data until urlConnection.getInputStream() is called. Volley The standard way to use the Volley library is to Pinning certificates, as shown in the article \" Android Security Tip: Public Key Pinning with Volley Library \". The GitHub project Public Key Pinning with Android Volley library shows how SSLSocketFactory can be configured to bind to SPKI. An alternative method can be used in addition to the approaches listed above. It uses the HostnameVerifier class. This class is used to verify that the host name in the URL matches that specified in the certificate. You can override HostnameVerifier as follows: RequestQueue requestQueue = Volley.newRequestQueue(appContext, new HurlStack() { @Override protected HttpURLConnection createConnection(URL url) throws IOException { HttpURLConnection connection = super.createConnection(url); if (connection instanceof HttpsURLConnection) { HostnameVerifier delegate = urlConnection.getHostnameVerifier(); HostnameVerifier pinningVerifier = new PinningHostnameVerifier(delegate); urlConnection.setHostnameVerifier(pinningVerifier); } return connection; } }); ... public static class PinningHostnameVerifier implements HostnameVerifier { private final HostnameVerifier delegate; private PinningHostnameVerifier(HostnameVerifier delegate) { this.delegate = delegate; } @Override public boolean verify(String host, SSLSession sslSession) { if (delegate.verify(host, sslSession)) { try { validatePinning(sslSession.getPeerCertificates(), host, validPins); return true; } catch (SSLException e) { throw new RuntimeException(e); } } return false; } } Links Network security configuration | Android Developers A Security Analyst\u2019s Guide to Network Security Configuration in Android P GitHub - square/okhttp: Square\u2019s meticulous HTTP client for the JVM, Android, and GraalVM. Vulnerability in OkHttp\u2019s Certificate Pinner GitHub - JakeWharton/picasso2-okhttp3-downloader: A OkHttp 3 downloader implementation for Picasso 2. Security with HTTPS and SSL | Android Developers Android Security Tip: Public Key Pinning with Volley Library GitHub - faruktoptas/volley-public-key-pinning: Public key pinning with Android volley networking library","title":"SSL-Pinning is missing or incorrectly implemented"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#ssl-pinning-is-missing-or-incorrectly-implemented","text":"Severity: \u0412\u042b\u0421\u041e\u041a\u0410\u042f Detection method: SAST, APK","title":"SSL-Pinning is missing or incorrectly implemented"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#description","text":"Insufficient attention to setting up proper client-server communication can lead to interception of traffic between application and server. The attacker model in this case can be very different. For example, public Wi-Fi networks, compromised network devices, an attacker on the same network as the device, etc. In absence or improper implementation of protection against traffic interception, a classic MiTM (\"Man in the middle\") attack can occur. The process of this attack is shown in the picture below: \u0420\u0438\u0441. 1. \u0421\u0445\u0435\u043c\u0430 \u0430\u0442\u0430\u043a\u0438 Man-In-The-Middle This scheme shows the following: Application accesses its server via an access point controlled by the attacker. A Proxy server is deployed on this access point. All traffic goes through it. When connecting to this access point, the client is prompted to install a root CA certificate in order to use Internet (via the Captive portal functionality). For each request that passes through the Proxy, it generates its own certificate signed by its root certificate. The same certificate is already installed on the client device. In this configuration, all app traffic will be available to the attacker, as he or she pretends to be the end destination of the mobile device and gives his or her certificate with his or her key when establishing a \"secure\" connection. A secure connection is established with the Proxy server according to the classic scheme below. The server in this case is the attacker's Proxy: \u0420\u0438\u0441. 2. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 SSL-Handshake On the other hand, the Proxy server makes a similar connection to the mobile application backend and sends it data coming from the client. But at that point, the Proxy server can fully read or modify the data that came to it from the mobile app. This attack is only possible if the application trusts the certificates stored in the user storage and if no SSL-Pinning protection is implemented. Nevertheless, such attacks are quite common.","title":"Description"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#recommendations","text":"The main recommendation in this case is to use SSL-Pinning. The essence of this method is as follows. In the SSL-Handshake phase, after the second step, when the server sends us its public key certificate, the application verifies that certain parameters of this certificate match what the application expects to receive. This is some data that is \"hardwired\" into the application. And this is the data we expect to get from our server. This is shown schematically in the picture below. \u0420\u0438\u0441. 3. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 SSL-Pinning In order to understand more precisely implementation details, it is necessary to understand what exactly and at what stages can be checked, and how it can be implemented.","title":"Recommendations"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#what-is-a-certificate","text":"A certificate is an electronic document that allows you to verify the authenticity of its owner (user, service, system). It usually contains owner's public key, summary information about the certificate (owner's name, expiration date, etc.) and information about who issued the certificate. All data is cryptographically signed by the issuing organization (usually large trusted companies) and can therefore be verified at any time.","title":"What is a certificate"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#what-kinds-of-ssl-pinning-exist","text":"","title":"What kinds of SSL-Pinning exist"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#certificate-pinning","text":"The first implementation is Certificate Pinning. In this case, the certificate itself is checked, including the metadata (to whom the certificate was issued, expiration date, owner data, etc.). This implementation is the most secure because even a minor change in the certificate will cause a mismatch and will make it impossible to establish a connection. A certificate has an expiration date. Therefore, every time a new certificate is issued, a new version of the application must be released.","title":"Certificate Pinning"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#public-key-pinning","text":"This is a simplified implementation of certificate check. During this check, only the public key is checked instead of the entire certificate. Since it is possible to update certificate without changing the public key, this way you do not have to update the application every time you change the certificate. However, companies should have a rotation policy for such keys, so that sooner or later the key will be updated.","title":"Public key Pinning"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#what-certificates-can-be-checked","text":"Certificate of the destination server to connect. Guarantees almost 100% that it is your certificate, even if the root certificate authority has been compromised. If a certificate becomes invalid for any reason (either expired or compromised), it will not be possible to connect to the server until the application is updated. Allows the use of self-signed certificates. This can be useful during development. Certificate of an intermediate certification authority. By checking the intermediate certificate, you are trusting the intermediate CA. As long as you use the same certificate provider, any changes to the destination server certificates will work without updating the application. Certificate authority (CA) certificate (root certificate). Checking root certificate means that you trust the root certificate authority and any intermediaries using that certificate authority. If the root certificate is compromised, connection cannot be considered secure and all certificates must be changed immediately. The entire certificate chain. This is the most reliable check from a security point of view, because all possible changes in any of the certificates are checked. At the same time, this verification is the most difficult to maintain, because if any of the certificates involved in the chain change, the application must be updated. How to check For different libraries implementation will be its own, depending on the specific library and its version. But Android has a built-in mechanism for implementing Pinning at the system level, namely the networking configuration. The network communication configuration is an XML file that configures the network security settings for the Android application. This setting is specified by a special attribute in AndroidManifest.xml \u2014 android:networkSecurityConfig . Connection example: <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest ... > <application android:networkSecurityConfig=\"@xml/network_security_config\" ... > ... </application> </manifest> Network Security Config allows you to easily enable the Certificate Pinning mechanism in your application. However, it is worth to take into account certain nuances. Let's look at a configuration that at first glance looks like a properly configured one and see how it can be slightly improved: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> </pin-set> </domain-config> </network-security-config> This example has two small disadvantages: The certificate fingerprint (pin-set) does not have an expiration date. There is no backup certificate. If your certificate is about to expire and no expiration date is specified in the settings, the application will stop connecting to the server and generate an error. However, if an expiration date has been set and it expires, the application will switch to the trusted certificate authorities installed in the system. Instead of getting a non-functional application, you will get no SSL Pinning for some time until you update the certificate in the application. To avoid this, if you know the certificate to be used on your server after the current one expires, you can specify it immediately in the \"backup certificates\" settings. Here is an example of the most correct use of the Certificate Pinning functionality: <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set expiration=\"2021-01-01\"> <pin digest=\"SHA-256\">7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=</pin> <!-- backup pin --> <pin digest=\"SHA-256\">fwza0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM1oE=</pin> </pin-set> </domain-config> </network-security-config> Despite all the conveniences of using the Network Security Config, some checks should be performed internally in the application code. For example, you still need to determine if your application performs hostname validation, because Network Security Config does not protect against this type of issue. Also, before implementation, make sure that third-party libraries support Network Security Config. Otherwise, these security measures may cause problems in your application. Besides, Network Security Config is not supported by lower-level network connections, such as web sockets. Here are some examples of the most popular networking libraries and how SSL Pinning can be implemented inside each of them.","title":"What certificates can be checked"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#okhttp","text":"When implementing in OkHttp, you can use the class CertificatePinner class. CertificatePinner certPinner = new CertificatePinner.Builder() .add(\"appmattus.com\", \"sha256/4hw5tz+scE+TW+mlai5YipDfFWn1dqvfLG+nU7tq1V8=\") .build(); OkHttpClient okHttpClient = new OkHttpClient.Builder() .certificatePinner(certPinner) .build(); **In OkHttp you can use this functionality starting from version 2.1. But unfortunately, earlier versions are affected by the vulnerability , fixed only in versions higher than 2.7.5 and higher than 3.2.0. Make sure that the version of the library you are using is not affected by this vulnerability. **","title":"OkHttp"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#retrofit","text":"Retrofit is used on top of OkHttp, so its use is similar to operations with OkHttpClient , as shown in the example above. Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://appmattus.com\") .addConverterFactory(GsonConverterFactory.create()) .client(okHttpClient) .build();","title":"Retrofit"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#picasso","text":"For Picasso, if you use OkHttp, similar to the example above, you must configure OkHttpClient. Picasso 2 does not currently support OkHttp 3, so an additional library Picasso 2 OkHttp3 may be required. Picasso picasso = new Picasso.Builder(getApplicationContext()) .downloader(new OkHttpDownloader(okHttpClient)) .build(); Picasso.setSingletonInstance(picasso); Implementation using UrlConnectionDownloader is a bit more complicated. However, it is possible to implement a similar method as in the Volley library (described below) by overloading the openConnection method of the downloader and overriding HostnameVerifier .","title":"Picasso"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#httpurlconnection","text":"If HttpUrlConnection is used, it is recommended to reconsider in favor of OkHttp. The version of HttpUrlConnection built into Android is fixed, so updates can be difficult. In the Android document \" Security with HTTPS and SSL \", the proposed implementation is based on pinning certificates with its own TrustManager and SSLSocketFactory . However, as with other APIs, this recommendation will include examples using SPKI. private void validatePinning( X509TrustManagerExtensions trustManagerExt, HttpsURLConnection conn, Set<String> validPins) throws SSLException { String certChainMsg = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); List<X509Certificate> trustedChain = trustedChain(trustManagerExt, conn); for (X509Certificate cert : trustedChain) { byte[] publicKey = cert.getPublicKey().getEncoded(); md.update(publicKey, 0, publicKey.length); String pin = Base64.encodeToString(md.digest(), Base64.NO_WRAP); certChainMsg += \" sha256/\" + pin + \" : \" + cert.getSubjectDN().toString() + \"\\n\"; if (validPins.contains(pin)) { return; } } } catch (NoSuchAlgorithmException e) { throw new SSLException(e); } throw new SSLPeerUnverifiedException(\"Certificate pinning \" + \"failure\\n Peer certificate chain:\\n\" + certChainMsg); } private List<X509Certificate> trustedChain( X509TrustManagerExtensions trustManagerExt, HttpsURLConnection conn) throws SSLException { Certificate[] serverCerts = conn.getServerCertificates(); X509Certificate[] untrustedCerts = Arrays.copyOf(serverCerts, serverCerts.length, X509Certificate[].class); String host = conn.getURL().getHost(); try { return trustManagerExt.checkServerTrusted(untrustedCerts, \"RSA\", host); } catch (CertificateException e) { throw new SSLException(e); } } This implementation shall be called like this: TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init((KeyStore) null); // Find first X509TrustManager in the TrustManagerFactory X509TrustManager x509TrustManager = null; for (TrustManager trustManager : trustManagerFactory.getTrustManagers()) { if (trustManager instanceof X509TrustManager) { x509TrustManager = (X509TrustManager) trustManager; break; } } X509TrustManagerExtensions trustManagerExt = new X509TrustManagerExtensions(x509TrustManager); ... URL url = new URL(\"https://www.appmattus.com/\"); HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); urlConnection.connect(); Set<String> validPins = Collections.singleton (\"4hw5tz+scE+TW+mlai5YipDfFWn1dqvfLG+nU7tq1V8=\"); validatePinning(trustManagerExt, urlConnection, validPins); In this case, the call of urlConnection.connect() performs SSL Handshake, but does not transfer any data until urlConnection.getInputStream() is called.","title":"HttpUrlConnection"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#volley","text":"The standard way to use the Volley library is to Pinning certificates, as shown in the article \" Android Security Tip: Public Key Pinning with Volley Library \". The GitHub project Public Key Pinning with Android Volley library shows how SSLSocketFactory can be configured to bind to SPKI. An alternative method can be used in addition to the approaches listed above. It uses the HostnameVerifier class. This class is used to verify that the host name in the URL matches that specified in the certificate. You can override HostnameVerifier as follows: RequestQueue requestQueue = Volley.newRequestQueue(appContext, new HurlStack() { @Override protected HttpURLConnection createConnection(URL url) throws IOException { HttpURLConnection connection = super.createConnection(url); if (connection instanceof HttpsURLConnection) { HostnameVerifier delegate = urlConnection.getHostnameVerifier(); HostnameVerifier pinningVerifier = new PinningHostnameVerifier(delegate); urlConnection.setHostnameVerifier(pinningVerifier); } return connection; } }); ... public static class PinningHostnameVerifier implements HostnameVerifier { private final HostnameVerifier delegate; private PinningHostnameVerifier(HostnameVerifier delegate) { this.delegate = delegate; } @Override public boolean verify(String host, SSLSession sslSession) { if (delegate.verify(host, sslSession)) { try { validatePinning(sslSession.getPeerCertificates(), host, validPins); return true; } catch (SSLException e) { throw new RuntimeException(e); } } return false; } }","title":"Volley"},{"location":"rg/en/android/ssl-pinning_is_missing_or_incorrectly_realized/#links","text":"Network security configuration | Android Developers A Security Analyst\u2019s Guide to Network Security Configuration in Android P GitHub - square/okhttp: Square\u2019s meticulous HTTP client for the JVM, Android, and GraalVM. Vulnerability in OkHttp\u2019s Certificate Pinner GitHub - JakeWharton/picasso2-okhttp3-downloader: A OkHttp 3 downloader implementation for Picasso 2. Security with HTTPS and SSL | Android Developers Android Security Tip: Public Key Pinning with Volley Library GitHub - faruktoptas/volley-public-key-pinning: Public key pinning with Android volley networking library","title":"Links"},{"location":"rg/en/android/storage_or_use_of_previously_found_sensitive_information/","text":"Storage or use of previously found sensitive information Severity: MEDIUM Detection method: DAST, API Description An application stores or uses sensitive information in its operation. During its operation, an application often handles sensitive information such as passwords, various tokens, encryption keys, etc. During the analysis of the application Mobix detects such information according to the search rules and additionally checks if the found sensitive information is stored unchanged or is used by the application in other functions or is \u201cembedded\u201c in the source code of application . Recommendations If you need to use sensitive information in the application, make sure that it is stored correctly and does not escape to public places, such as system logs (logcat) or application files on the SD-card. If it is necessary to store such information, it is recommended to use encryption. To ensure privacy, Android is equipped with many cryptographic features and methods that allow Android applications to securely encrypt and decrypt (to ensure privacy), as well as perform message authentication (MAC) and digital signatures (to verify integrity). In order to select an encryption method and key type suitable for the given conditions, you can use the following scheme: Encryption/decryption using Android KeyStore As an example, let's consider encryption/decryption using Android KeyStore. This mechanism allows you to generate and use keys generated in the Android hardware key store. This approach is the most secure in terms of key storage because the private key never appears in memory, which minimizes the risk of leakage or compromise. Creating new keys Before you start the encryption process, you must set the alias that will be used to encrypt/decrypt the data. This can be any string. Alias is the entry name to refer to the generated key in the Android KeyStore. First, you need to get an instance of Android KeyGenerator . final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\"); This example uses the AES algorithm and the keys will be stored in AndroidKeyStore. Next you need to create a KeyGenParameterSpec , using KeyGenParameterSpec.Builder to pass to the initialization method KeyGenerators . What is KeyGenParameterSpec? KeyGenParameterSpec is some properties of the keys that will be generated. For example, you can specify the validity period of a key, its purpose, and various other parameters. final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE); final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .build(); In the example above, the first argument is the alias, that will be used to refer to this key. Then the purpose of this key is specified - to encrypt and decrypt data. The setBlockModes specifies a mode for using this key. Since we use the \" AES / GCM / NoPadding \" conversion algorithm, it is necessary to specify BLOCK_MODE_GCM . And the last parameter specifies the padding mode ( ENCRYPTION_PADDING_NONE ). Data encryption The presets are now complete. The following example can be used to encrypt data: final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE); final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .build(); keyGenerator.init(keyGenParameterSpec); final SecretKey secretKey = keyGenerator.generateKey(); final Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); cipher.init(Cipher.ENCRYPT_MODE, secretKey); First, the keyGenerator is initialized using keyGenParameterSpec . After that - the SecretKey generation itself. Now a secret key is available, you can use it to initialize the Cipher object, which is actually responsible for the encryption. final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE); final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .build(); keyGenerator.init(keyGenParameterSpec); final SecretKey secretKey = keyGenerator.generateKey(); final Cipher cipher = Cipher.getInstance(TRANSFORMATION); cipher.init(Cipher.ENCRYPT_MODE, secretKey); iv = cipher.getIV(); encryption = cipher.doFinal(textToEncrypt.getBytes(\"UTF-8\")); Then a reference to the initialization vector (IV) is used. This vector is also required for decryption. Using doFinal (textToEncrypt) we finish the encryption operation. The doFinal method returns an array of bytes, which is the encrypted text. Data decryption Launching KeyStore Before we can start decrypting data, we need a KeyStore instance. keyStore = KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); KeyStore is used to get a private key using the alias that was previously used to encrypt the data. You need SecretKeyEntry from the key store to get the secretKey . keyStore = KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore .getEntry(alias, null); final SecretKey secretKey = secretKeyEntry.getSecretKey(); Use GCMParameterSpec with Cipher to initialize the decryption process (the encryptionIv parameter is the initialization vector that was used for encryption). keyStore = KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore .getEntry(alias, null); final SecretKey secretKey = secretKeyEntry.getSecretKey(); final Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); final GCMParameterSpec spec = new GCMParameterSpec(128, encryptionIv); cipher.init(Cipher.DECRYPT_MODE, secretKey, spec); And, as we did before, to get the decrypted data: final byte[] decodedData = cipher.doFinal(encryptedData); To get an unencrypted string representation: final String unencryptedString = new String(decodedData, \"UTF-8\"); Complete example source code . Links https://medium.com/@josiassena/using-the-android-keystore-system-to-store-sensitive-information-3a56175a454bhttps://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://gist.github.com/JosiasSena/3bf4ca59777f7dedcaf41a495d96d984https://cwe.mitre.org/data/definitions/200.html https://developer.android.com/reference/javax/crypto/KeyGenerator.html https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder.html https://developer.android.com/reference/android/security/keystore/KeyProperties.html https://developer.android.com/reference/javax/crypto/SecretKey.html https://developer.android.com/reference/javax/crypto/Cipher.html https://developer.android.com/reference/javax/crypto/spec/GCMParameterSpec.html","title":"Storage or use of previously found sensitive information"},{"location":"rg/en/android/storage_or_use_of_previously_found_sensitive_information/#storage-or-use-of-previously-found-sensitive-information","text":"Severity: MEDIUM Detection method: DAST, API","title":"Storage or use of previously found sensitive information"},{"location":"rg/en/android/storage_or_use_of_previously_found_sensitive_information/#description","text":"An application stores or uses sensitive information in its operation. During its operation, an application often handles sensitive information such as passwords, various tokens, encryption keys, etc. During the analysis of the application Mobix detects such information according to the search rules and additionally checks if the found sensitive information is stored unchanged or is used by the application in other functions or is \u201cembedded\u201c in the source code of application .","title":"Description"},{"location":"rg/en/android/storage_or_use_of_previously_found_sensitive_information/#recommendations","text":"If you need to use sensitive information in the application, make sure that it is stored correctly and does not escape to public places, such as system logs (logcat) or application files on the SD-card. If it is necessary to store such information, it is recommended to use encryption. To ensure privacy, Android is equipped with many cryptographic features and methods that allow Android applications to securely encrypt and decrypt (to ensure privacy), as well as perform message authentication (MAC) and digital signatures (to verify integrity). In order to select an encryption method and key type suitable for the given conditions, you can use the following scheme: Encryption/decryption using Android KeyStore As an example, let's consider encryption/decryption using Android KeyStore. This mechanism allows you to generate and use keys generated in the Android hardware key store. This approach is the most secure in terms of key storage because the private key never appears in memory, which minimizes the risk of leakage or compromise. Creating new keys Before you start the encryption process, you must set the alias that will be used to encrypt/decrypt the data. This can be any string. Alias is the entry name to refer to the generated key in the Android KeyStore. First, you need to get an instance of Android KeyGenerator . final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\"); This example uses the AES algorithm and the keys will be stored in AndroidKeyStore. Next you need to create a KeyGenParameterSpec , using KeyGenParameterSpec.Builder to pass to the initialization method KeyGenerators . What is KeyGenParameterSpec? KeyGenParameterSpec is some properties of the keys that will be generated. For example, you can specify the validity period of a key, its purpose, and various other parameters. final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE); final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .build(); In the example above, the first argument is the alias, that will be used to refer to this key. Then the purpose of this key is specified - to encrypt and decrypt data. The setBlockModes specifies a mode for using this key. Since we use the \" AES / GCM / NoPadding \" conversion algorithm, it is necessary to specify BLOCK_MODE_GCM . And the last parameter specifies the padding mode ( ENCRYPTION_PADDING_NONE ). Data encryption The presets are now complete. The following example can be used to encrypt data: final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE); final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .build(); keyGenerator.init(keyGenParameterSpec); final SecretKey secretKey = keyGenerator.generateKey(); final Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); cipher.init(Cipher.ENCRYPT_MODE, secretKey); First, the keyGenerator is initialized using keyGenParameterSpec . After that - the SecretKey generation itself. Now a secret key is available, you can use it to initialize the Cipher object, which is actually responsible for the encryption. final KeyGenerator keyGenerator = KeyGenerator .getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE); final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .build(); keyGenerator.init(keyGenParameterSpec); final SecretKey secretKey = keyGenerator.generateKey(); final Cipher cipher = Cipher.getInstance(TRANSFORMATION); cipher.init(Cipher.ENCRYPT_MODE, secretKey); iv = cipher.getIV(); encryption = cipher.doFinal(textToEncrypt.getBytes(\"UTF-8\")); Then a reference to the initialization vector (IV) is used. This vector is also required for decryption. Using doFinal (textToEncrypt) we finish the encryption operation. The doFinal method returns an array of bytes, which is the encrypted text. Data decryption Launching KeyStore Before we can start decrypting data, we need a KeyStore instance. keyStore = KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); KeyStore is used to get a private key using the alias that was previously used to encrypt the data. You need SecretKeyEntry from the key store to get the secretKey . keyStore = KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore .getEntry(alias, null); final SecretKey secretKey = secretKeyEntry.getSecretKey(); Use GCMParameterSpec with Cipher to initialize the decryption process (the encryptionIv parameter is the initialization vector that was used for encryption). keyStore = KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore .getEntry(alias, null); final SecretKey secretKey = secretKeyEntry.getSecretKey(); final Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); final GCMParameterSpec spec = new GCMParameterSpec(128, encryptionIv); cipher.init(Cipher.DECRYPT_MODE, secretKey, spec); And, as we did before, to get the decrypted data: final byte[] decodedData = cipher.doFinal(encryptedData); To get an unencrypted string representation: final String unencryptedString = new String(decodedData, \"UTF-8\"); Complete example source code .","title":"Recommendations"},{"location":"rg/en/android/storage_or_use_of_previously_found_sensitive_information/#links","text":"https://medium.com/@josiassena/using-the-android-keystore-system-to-store-sensitive-information-3a56175a454bhttps://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://gist.github.com/JosiasSena/3bf4ca59777f7dedcaf41a495d96d984https://cwe.mitre.org/data/definitions/200.html https://developer.android.com/reference/javax/crypto/KeyGenerator.html https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder.html https://developer.android.com/reference/android/security/keystore/KeyProperties.html https://developer.android.com/reference/javax/crypto/SecretKey.html https://developer.android.com/reference/javax/crypto/Cipher.html https://developer.android.com/reference/javax/crypto/spec/GCMParameterSpec.html","title":"Links"},{"location":"rg/en/android/storing_a_key_certificate_in_the_directory_resources_of_the_application/","text":"Storing a key/certificate in the directory/resources of the application Severity: INFO Detection method: DAST, SENSITIVE INFO Description The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below. Recommendations The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6). Android 6 and higher For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the API KeyGenParameterSpec . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired() when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it. Lower than Android 6 For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyPairGeneratorSpec API . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; } Links https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Storing a key/certificate in the directory/resources of the application"},{"location":"rg/en/android/storing_a_key_certificate_in_the_directory_resources_of_the_application/#storing-a-keycertificate-in-the-directoryresources-of-the-application","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Storing a key/certificate in the directory/resources of the application"},{"location":"rg/en/android/storing_a_key_certificate_in_the_directory_resources_of_the_application/#description","text":"The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below.","title":"Description"},{"location":"rg/en/android/storing_a_key_certificate_in_the_directory_resources_of_the_application/#recommendations","text":"The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6).","title":"Recommendations"},{"location":"rg/en/android/storing_a_key_certificate_in_the_directory_resources_of_the_application/#android-6-and-higher","text":"For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the API KeyGenParameterSpec . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired() when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it.","title":"Android 6 and higher"},{"location":"rg/en/android/storing_a_key_certificate_in_the_directory_resources_of_the_application/#lower-than-android-6","text":"For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyPairGeneratorSpec API . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; }","title":"Lower than Android 6"},{"location":"rg/en/android/storing_a_key_certificate_in_the_directory_resources_of_the_application/#links","text":"https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Links"},{"location":"rg/en/android/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application/","text":"Storing a private key/certificate protected by a password in the directory/resources of the application Severity: LOW Detection method: DAST, SENSITIVE INFO Description Storing a password-protected private key anywhere on the device's file system can be a serious problem if the password is not strong enough or if it is compromised. Private keys are used to encrypt or decrypt data (depending on the type of algorithm, symmetric or asymmetric) and must not be available to anyone. A more serious vulnerability is the use of a single key supplied with the application (in the resources or obtained from the server) to the data of different users. By retrieving the value of such a key from one instance of the application, you can decrypt data from another user. Recommendations Although storing a private key with a password is not an immediate vulnerability, there are risks associated with its use. The following are recommendations for creating and storing keys for encryption operations. The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6). Android 6 and higher For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the API KeyGenParameterSpec . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired() when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it. Lower than Android 6 For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyGenParameterSpec . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; } Links https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Storing a private key/certificate protected by a password in the directory/resources of the application"},{"location":"rg/en/android/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application/#storing-a-private-keycertificate-protected-by-a-password-in-the-directoryresources-of-the-application","text":"Severity: LOW Detection method: DAST, SENSITIVE INFO","title":"Storing a private key/certificate protected by a password in the directory/resources of the application"},{"location":"rg/en/android/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application/#description","text":"Storing a password-protected private key anywhere on the device's file system can be a serious problem if the password is not strong enough or if it is compromised. Private keys are used to encrypt or decrypt data (depending on the type of algorithm, symmetric or asymmetric) and must not be available to anyone. A more serious vulnerability is the use of a single key supplied with the application (in the resources or obtained from the server) to the data of different users. By retrieving the value of such a key from one instance of the application, you can decrypt data from another user.","title":"Description"},{"location":"rg/en/android/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application/#recommendations","text":"Although storing a private key with a password is not an immediate vulnerability, there are risks associated with its use. The following are recommendations for creating and storing keys for encryption operations. The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6).","title":"Recommendations"},{"location":"rg/en/android/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application/#android-6-and-higher","text":"For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the API KeyGenParameterSpec . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired() when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it.","title":"Android 6 and higher"},{"location":"rg/en/android/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application/#lower-than-android-6","text":"For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyGenParameterSpec . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; }","title":"Lower than Android 6"},{"location":"rg/en/android/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application/#links","text":"https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Links"},{"location":"rg/en/android/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application/","text":"Storing a private key/certificate that is not protected by a password in the directory/resources of the application Severity: HIGH Detection method: DAST, SENSITIVE INFO Description Storing a private key that is not password protected (that is, in open form) anywhere in the device's file system is a serious problem. Private keys are used to encrypt or decrypt data (depending on the type of algorithm, symmetric or asymmetric) and must not be available to anyone. A more serious vulnerability is the use of a single key supplied with the application (in the resources or obtained from the server) to the data of different users. By retrieving the value of such a key from one instance of the application, you can decrypt data from another user. Recommendations The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6). Android 6 and higher For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the KeyGenParameterSpec API . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired () when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it. Lower than Android 6 For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyPairGeneratorSpec API . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; } Links https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Storing a private key/certificate that is not protected by a password in the directory/resources of the application"},{"location":"rg/en/android/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application/#storing-a-private-keycertificate-that-is-not-protected-by-a-password-in-the-directoryresources-of-the-application","text":"Severity: HIGH Detection method: DAST, SENSITIVE INFO","title":"Storing a private key/certificate that is not protected by a password in the directory/resources of the application"},{"location":"rg/en/android/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application/#description","text":"Storing a private key that is not password protected (that is, in open form) anywhere in the device's file system is a serious problem. Private keys are used to encrypt or decrypt data (depending on the type of algorithm, symmetric or asymmetric) and must not be available to anyone. A more serious vulnerability is the use of a single key supplied with the application (in the resources or obtained from the server) to the data of different users. By retrieving the value of such a key from one instance of the application, you can decrypt data from another user.","title":"Description"},{"location":"rg/en/android/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application/#recommendations","text":"The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6).","title":"Recommendations"},{"location":"rg/en/android/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application/#android-6-and-higher","text":"For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the KeyGenParameterSpec API . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired () when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it.","title":"Android 6 and higher"},{"location":"rg/en/android/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application/#lower-than-android-6","text":"For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyPairGeneratorSpec API . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; }","title":"Lower than Android 6"},{"location":"rg/en/android/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application/#links","text":"https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Links"},{"location":"rg/en/android/storing_a_public_key_certificate_in_the_directory_resources_of_the_application/","text":"Storing a public key/certificate in the directory/resources of the application Severity: INFO Detection method: DAST, SENSITIVE INFO Description Storing a public key in the directory/resources of the application is generally not a problem. Public keys are typically used to encrypt/sign data or authenticate the server. A more serious vulnerability is the use of a single key supplied with the application (in the resources or obtained from the server) to the data of different users. By retrieving the value of such a key from one instance of the application, you can decrypt data from another user. Or if it is possible to replace the public key and it is used to authenticate the server, the risk of a man-in-the-middle (MiTM) attack increases. Recommendations Although storing a public key is not a vulnerability, the following are approaches to secure use and storage of keys. The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6). Android 6 and higher For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the API KeyGenParameterSpec . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired () when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it. Lower than Android 6 For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyPairGeneratorSpec API . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; } Links https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Storing a public key/certificate in the directory/resources of the application"},{"location":"rg/en/android/storing_a_public_key_certificate_in_the_directory_resources_of_the_application/#storing-a-public-keycertificate-in-the-directoryresources-of-the-application","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Storing a public key/certificate in the directory/resources of the application"},{"location":"rg/en/android/storing_a_public_key_certificate_in_the_directory_resources_of_the_application/#description","text":"Storing a public key in the directory/resources of the application is generally not a problem. Public keys are typically used to encrypt/sign data or authenticate the server. A more serious vulnerability is the use of a single key supplied with the application (in the resources or obtained from the server) to the data of different users. By retrieving the value of such a key from one instance of the application, you can decrypt data from another user. Or if it is possible to replace the public key and it is used to authenticate the server, the risk of a man-in-the-middle (MiTM) attack increases.","title":"Description"},{"location":"rg/en/android/storing_a_public_key_certificate_in_the_directory_resources_of_the_application/#recommendations","text":"Although storing a public key is not a vulnerability, the following are approaches to secure use and storage of keys. The recommended way to store keys is to use KeyChain. KeyStore provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from KeyStore, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from KeyStore and use it to decrypt the data. The way you use Android KeyStore differs depending on the Android version (higher or lower than Android 6).","title":"Recommendations"},{"location":"rg/en/android/storing_a_public_key_certificate_in_the_directory_resources_of_the_application/#android-6-and-higher","text":"For API level 23 and higher, the implementation will be easier because the AES keys are generated by the system. An example can be found in the API KeyGenParameterSpec . Key generation: private static final String AndroidKeyStore = \"AndroidKeyStore\"; private static final String AES_MODE = \"AES/GCM/NoPadding\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); if (!keyStore.containsAlias(KEY_ALIAS)) { KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, AndroidKeyStore); keyGenerator.init( new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) .setRandomizedEncryptionRequired(false) .build()); keyGenerator.generateKey(); } Receiving the key: private java.security.Key getSecretKey(Context context) throws Exception { return keyStore.getKey(XEALTH_KEY_ALIAS, null); } Data encryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; Data decryption: Cipher c = Cipher.getInstance(AES_MODE); c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128, FIXED_IV.getBytes())); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; Initialization vector The initialization vector (IV) is a cryptographic function that is responsible for the randomness of the first encryption block. Remember that the IV used for encryption must be the same as the one used for decryption. By default Android forces you to use a random IV every time, but you can disable this by calling setRandomizedEncryptionRequired () when generating the key. Due to the security provided by Android KeyStore, a random IV is redundant, so a fixed IV can be used instead. If there is a need to use random IVs, you can call the getIV() method when encrypting the data and use the same IV when decrypting it.","title":"Android 6 and higher"},{"location":"rg/en/android/storing_a_public_key_certificate_in_the_directory_resources_of_the_application/#lower-than-android-6","text":"For Android API versions lower than 23 (Android 6), a little more work is required. KeyGenParameterSpec is only available in API 23, so the KeyStore itself cannot generate random AES keys. Instead, you need to generate the keys yourself using the KeyPairGeneratorSpec API . As the name suggests, KeyPairGeneratorSpec generates public and private key pairs. Public key encryption is primarily for signature and authentication and is not suitable for the encryption of large blocks of data, but can be combined with a block cipher such as AES. That is the principle of KEK + DEK (Key Encryption Key + Data Encryption Key). We encrypt the data with a key, which in turn is encrypted with another key stored in the KeyStore. This approach has its advantages. For example, if you change the encryption key, it is enough to re-encrypt the AES key and not touch user data (not re-encrypt it). The algorithm is roughly as follows: Key generation: Generate a pair of RSA keys. Generate a random AES key. Encrypt the AES key using the RSA public key. Save the encrypted key in Shared Preferences. Data encryption and storage: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Encrypt data using the AES key. Data receiving and decryption: Get the encrypted AES key from Shared Preferences. Decrypt the key using the RSA private key. Decrypt data using the AES key. RSA key generation private static final String AndroidKeyStore = \"AndroidKeyStore\"; keyStore = KeyStore.getInstance(AndroidKeyStore); keyStore.load(null); // Generate the RSA key pairs if (!keyStore.containsAlias(KEY_ALIAS)) { // Generate a key pair for encryption Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 30); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(KEY_ALIAS) .setSubject(new X500Principal(\"CN=\" + KEY_ALIAS)) .setSerialNumber(BigInteger.TEN) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, AndroidKeyStore); kpg.initialize(spec); kpg.generateKeyPair(); } RSA encryption and decryption procedures: private static final String RSA_MODE = \"RSA/ECB/PKCS1Padding\"; private byte[] rsaEncrypt(byte[] secret) throws Exception{ KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS, null); // Encrypt the text Cipher inputCipher = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); inputCipher.init(Cipher.ENCRYPT_MODE, privateKeyEntry.getCertificate().getPublicKey()); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, inputCipher); cipherOutputStream.write(secret); cipherOutputStream.close(); byte[] vals = outputStream.toByteArray(); return vals; } private byte[] rsaDecrypt(byte[] encrypted) throws Exception { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(KEY_ALIAS, null); Cipher output = Cipher.getInstance(RSA_MODE, \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey()); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(encrypted), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } return bytes; } AES key generation and storage: SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); if (enryptedKeyB64 == null) { byte[] key = new byte[16]; SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(key); byte[] encryptedKey = rsaEncrypt(key); enryptedKeyB64 = Base64.encodeToString(encryptedKey, Base64.DEFAULT); SharedPreferences.Editor edit = pref.edit(); edit.putString(ENCRYPTED_KEY, enryptedKeyB64); edit.commit(); } Data encryption and decryption: private static final String AES_MODE = \"AES/ECB/PKCS7Padding\"; private Key getSecretKey(Context context) throws Exception{ SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE); String enryptedKeyB64 = pref.getString(ENCRYPTED_KEY, null); // need to check null, omitted here byte[] encryptedKey = Base64.decode(enryptedKeyB64, Base64.DEFAULT); byte[] key = rsaDecrypt(encryptedKey); return new SecretKeySpec(key, \"AES\"); } public String encrypt(Context context, byte[] input) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.ENCRYPT_MODE, getSecretKey(context)); byte[] encodedBytes = c.doFinal(input); String encryptedBase64Encoded = Base64.encodeToString(encodedBytes, Base64.DEFAULT); return encryptedBase64Encoded; } public byte[] decrypt(Context context, byte[] encrypted) { Cipher c = Cipher.getInstance(AES_MODE, \"BC\"); c.init(Cipher.DECRYPT_MODE, getSecretKey(context)); byte[] decodedBytes = c.doFinal(encrypted); return decodedBytes; }","title":"Lower than Android 6"},{"location":"rg/en/android/storing_a_public_key_certificate_in_the_directory_resources_of_the_application/#links","text":"https://doridori.github.io/android-security-the-forgetful-keystore/#sthash.cxj8r3G6.dpbs http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html http://developer.android.com/reference/android/security/KeyPairGeneratorSpec.html https://medium.com/@ericfu/securely-storing-secrets-in-an-android-application-501f030ae5a3#:~:text=With%20these%2C%20storing%20secrets%20becomes,the%20encrypted%20data%20in%20Preferences. https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Links"},{"location":"rg/en/android/storing_cookie_values_in_the_standard_webview_database/","text":"Storing Cookie values in the standard WebView database Severity: HIGH Detection method: DAST, SENSITIVE INFO Description If you use WebView with default settings (or improperly configured), all Cookie values handled by WebView will be stored in the application directory in a special Cookie.db database. The values in this database are not encrypted in any way and are openly available. Despite the fact that this file is located in the internal directory of the application, it is not recommended to store session IDs and other sensitive data related to the authentication process in an open form. There are several ways to get this file, from application backup, to exploiting other vulnerabilities allowing to read any files in the application directory. Recommendations To prevent storing Cookie values, you should configure WebView correctly when you create it. In case the values have been saved previously, they must be deleted. It is important to keep in mind that this operation is performed differently on different versions of the Android SDK. Here is an example of code that implements correct Cookie clearing for all Android versions: webView.clearCache(true); webView.clearHistory(); WebSettings webSettings = webView.getSettings(); webSettings.setSaveFormData(false); // Not needed for API level 18 or greater (deprecated) webSettings.setSavePassword(false); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) { CookieManager.getInstance().removeAllCookies(null); CookieManager.getInstance().flush(); } else { CookieSyncManager cookieSyncMngr = CookieSyncManager.createInstance(this); cookieSyncMngr.startSync(); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeAllCookie(); cookieManager.removeSessionCookie(); cookieSyncMngr.stopSync(); cookieSyncMngr.sync(); } Links https://developer.android.com/reference/android/webkit/CookieManager#removeAllCookies(android.webkit.ValueCallback\\ ) https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Storing Cookie values in the standard WebView database"},{"location":"rg/en/android/storing_cookie_values_in_the_standard_webview_database/#storing-cookie-values-in-the-standard-webview-database","text":"Severity: HIGH Detection method: DAST, SENSITIVE INFO","title":"Storing Cookie values in the standard WebView database"},{"location":"rg/en/android/storing_cookie_values_in_the_standard_webview_database/#description","text":"If you use WebView with default settings (or improperly configured), all Cookie values handled by WebView will be stored in the application directory in a special Cookie.db database. The values in this database are not encrypted in any way and are openly available. Despite the fact that this file is located in the internal directory of the application, it is not recommended to store session IDs and other sensitive data related to the authentication process in an open form. There are several ways to get this file, from application backup, to exploiting other vulnerabilities allowing to read any files in the application directory.","title":"Description"},{"location":"rg/en/android/storing_cookie_values_in_the_standard_webview_database/#recommendations","text":"To prevent storing Cookie values, you should configure WebView correctly when you create it. In case the values have been saved previously, they must be deleted. It is important to keep in mind that this operation is performed differently on different versions of the Android SDK. Here is an example of code that implements correct Cookie clearing for all Android versions: webView.clearCache(true); webView.clearHistory(); WebSettings webSettings = webView.getSettings(); webSettings.setSaveFormData(false); // Not needed for API level 18 or greater (deprecated) webSettings.setSavePassword(false); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) { CookieManager.getInstance().removeAllCookies(null); CookieManager.getInstance().flush(); } else { CookieSyncManager cookieSyncMngr = CookieSyncManager.createInstance(this); cookieSyncMngr.startSync(); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeAllCookie(); cookieManager.removeSessionCookie(); cookieSyncMngr.stopSync(); cookieSyncMngr.sync(); }","title":"Recommendations"},{"location":"rg/en/android/storing_cookie_values_in_the_standard_webview_database/#links","text":"https://developer.android.com/reference/android/webkit/CookieManager#removeAllCookies(android.webkit.ValueCallback\\ ) https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_inside_the_application_s_directory/","text":"Storing sensitive information in a private file inside the application's directory Severity: INFO Detection method: DAST, FILES Description An application stores sensitive information in a private file inside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you need to clearly define what is considered as confidential data by your application or by your company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files. Recommendations The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } } Links https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Storing sensitive information in a private file inside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_inside_the_application_s_directory/#storing-sensitive-information-in-a-private-file-inside-the-applications-directory","text":"Severity: INFO Detection method: DAST, FILES","title":"Storing sensitive information in a private file inside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_inside_the_application_s_directory/#description","text":"An application stores sensitive information in a private file inside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you need to clearly define what is considered as confidential data by your application or by your company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_inside_the_application_s_directory/#recommendations","text":"The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } }","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_inside_the_application_s_directory/#links","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_outside_the_application_s_directory/","text":"Storing sensitive information in a private file outside the application's directory Severity: INFO Detection method: DAST, FILES Description An application stores sensitive information in a private file inside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you need to clearly define what is considered as confidential data by your application or by your company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files. Recommendations The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } } Links https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Storing sensitive information in a private file outside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_outside_the_application_s_directory/#storing-sensitive-information-in-a-private-file-outside-the-applications-directory","text":"Severity: INFO Detection method: DAST, FILES","title":"Storing sensitive information in a private file outside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_outside_the_application_s_directory/#description","text":"An application stores sensitive information in a private file inside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you need to clearly define what is considered as confidential data by your application or by your company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_outside_the_application_s_directory/#recommendations","text":"The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } }","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_a_private_file_outside_the_application_s_directory/#links","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_a_protected_database/","text":"Storing sensitive information in a protected database Severity: INFO Detection method: DAST, API Description The application stores sensitive information in a protected database. In general this is not a vulnerability, but it is necessary to make sure that a [strong password] is used to encrypt the database. Sensitive data found is used by the system to find its use or [storage in the collected data]. Recommendations To protect against data interception at runtime, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult. Links https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Storing sensitive information in a protected database"},{"location":"rg/en/android/storing_sensitive_information_in_a_protected_database/#storing-sensitive-information-in-a-protected-database","text":"Severity: INFO Detection method: DAST, API","title":"Storing sensitive information in a protected database"},{"location":"rg/en/android/storing_sensitive_information_in_a_protected_database/#description","text":"The application stores sensitive information in a protected database. In general this is not a vulnerability, but it is necessary to make sure that a [strong password] is used to encrypt the database. Sensitive data found is used by the system to find its use or [storage in the collected data].","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_a_protected_database/#recommendations","text":"To protect against data interception at runtime, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult.","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_a_protected_database/#links","text":"https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_inside_the_application_s_directory/","text":"Storing sensitive information in a public file inside the application's directory Severity: CRITICAL Detection method: DAST, FILES Description An application stores sensitive information in a public file inside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you need to clearly define what is considered as confidential data by your application or by your company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files. Recommendations The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } } Links https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Storing sensitive information in a public file inside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_inside_the_application_s_directory/#storing-sensitive-information-in-a-public-file-inside-the-applications-directory","text":"Severity: CRITICAL Detection method: DAST, FILES","title":"Storing sensitive information in a public file inside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_inside_the_application_s_directory/#description","text":"An application stores sensitive information in a public file inside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you need to clearly define what is considered as confidential data by your application or by your company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_inside_the_application_s_directory/#recommendations","text":"The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } }","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_inside_the_application_s_directory/#links","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_outside_the_application_s_directory/","text":"Storing sensitive information in a public file outside the application's directory Severity: CRITICAL Detection method: DAST, FILES Description An application stores sensitive information in a public file outside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files. Recommendations The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } } Links https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Storing sensitive information in a public file outside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_outside_the_application_s_directory/#storing-sensitive-information-in-a-public-file-outside-the-applications-directory","text":"Severity: CRITICAL Detection method: DAST, FILES","title":"Storing sensitive information in a public file outside the application's directory"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_outside_the_application_s_directory/#description","text":"An application stores sensitive information in a public file outside the application's directory. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force a user to enter a complex password every time an application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. An application can store data in several places, for example, on a device or on an external SD-card. The most common ways to store data on a device are: Shared Preferences. SQLite databases. Realm databases. Internal memory. External storage. Keep in mind that using any of these methods does not guarantee security of the stored data. If you do not use encryption or hashing beforehand, this data may be available to an attacker. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Placing information on an external storage or in shared directories makes it accessible to everyone. And you should definitely not store sensitive information in such files.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_outside_the_application_s_directory/#recommendations","text":"The way confidential information is stored depends on its type. If there is a need to store encryption keys, the best choice would be the system storage, AndroidKeyStore. Unfortunately, this is not always possible, so you have to choose a method that provides the maximum possible protection taking into account the Android version: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Android has many cryptographic functions that help ensure confidentiality and integrity of data. There are methods that enable Android applications to securely encrypt and decrypt data (maintaining confidentiality), to authenticate messages (MAC) and digital signatures (ensuring integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Password-based encryption/decryption Let's take a closer look at encryption/decryption method based on a user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mIV = null; private byte[] mSalt = null; public byte[] getIV() { return mIV; } public byte[] getSalt() { return mSalt; } AesCryptoPBEKey(final byte[] iv, final byte[] salt) { mIV = iv; mSalt = salt; } AesCryptoPBEKey() { mIV = null; initSalt(); } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } public final byte[] encrypt(final byte[] plain, final char[] password) { byte[] encrypted = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); cipher.init(Cipher.ENCRYPT_MODE, secretKey); mIV = cipher.getIV(); encrypted = cipher.doFinal(plain); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return encrypted; } public final byte[] decrypt(final byte[] encrypted, final char[] password) { byte[] plain = null; try { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 Cipher cipher = Cipher.getInstance(TRANSFORMATION); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) SecretKey secretKey = generateKey(password, mSalt); IvParameterSpec ivParameterSpec = new IvParameterSpec(mIV); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); plain = cipher.doFinal(encrypted); } catch (NoSuchAlgorithmException e) { } catch (NoSuchPaddingException e) { } catch (InvalidKeyException e) { } catch (InvalidAlgorithmParameterException e) { } catch (IllegalBlockSizeException e) { } catch (BadPaddingException e) { } finally { } return plain; } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } }","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_file_outside_the_application_s_directory/#links","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312.html","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_protected_database/","text":"Storing sensitive information in a public protected database Severity: LOW Detection method: DAST, API Description The application stores sensitive information in a publicly accessible protected database. In general this is not a vulnerability, but it is necessary to make sure that a [strong password is used] to encrypt the database. Sensitive data found is used by the system to find its use or [storage in the collected data]. Recommendations To protect against data interception at runtime, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult. Links https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Storing sensitive information in a public protected database"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_protected_database/#storing-sensitive-information-in-a-public-protected-database","text":"Severity: LOW Detection method: DAST, API","title":"Storing sensitive information in a public protected database"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_protected_database/#description","text":"The application stores sensitive information in a publicly accessible protected database. In general this is not a vulnerability, but it is necessary to make sure that a [strong password is used] to encrypt the database. Sensitive data found is used by the system to find its use or [storage in the collected data].","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_protected_database/#recommendations","text":"To protect against data interception at runtime, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult.","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_protected_database/#links","text":"https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-stg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_unprotected_database/","text":"Storing sensitive information in a public unprotected database Severity: CRITICAL Detection method: DAST, API Description The application stores sensitive information in a publicly accessible, unsecured database, which can lead to data compromise. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. Recommendations If you need to store sensitive information in a database, you must additionally encrypt the database or the data stored in it. As an example for database encryption, you can use the sqlcipher . An example of using SQLCipher (Java) package com.demo.sqlcipher; import java.io.File; import net.sqlcipher.database.SQLiteDatabase; import android.app.Activity; import android.os.Bundle; public class HelloSQLCipherActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); InitializeSQLCipher(); } private void InitializeSQLCipher() { SQLiteDatabase.loadLibs(this); File databaseFile = getDatabasePath(\"demo.db\"); databaseFile.mkdirs(); databaseFile.delete(); SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null); database.execSQL(\"create table t1(a, b)\"); database.execSQL(\"insert into t1(a, b) values(?, ?)\", new Object[]{\"one for the money\", \"two for the show\"}); } } An example of using SQLCipher (Kotlin) package com.demo.sqlcipher import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import net.sqlcipher.database.SQLiteDatabase class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) SQLiteDatabase.loadLibs(this) val databaseFile = getDatabasePath(\"demo.db\") if(databaseFile.exists()) databaseFile.delete() databaseFile.mkdirs() databaseFile.delete() val database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null) database.execSQL(\"create table t1(a, b)\") database.execSQL(\"insert into t1(a, b) values(?, ?)\", arrayOf(\"one for the money\", \"two for the show\") ) } } This example uses the hardcoded \"test123\" password for the database. In a real application, you should not use such an insecure password and store it in the source code or in an open form. One way of not storing the password is to generate it \"on the fly\" using the user's password based on the key strengthening procedure. Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import android.os.Build import javax.crypto.SecretKeyFactory import javax.crypto.spec.PBEKeySpec @Deprecated(\"Use Argon2 instead\") internal object Pbkdf2Factory { private const val DEFAULT_ITERATIONS = 10_000 private val systemAlgorithm by lazy { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { \"PBKDF2withHmacSHA1\" } else { \"PBKDF2withHmacSHA256\" } } fun createKey( passphraseOrPin: CharArray, salt: ByteArray, algorithm: String = systemAlgorithm, iterations: Int = DEFAULT_ITERATIONS ): Pbkdf2Key { @Suppress(\"MagicNumber\") val keySpec = PBEKeySpec(passphraseOrPin, salt, iterations, 256) val secretKey = SecretKeyFactory.getInstance(algorithm).generateSecret(keySpec) return Pbkdf2Key( secretKey.algorithm, iterations, salt, secretKey.encoded ) } } In the future, the resulting key value can be used as a password to encrypt the database and there is no need to store it. Each time you enter a password, the key will be generated on the fly and sent to the database open function. !!! note \"Note!\" With this approach, if the secret (user password) is changed, the data must be re-encrypted with a new secret if it is to be stored. Also, if the user's password is a pin code, it is better to use the KEK (Key Encryption Key) + DEK (Data Encryption Key) approach. This involves creating a key for encrypting the data and also encrypting this key with the user's password. With this approach, if you change the secret, you only need to re-encrypt the key; the encrypted user data remains untouched. When you link the SQLCipher library, do not forget to add rules to Proguard to make the application work correctly. The rules for ProGuard: -keep,includedescriptorclasses class net.sqlcipher.** { *; } -keep,includedescriptorclasses interface net.sqlcipher.** { *; } Links https://github.com/sqlcipher/android-database-sqlcipher https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted https://cwe.mitre.org/data/definitions/521.html https://www.techopedia.com/definition/5660/data-encryption-key-dek","title":"Storing sensitive information in a public unprotected database"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_unprotected_database/#storing-sensitive-information-in-a-public-unprotected-database","text":"Severity: CRITICAL Detection method: DAST, API","title":"Storing sensitive information in a public unprotected database"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_unprotected_database/#description","text":"The application stores sensitive information in a publicly accessible, unsecured database, which can lead to data compromise. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect the speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_unprotected_database/#recommendations","text":"If you need to store sensitive information in a database, you must additionally encrypt the database or the data stored in it. As an example for database encryption, you can use the sqlcipher . An example of using SQLCipher (Java) package com.demo.sqlcipher; import java.io.File; import net.sqlcipher.database.SQLiteDatabase; import android.app.Activity; import android.os.Bundle; public class HelloSQLCipherActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); InitializeSQLCipher(); } private void InitializeSQLCipher() { SQLiteDatabase.loadLibs(this); File databaseFile = getDatabasePath(\"demo.db\"); databaseFile.mkdirs(); databaseFile.delete(); SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null); database.execSQL(\"create table t1(a, b)\"); database.execSQL(\"insert into t1(a, b) values(?, ?)\", new Object[]{\"one for the money\", \"two for the show\"}); } } An example of using SQLCipher (Kotlin) package com.demo.sqlcipher import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import net.sqlcipher.database.SQLiteDatabase class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) SQLiteDatabase.loadLibs(this) val databaseFile = getDatabasePath(\"demo.db\") if(databaseFile.exists()) databaseFile.delete() databaseFile.mkdirs() databaseFile.delete() val database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null) database.execSQL(\"create table t1(a, b)\") database.execSQL(\"insert into t1(a, b) values(?, ?)\", arrayOf(\"one for the money\", \"two for the show\") ) } } This example uses the hardcoded \"test123\" password for the database. In a real application, you should not use such an insecure password and store it in the source code or in an open form. One way of not storing the password is to generate it \"on the fly\" using the user's password based on the key strengthening procedure. Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import android.os.Build import javax.crypto.SecretKeyFactory import javax.crypto.spec.PBEKeySpec @Deprecated(\"Use Argon2 instead\") internal object Pbkdf2Factory { private const val DEFAULT_ITERATIONS = 10_000 private val systemAlgorithm by lazy { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { \"PBKDF2withHmacSHA1\" } else { \"PBKDF2withHmacSHA256\" } } fun createKey( passphraseOrPin: CharArray, salt: ByteArray, algorithm: String = systemAlgorithm, iterations: Int = DEFAULT_ITERATIONS ): Pbkdf2Key { @Suppress(\"MagicNumber\") val keySpec = PBEKeySpec(passphraseOrPin, salt, iterations, 256) val secretKey = SecretKeyFactory.getInstance(algorithm).generateSecret(keySpec) return Pbkdf2Key( secretKey.algorithm, iterations, salt, secretKey.encoded ) } } In the future, the resulting key value can be used as a password to encrypt the database and there is no need to store it. Each time you enter a password, the key will be generated on the fly and sent to the database open function. !!! note \"Note!\" With this approach, if the secret (user password) is changed, the data must be re-encrypted with a new secret if it is to be stored. Also, if the user's password is a pin code, it is better to use the KEK (Key Encryption Key) + DEK (Data Encryption Key) approach. This involves creating a key for encrypting the data and also encrypting this key with the user's password. With this approach, if you change the secret, you only need to re-encrypt the key; the encrypted user data remains untouched. When you link the SQLCipher library, do not forget to add rules to Proguard to make the application work correctly. The rules for ProGuard: -keep,includedescriptorclasses class net.sqlcipher.** { *; } -keep,includedescriptorclasses interface net.sqlcipher.** { *; }","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_a_public_unprotected_database/#links","text":"https://github.com/sqlcipher/android-database-sqlcipher https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted https://cwe.mitre.org/data/definitions/521.html https://www.techopedia.com/definition/5660/data-encryption-key-dek","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_an_insecure_database/","text":"Storing sensitive information in an unprotected database Severity: LOW Detection method: DAST, DATA BASES Description The application stores sensitive information in an unprotected database, which can lead to data compromise. Although the file is stored inside the application directory, you should not store sensitive information in it. This information can be obtained in many ways, from local or cloud-based backups, to various file reading vulnerabilities and injections into the Content Provider. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. Recommendations If you need to store sensitive information in a database, you must additionally encrypt the database or the data stored in it. As an example for database encryption, you can use the sqlcipher . An example of using SQLCipher (Java): package com.demo.sqlcipher; import java.io.File; import net.sqlcipher.database.SQLiteDatabase; import android.app.Activity; import android.os.Bundle; public class HelloSQLCipherActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); InitializeSQLCipher(); } private void InitializeSQLCipher() { SQLiteDatabase.loadLibs(this); File databaseFile = getDatabasePath(\"demo.db\"); databaseFile.mkdirs(); databaseFile.delete(); SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null); database.execSQL(\"create table t1(a, b)\"); database.execSQL(\"insert into t1(a, b) values(?, ?)\", new Object[]{\"one for the money\", \"two for the show\"}); } } An example of using SQLCipher (Kotlin): package com.demo.sqlcipher import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import net.sqlcipher.database.SQLiteDatabase class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) SQLiteDatabase.loadLibs(this) val databaseFile = getDatabasePath(\"demo.db\") if(databaseFile.exists()) databaseFile.delete() databaseFile.mkdirs() databaseFile.delete() val database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null) database.execSQL(\"create table t1(a, b)\") database.execSQL(\"insert into t1(a, b) values(?, ?)\", arrayOf<Any>(\"one for the money\", \"two for the show\") ) } } This example uses the hardcoded \"test123\" password for the database. In a real application, you should not use such an insecure password and store it in the source code or in an open form. One way of not storing the password is to generate it \"on the fly\" using the user's password based on the key strengthening procedure. Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. import android.os.Build package com.appsec.android.cryptsymmetricpasswordbasedkey; import javax.crypto.SecretKeyFactory import javax.crypto.spec.PBEKeySpec @Deprecated(\"Use Argon2 instead\") internal object Pbkdf2Factory { private const val DEFAULT_ITERATIONS = 10_000 private val systemAlgorithm by lazy { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { \"PBKDF2withHmacSHA1\" } else { \"PBKDF2withHmacSHA256\" } } fun createKey( passphraseOrPin: CharArray, salt: ByteArray, algorithm: String = systemAlgorithm, iterations: Int = DEFAULT_ITERATIONS ): Pbkdf2Key { @Suppress(\"MagicNumber\") val keySpec = PBEKeySpec(passphraseOrPin, salt, iterations, 256) val secretKey = SecretKeyFactory.getInstance(algorithm).generateSecret(keySpec) return Pbkdf2Key( secretKey.algorithm, iterations, salt, secretKey.encoded ) } } In the future, the resulting key value can be used as a password to encrypt the database and there is no need to store it. Each time you enter a password, the key will be generated on the fly and sent to the database open function. !!! note \"Note!\" With this approach, if the secret (user password) is changed, the data must be re-encrypted with a new secret if it is to be stored. Also, if the user's password is a pin code, it is better to use the KEK (Key Encryption Key) + DEK (Data Encryption Key) approach. This involves creating a key for encrypting the data and also encrypting this key with the user's password. With this approach, if you change the secret, you only need to re-encrypt the key; the encrypted user data remains untouched. !!! note \"Note\" When you link the SQLCipher library, do not forget to add rules to Proguard to make the application work correctly. The rules for ProGuard: -keep,includedescriptorclasses class net.sqlcipher.** { *; } -keep,includedescriptorclasses interface net.sqlcipher.** { *; } Links GitHub - sqlcipher/android-database-sqlcipher: Android SQLite API based on SQLCipher owasp-mstg/0x05d-Testing-Data-Storage.md at master \u00b7 OWASP/owasp-mstg CWE - CWE-521: Weak Password Requirements (4.6) What is a Data Encryption Key (DEK) Definition from Techopedia","title":"Storing sensitive information in an unprotected database"},{"location":"rg/en/android/storing_sensitive_information_in_an_insecure_database/#storing-sensitive-information-in-an-unprotected-database","text":"Severity: LOW Detection method: DAST, DATA BASES","title":"Storing sensitive information in an unprotected database"},{"location":"rg/en/android/storing_sensitive_information_in_an_insecure_database/#description","text":"The application stores sensitive information in an unprotected database, which can lead to data compromise. Although the file is stored inside the application directory, you should not store sensitive information in it. This information can be obtained in many ways, from local or cloud-based backups, to various file reading vulnerabilities and injections into the Content Provider. In order to understand what kind of data needs to be protected, you first need to determine what data the application processes and stores and what part of that information is considered sensitive. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_an_insecure_database/#recommendations","text":"If you need to store sensitive information in a database, you must additionally encrypt the database or the data stored in it. As an example for database encryption, you can use the sqlcipher . An example of using SQLCipher (Java): package com.demo.sqlcipher; import java.io.File; import net.sqlcipher.database.SQLiteDatabase; import android.app.Activity; import android.os.Bundle; public class HelloSQLCipherActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); InitializeSQLCipher(); } private void InitializeSQLCipher() { SQLiteDatabase.loadLibs(this); File databaseFile = getDatabasePath(\"demo.db\"); databaseFile.mkdirs(); databaseFile.delete(); SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null); database.execSQL(\"create table t1(a, b)\"); database.execSQL(\"insert into t1(a, b) values(?, ?)\", new Object[]{\"one for the money\", \"two for the show\"}); } } An example of using SQLCipher (Kotlin): package com.demo.sqlcipher import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import net.sqlcipher.database.SQLiteDatabase class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) SQLiteDatabase.loadLibs(this) val databaseFile = getDatabasePath(\"demo.db\") if(databaseFile.exists()) databaseFile.delete() databaseFile.mkdirs() databaseFile.delete() val database = SQLiteDatabase.openOrCreateDatabase(databaseFile, \"test123\", null) database.execSQL(\"create table t1(a, b)\") database.execSQL(\"insert into t1(a, b) values(?, ?)\", arrayOf<Any>(\"one for the money\", \"two for the show\") ) } } This example uses the hardcoded \"test123\" password for the database. In a real application, you should not use such an insecure password and store it in the source code or in an open form. One way of not storing the password is to generate it \"on the fly\" using the user's password based on the key strengthening procedure. Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. import android.os.Build package com.appsec.android.cryptsymmetricpasswordbasedkey; import javax.crypto.SecretKeyFactory import javax.crypto.spec.PBEKeySpec @Deprecated(\"Use Argon2 instead\") internal object Pbkdf2Factory { private const val DEFAULT_ITERATIONS = 10_000 private val systemAlgorithm by lazy { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { \"PBKDF2withHmacSHA1\" } else { \"PBKDF2withHmacSHA256\" } } fun createKey( passphraseOrPin: CharArray, salt: ByteArray, algorithm: String = systemAlgorithm, iterations: Int = DEFAULT_ITERATIONS ): Pbkdf2Key { @Suppress(\"MagicNumber\") val keySpec = PBEKeySpec(passphraseOrPin, salt, iterations, 256) val secretKey = SecretKeyFactory.getInstance(algorithm).generateSecret(keySpec) return Pbkdf2Key( secretKey.algorithm, iterations, salt, secretKey.encoded ) } } In the future, the resulting key value can be used as a password to encrypt the database and there is no need to store it. Each time you enter a password, the key will be generated on the fly and sent to the database open function. !!! note \"Note!\" With this approach, if the secret (user password) is changed, the data must be re-encrypted with a new secret if it is to be stored. Also, if the user's password is a pin code, it is better to use the KEK (Key Encryption Key) + DEK (Data Encryption Key) approach. This involves creating a key for encrypting the data and also encrypting this key with the user's password. With this approach, if you change the secret, you only need to re-encrypt the key; the encrypted user data remains untouched. !!! note \"Note\" When you link the SQLCipher library, do not forget to add rules to Proguard to make the application work correctly. The rules for ProGuard: -keep,includedescriptorclasses class net.sqlcipher.** { *; } -keep,includedescriptorclasses interface net.sqlcipher.** { *; }","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_an_insecure_database/#links","text":"GitHub - sqlcipher/android-database-sqlcipher: Android SQLite API based on SQLCipher owasp-mstg/0x05d-Testing-Data-Storage.md at master \u00b7 OWASP/owasp-mstg CWE - CWE-521: Weak Password Requirements (4.6) What is a Data Encryption Key (DEK) Definition from Techopedia","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_memory/","text":"Storing sensitive information in memory Severity: MEDIUM Detection method: DAST, HEAPDUMP Description Memory analysis can help developers identify the root causes of a number of problems that occur while an application is running on a device. However, it can also be used to access sensitive data. When an application runs on a device, user data or application-specific data can be stored in RAM and not cleared properly after a user exits the system or the application. Since Android stores applications in memory (even after exit) until it is restored, various sensitive information can remain in memory indefinitely. An attacker who discovers or steals the device can plug in a debugger and dump the application's memory. Recommendations Do not store sensitive data (such as encryption keys) in RAM longer than necessary. Clear all variables that contain sensitive information after it has been used. Avoid using constant objects (such as Android java.lang.String ) for cryptographic keys or passwords. Store confidential information in primitive data arrays, such as byte arrays ( byte [] ) and char arrays ( char [] ). This helps to correctly clear confidential information from memory. There are several methods of clearing information in memory, one of them is to overwrite the contents with zeros. Example: Java byte[] secret = null; try{ //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { Arrays.fill(secret, (byte) 0); } } Example: Kotlin val secret: ByteArray? = null try { //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { Arrays.fill(secret, 0.toByte()) } } Unfortunately, this does not guarantee that the content will be overwritten at runtime. To optimize the bytecode, compiler will analyze and decide not to overwrite the data because it will not be used later. From the compiler's point of view, this is an unnecessary operation. This problem doesn't have an ideal solution. For example, you can perform additional calculations (such as XOR for data in a dummy buffer), but you won't know if the compiler decided to remove those operations. On the other hand, using data outside the compiler (for example, serializing the data in a temporary file) guarantees that the data will be overwritten, but, obviously, this affects performance. Moreover, using Arrays.fill to overwrite data might be a bad idea because this method could be intercepted, which is often done by various instruments for analysis. Another problem in the example given above is that the contents are overwritten with zeros only. Ideally, you should overwrite objects with sensitive information with random data or contents of other variables. Example: Java byte[] nonSecret = somePublicString.getBytes(\"ISO-8859-1\"); byte[] secret = null; try{ //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { for (int i = 0; i < secret.length; i++) { secret[i] = nonSecret[i % nonSecret.length]; } FileOutputStream out = new FileOutputStream(\"/dev/null\"); out.write(secret); out.flush(); out.close(); } } Example: Kotlin val nonSecret: ByteArray = somePublicString.getBytes(\"ISO-8859-1\") val secret: ByteArray? = null try { //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { for (i in secret.indices) { secret[i] = nonSecret[i % nonSecret.size] } val out = FileOutputStream(\"/dev/null\") out.write(secret) out.flush() out.close() } } Links https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/316.html https://www.pentestpartners.com/security-blog/how-to-extract-sensitive-plaintext-data-from-android-memory/ https://securitygrind.com/dumping-and-analyzing-android-application-memory/ https://developer.android.com/studio/profile/memory-profiler","title":"Storing sensitive information in memory"},{"location":"rg/en/android/storing_sensitive_information_in_memory/#storing-sensitive-information-in-memory","text":"Severity: MEDIUM Detection method: DAST, HEAPDUMP","title":"Storing sensitive information in memory"},{"location":"rg/en/android/storing_sensitive_information_in_memory/#description","text":"Memory analysis can help developers identify the root causes of a number of problems that occur while an application is running on a device. However, it can also be used to access sensitive data. When an application runs on a device, user data or application-specific data can be stored in RAM and not cleared properly after a user exits the system or the application. Since Android stores applications in memory (even after exit) until it is restored, various sensitive information can remain in memory indefinitely. An attacker who discovers or steals the device can plug in a debugger and dump the application's memory.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_memory/#recommendations","text":"Do not store sensitive data (such as encryption keys) in RAM longer than necessary. Clear all variables that contain sensitive information after it has been used. Avoid using constant objects (such as Android java.lang.String ) for cryptographic keys or passwords. Store confidential information in primitive data arrays, such as byte arrays ( byte [] ) and char arrays ( char [] ). This helps to correctly clear confidential information from memory. There are several methods of clearing information in memory, one of them is to overwrite the contents with zeros. Example: Java byte[] secret = null; try{ //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { Arrays.fill(secret, (byte) 0); } } Example: Kotlin val secret: ByteArray? = null try { //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { Arrays.fill(secret, 0.toByte()) } } Unfortunately, this does not guarantee that the content will be overwritten at runtime. To optimize the bytecode, compiler will analyze and decide not to overwrite the data because it will not be used later. From the compiler's point of view, this is an unnecessary operation. This problem doesn't have an ideal solution. For example, you can perform additional calculations (such as XOR for data in a dummy buffer), but you won't know if the compiler decided to remove those operations. On the other hand, using data outside the compiler (for example, serializing the data in a temporary file) guarantees that the data will be overwritten, but, obviously, this affects performance. Moreover, using Arrays.fill to overwrite data might be a bad idea because this method could be intercepted, which is often done by various instruments for analysis. Another problem in the example given above is that the contents are overwritten with zeros only. Ideally, you should overwrite objects with sensitive information with random data or contents of other variables. Example: Java byte[] nonSecret = somePublicString.getBytes(\"ISO-8859-1\"); byte[] secret = null; try{ //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { for (int i = 0; i < secret.length; i++) { secret[i] = nonSecret[i % nonSecret.length]; } FileOutputStream out = new FileOutputStream(\"/dev/null\"); out.write(secret); out.flush(); out.close(); } } Example: Kotlin val nonSecret: ByteArray = somePublicString.getBytes(\"ISO-8859-1\") val secret: ByteArray? = null try { //get or generate the secret, do work with it, make sure you make no local copies } finally { if (null != secret) { for (i in secret.indices) { secret[i] = nonSecret[i % nonSecret.size] } val out = FileOutputStream(\"/dev/null\") out.write(secret) out.flush() out.close() } }","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_memory/#links","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/316.html https://www.pentestpartners.com/security-blog/how-to-extract-sensitive-plaintext-data-from-android-memory/ https://securitygrind.com/dumping-and-analyzing-android-application-memory/ https://developer.android.com/studio/profile/memory-profiler","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_the_application_source_code/","text":"Storing sensitive information in the application source code Severity: CRITICAL Detection method: DATA, FILES Description The application stores sensitive information in its source code. It is often wrongly assumed that the data that is embedded in the source code of applications is protected and inaccessible after compilation and obfuscation. However, in a decompiled application, all string resources remain unchanged. Any sensitive information located in the source code of the application will be available to malefactors. It is not recommended to store in the source code any information that could help an attacker. This applies to any tokens, passwords, encryption keys, and data used for testing - test bench addresses, test credentials, etc. Such information reveals the inside structure of test benches and can be used in the future. Recommendations If you need to store confidential information, the source code is not the best place to do it. It is recommended to get such information from the server and store it encrypted on the device, if necessary. Android is equipped with many cryptographic features and methods to ensure data privacy. With these, Android applications can securely perform encryption and decryption (to ensure privacy) as well as message authentication (MAC) and digital signatures (to verify integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Encryption/decryption using the Pinkman library Let's consider the example of storing a user's PIN using the Pinkman library. This library demonstrates an example of using the key expansion procedure and the KeyStore mechanism to generate and store an encryption key. The library gets the hash from the user's PIN using the Argon2 hash function and stores it in an encrypted file. The file is encrypted with the AES-256 algorithm in GCM mode, and the keys are stored in AndroidKeystore. This library does not invent its own cryptography, but uses proven algorithms. Description of the technologies used and their parameters. Getting a hash from a PIN The Argon2 function with the following parameters is used to obtain the hash: Mode: Argon2i. Time spent on iterations: 5. Memory cost in kilobytes: 65,536. Parallelism: 2. The resulting hash length: 128 bit. Encrypted files This library uses the Jetpack security library from the Android Jetpack library set for secure data storage. This library in turn uses another library, Tink. Usage example Add the library to the Gradle configuration: implementation 'com.redmadrobot:pinkman:$pinkman_version' Create an instance of the Pinkman class and integrate it into your authentication logic. val pinkman = Pinkman(application.applicationContext) ... class CreatePinViewModel(private val pinkman: Pinkman) : ViewModel() { val pinIsCreated = MutableLiveData() fun createPin(pin: String) { pinkman.createPin(pin) pinIsCreated.postValue(true) } } ... class InputPinViewModel(private val pinkman: Pinkman) : ViewModel() { val pinIsValid = MutableLiveData() fun validatePin(pin: String) { pinIsValid.value = pinkman.isValidPin(pin) } } On some devices, the hash obtaining operations can take considerable time. To avoid ANR in your application, you should not run the createPin() , changePin() , isValidPin() methods in the main thread. This library already has two extensions to run these methods asynchronously. You can choose one of them depending on your specific needs (or technical stack). You need to add this dependency if you prefer RxJava: implementation 'com.redmadrobot:pinkman-rx3:$pinkman_version' But if you are using the latest technology, you should use a dependency with Kotlin Coroutines : implementation 'com.redmadrobot:pinkman-coroutines:$pinkman_version' The result is a set of methods specific to RxJava or Coroutines: // RxJava3 fun createPinAsync(...): Completable fun changePinAsync(...): Completable fun isValidPinAsync(...): Single // Coroutines suspend fun createPinAsync(...) suspend fun changePinAsync(...) suspend fun isValidPinAsync(...): Boolean If, for whatever reason, the storage of such information cannot be removed from the source code of the application, you can use paid tools that allow you to encrypt string resources when compiling the application. Examples of such software are DexProtector and DexGuard . Links https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312 https://www.guardsquare.com/en/products/dexguard https://dexprotector.com/ https://github.com/RedMadRobot/PINkman","title":"Storing sensitive information in the application source code"},{"location":"rg/en/android/storing_sensitive_information_in_the_application_source_code/#storing-sensitive-information-in-the-application-source-code","text":"Severity: CRITICAL Detection method: DATA, FILES","title":"Storing sensitive information in the application source code"},{"location":"rg/en/android/storing_sensitive_information_in_the_application_source_code/#description","text":"The application stores sensitive information in its source code. It is often wrongly assumed that the data that is embedded in the source code of applications is protected and inaccessible after compilation and obfuscation. However, in a decompiled application, all string resources remain unchanged. Any sensitive information located in the source code of the application will be available to malefactors. It is not recommended to store in the source code any information that could help an attacker. This applies to any tokens, passwords, encryption keys, and data used for testing - test bench addresses, test credentials, etc. Such information reveals the inside structure of test benches and can be used in the future.","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_the_application_source_code/#recommendations","text":"If you need to store confidential information, the source code is not the best place to do it. It is recommended to get such information from the server and store it encrypted on the device, if necessary. Android is equipped with many cryptographic features and methods to ensure data privacy. With these, Android applications can securely perform encryption and decryption (to ensure privacy) as well as message authentication (MAC) and digital signatures (to verify integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following schemes: Encryption/decryption using the Pinkman library Let's consider the example of storing a user's PIN using the Pinkman library. This library demonstrates an example of using the key expansion procedure and the KeyStore mechanism to generate and store an encryption key. The library gets the hash from the user's PIN using the Argon2 hash function and stores it in an encrypted file. The file is encrypted with the AES-256 algorithm in GCM mode, and the keys are stored in AndroidKeystore. This library does not invent its own cryptography, but uses proven algorithms. Description of the technologies used and their parameters. Getting a hash from a PIN The Argon2 function with the following parameters is used to obtain the hash: Mode: Argon2i. Time spent on iterations: 5. Memory cost in kilobytes: 65,536. Parallelism: 2. The resulting hash length: 128 bit. Encrypted files This library uses the Jetpack security library from the Android Jetpack library set for secure data storage. This library in turn uses another library, Tink. Usage example Add the library to the Gradle configuration: implementation 'com.redmadrobot:pinkman:$pinkman_version' Create an instance of the Pinkman class and integrate it into your authentication logic. val pinkman = Pinkman(application.applicationContext) ... class CreatePinViewModel(private val pinkman: Pinkman) : ViewModel() { val pinIsCreated = MutableLiveData() fun createPin(pin: String) { pinkman.createPin(pin) pinIsCreated.postValue(true) } } ... class InputPinViewModel(private val pinkman: Pinkman) : ViewModel() { val pinIsValid = MutableLiveData() fun validatePin(pin: String) { pinIsValid.value = pinkman.isValidPin(pin) } } On some devices, the hash obtaining operations can take considerable time. To avoid ANR in your application, you should not run the createPin() , changePin() , isValidPin() methods in the main thread. This library already has two extensions to run these methods asynchronously. You can choose one of them depending on your specific needs (or technical stack). You need to add this dependency if you prefer RxJava: implementation 'com.redmadrobot:pinkman-rx3:$pinkman_version' But if you are using the latest technology, you should use a dependency with Kotlin Coroutines : implementation 'com.redmadrobot:pinkman-coroutines:$pinkman_version' The result is a set of methods specific to RxJava or Coroutines: // RxJava3 fun createPinAsync(...): Completable fun changePinAsync(...): Completable fun isValidPinAsync(...): Single // Coroutines suspend fun createPinAsync(...) suspend fun changePinAsync(...) suspend fun isValidPinAsync(...): Boolean If, for whatever reason, the storage of such information cannot be removed from the source code of the application, you can use paid tools that allow you to encrypt string resources when compiling the application. Examples of such software are DexProtector and DexGuard .","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_the_application_source_code/#links","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage https://cwe.mitre.org/data/definitions/200.html https://cwe.mitre.org/data/definitions/311.html https://cwe.mitre.org/data/definitions/312 https://www.guardsquare.com/en/products/dexguard https://dexprotector.com/ https://github.com/RedMadRobot/PINkman","title":"Links"},{"location":"rg/en/android/storing_sensitive_information_in_the_keyboard_cache/","text":"Storing sensitive information in the keyboard cache Severity: MEDIUM Detection method: DAST, SENSITIVE INFO Description Android has a mechanism to auto-complete words that the user enters in the text fields. In this case, if Android does not know the word the user enters, it can cache the word (or prompt the user to add the word to the dictionary). This feature can be very useful for messenger applications, for example. However, the keyboard cache may disclose sensitive information if it is used to enter such information (credit card data, login, password or personal user information). The android:inputType=\"textNoSuggestions\" parameter in the description of the ( <EditText/> ) is responsible for enabling or disabling the auto-complete option. An example of vulnerable code: <EditText android:id=\"@+id/KeyBoardCache\"/> Recommendations All input fields that request confidential information must have the following XML attribute enabled (to disable auto-completes): <EditText android:id=\"@+id/KeyBoardCache\" android:inputType=\"textNoSuggestions\"/> Links https://developer.android.com/reference/android/text/InputType.html#TYPE_TEXT_FLAG_NO_SUGGESTIONS https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5 https://cwe.mitre.org/data/definitions/200.html","title":"Storing sensitive information in the keyboard cache"},{"location":"rg/en/android/storing_sensitive_information_in_the_keyboard_cache/#storing-sensitive-information-in-the-keyboard-cache","text":"Severity: MEDIUM Detection method: DAST, SENSITIVE INFO","title":"Storing sensitive information in the keyboard cache"},{"location":"rg/en/android/storing_sensitive_information_in_the_keyboard_cache/#description","text":"Android has a mechanism to auto-complete words that the user enters in the text fields. In this case, if Android does not know the word the user enters, it can cache the word (or prompt the user to add the word to the dictionary). This feature can be very useful for messenger applications, for example. However, the keyboard cache may disclose sensitive information if it is used to enter such information (credit card data, login, password or personal user information). The android:inputType=\"textNoSuggestions\" parameter in the description of the ( <EditText/> ) is responsible for enabling or disabling the auto-complete option. An example of vulnerable code: <EditText android:id=\"@+id/KeyBoardCache\"/>","title":"Description"},{"location":"rg/en/android/storing_sensitive_information_in_the_keyboard_cache/#recommendations","text":"All input fields that request confidential information must have the following XML attribute enabled (to disable auto-completes): <EditText android:id=\"@+id/KeyBoardCache\" android:inputType=\"textNoSuggestions\"/>","title":"Recommendations"},{"location":"rg/en/android/storing_sensitive_information_in_the_keyboard_cache/#links","text":"https://developer.android.com/reference/android/text/InputType.html#TYPE_TEXT_FLAG_NO_SUGGESTIONS https://www.owasp.org/index.php/Mobile_Top_10_2016-M2-Insecure_Data_Storage https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5 https://cwe.mitre.org/data/definitions/200.html","title":"Links"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_request/","text":"Sending sensitive information in an HTTP request Severity: CRITICAL Detection method: DAST, NETWORKING Description Using HTTP instead of HTTPS makes it possible to implement the Man-in-the-Middle attack. This can lead to a complete loss of confidentiality of transmitted data. Note, that all data sent via the HTTP protocol are transferred in plain text with absolutely no protection. Anybody, who shares a network with you, can receive or even forge the data having relevant experience. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication. Recommendations Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! note \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly. Example: Correct implementation of SSL-Pinning PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher. Links http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Sending sensitive information in an HTTP request"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_request/#sending-sensitive-information-in-an-http-request","text":"Severity: CRITICAL Detection method: DAST, NETWORKING","title":"Sending sensitive information in an HTTP request"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_request/#description","text":"Using HTTP instead of HTTPS makes it possible to implement the Man-in-the-Middle attack. This can lead to a complete loss of confidentiality of transmitted data. Note, that all data sent via the HTTP protocol are transferred in plain text with absolutely no protection. Anybody, who shares a network with you, can receive or even forge the data having relevant experience. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication.","title":"Description"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_request/#recommendations","text":"Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! note \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly. Example: Correct implementation of SSL-Pinning PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher.","title":"Recommendations"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_request/#links","text":"http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Links"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_response/","text":"Getting sensitive information in an HTTP response Severity: CRITICAL Detection method: DAST, NETWORKING Description Using HTTP instead of HTTPS makes it possible to implement the Man-in-the-Middle attack. This can lead to a complete loss of confidentiality of transmitted data. Note, that all data sent via the HTTP protocol are transferred in plain text with absolutely no protection. Anybody, who shares a network with you, can receive or even forge the data having relevant experience. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication. Recommendations Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! note \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly. Example: Correct implementation of SSL-Pinning PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher. Links http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Getting sensitive information in an HTTP response"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_response/#getting-sensitive-information-in-an-http-response","text":"Severity: CRITICAL Detection method: DAST, NETWORKING","title":"Getting sensitive information in an HTTP response"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_response/#description","text":"Using HTTP instead of HTTPS makes it possible to implement the Man-in-the-Middle attack. This can lead to a complete loss of confidentiality of transmitted data. Note, that all data sent via the HTTP protocol are transferred in plain text with absolutely no protection. Anybody, who shares a network with you, can receive or even forge the data having relevant experience. Using the HTTPS protocol that is based on HTTP plus SSL / TLS, allows to protect the transferred data from an unauthorized access or modification. It is recommended to use HTTPS for all situations involving exchange of valuable information between a client and a server, particularly for login pages and other pages requiring authentication.","title":"Description"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_response/#recommendations","text":"Ideally, not encrypted traffic should never be used in an application. If this is difficult to implement or there is a need to use third-party services via HTTP, pay special attention to verification and validation of the received data and never transmit confidential information over such protocol. If you need to choose a data transmission method, the following chart can be helpful: Comparison of HTTP and HTTPS: Android uses java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection as API for establishing communication channels over HTTP/HTTPS. Apache HttpClient is not supported starting from Android 6.0 (API 23). !!! note \"Note!\" To establish a channel via HTTPS, you shouldn't use SSLSocket. Unlike HttpsURLConnection, this class doesn't check by default if there is a match between the server name and the name of the host declared in the certificate. Moreover, when using SSLSocket, developers often make mistakes that lead to security defects in the communication channel. Using HTTPS with SSL-Pinning An application can be additionally protected from fraudulent certificates with help of a mechanism known as SSL-Pinning. This mechanism prevents a certificate issued by a trusted certificate authority from being compromised in the system storage, which makes security violation of the data transmission channel nearly impossible. Rules: Compare the server certificate with the one stored in the application. The URI scheme must be https://. Sensitive information may be transmitted. You can trust the received data, as they are received from a real server. Handle SSL issues properly. Example: Correct implementation of SSL-Pinning PrivateCertificateHttpsGet.java package com.appsec.android.https.privatecertificate; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.HttpURLConnection; import java.net.URL; import java.security.KeyStore; import java.security.SecureRandom; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManagerFactory; import android.content.Context; import android.os.AsyncTask; public abstract class PrivateCertificateHttpsGet extends AsyncTask { private Context mContext; public PrivateCertificateHttpsGet(Context context) { mContext = context; } @Override protected Object doInBackground(String... params) { TrustManagerFactory trustManager; BufferedInputStream inputStream = null; ByteArrayOutputStream responseArray = null; byte[] buff = new byte[1024]; int length; try { URL url = new URL(params[0]); // *** 1 *** \u0421\u0432\u0435\u0440\u044f\u0439\u0442\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u043c \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 // \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c keystore \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u043b \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u0438\u0437 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f KeyStore ks = KeyStoreUtil.getEmptyKeyStore(); KeyStoreUtil.loadX509Certificate(ks, mContext.getResources().getAssets().open(\"cacert.crt\")); // *** 2 *** \u0421\u0445\u0435\u043c\u0430 URI \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c https:// // *** 3 *** \u0412 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManager.init(ks); SSLContext sslCon = SSLContext.getInstance(\"TLS\"); sslCon.init(null, trustManager.getTrustManagers(), new SecureRandom()); HttpURLConnection con = (HttpURLConnection)url.openConnection(); HttpsURLConnection response = (HttpsURLConnection)con; response.setDefaultSSLSocketFactory(sslCon.getSocketFactory()); response.setSSLSocketFactory(sslCon.getSocketFactory()); checkResponse(response); // *** 4 *** \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0432\u0435\u0440\u044f\u0442\u044c, \u0442.\u043a. \u043e\u043d\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u043e\u0442 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 inputStream = new BufferedInputStream(response.getInputStream()); responseArray = new ByteArrayOutputStream(); while ((length = inputStream.read(buff)) != -1) { if (length > 0) { responseArray.write(buff, 0, length); } } return responseArray.toByteArray(); } catch(SSLException e) { // *** 5 *** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0439\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 SSL \u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 return e; } catch(Exception e) { return e; } finally { if (inputStream != null) { try { inputStream.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } if (responseArray != null) { try { responseArray.close(); } catch (Exception e) { // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440 } } } } private void checkResponse(HttpURLConnection response) throws IOException { int statusCode = response.getResponseCode(); if (HttpURLConnection.HTTP_OK != statusCode) { throw new IOException(\"HttpStatus: \" + statusCode); } } } KeyStoreUtil.java package com.appsec.android.https.privatecertificate; import java.io.IOException; import java.io.InputStream; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Enumeration; public class KeyStoreUtil { public static KeyStore getEmptyKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore ks = KeyStore.getInstance(\"BKS\"); ks.load(null); return ks; } public static void loadAndroidCAStore(KeyStore ks) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { KeyStore aks = KeyStore.getInstance(\"AndroidCAStore\"); aks.load(null); Enumeration aliases = aks.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); Certificate cert = aks.getCertificate(alias); ks.setCertificateEntry(alias, cert); } } public static void loadX509Certificate(KeyStore ks, InputStream is) throws CertificateException, KeyStoreException { try { CertificateFactory factory = CertificateFactory.getInstance(\"X509\"); X509Certificate x509 = (X509Certificate)factory.generateCertificate(is); String alias = x509.getSubjectDN().getName(); ks.setCertificateEntry(alias, x509); } finally { try { is.close(); } catch (IOException e) { /* \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c, \u0442.\u043a. \u044d\u0442\u043e \u043f\u0440\u0438\u043c\u0435\u0440*/ } } } } PrivateCertificateHttpsActivity.java package com.appsec.android.https.privatecertificate; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.ImageView; import android.widget.TextView; public class PrivateCertificateHttpsActivity extends Activity { private EditText mUrlBox; private TextView mMsgBox; private ImageView mImgBox; private AsyncTask mAsyncTask ; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUrlBox = (EditText)findViewById(R.id.urlbox); mMsgBox = (TextView)findViewById(R.id.msgbox); mImgBox = (ImageView)findViewById(R.id.imageview); } @Override protected void onPause() { if (mAsyncTask != null) mAsyncTask.cancel(true); super.onPause(); } public void onClick(View view) { String url = mUrlBox.getText().toString(); mMsgBox.setText(url); mImgBox.setImageBitmap(null); if (mAsyncTask != null) mAsyncTask.cancel(true); mAsyncTask = new PrivateCertificateHttpsGet(this) { @Override protected void onPostExecute(Object result) { if (result instanceof Exception) { Exception e = (Exception)result; mMsgBox.append(\"\\nException occurs\\n\" + e.toString()); } else { byte[] data = (byte[])result; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); mImgBox.setImageBitmap(bmp); } } }.execute(url); } } Using a modern approach \u2014 Network Security Configuration The Android platform provides a new simple instrument for configuration of a network \u2014 Network Security Configuration (NSC). This instrument is available on Android 7.0. and above. With help of NSC, you can configure network connections (including SSL-Pinning) using XML files. To turn on the configuration, you need to link the configuration file with the application's manifest. To do this, use the networkSecurityConfig attribute in the application tag. Create the configuration file res/xml/network_security_config.xml Add the android:networkSecurityConfig attribute specifying the file location in AndroidManifest.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.netguru.demoapp\"> <application android:networkSecurityConfig=\"@xml/network_security_config\"> ... </application> </manifest> Create the configuration file and add certificate fingerprints: <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"true\">example.com</domain> <pin-set> <pin digest=\"SHA-256\">ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=</pin> <pin digest=\"SHA-256\">GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=</pin> </pin-set> </domain-config> </network-security-config> As you can see, this method is very easy to implement. However, keep in mind that it is only available for API level 24 or higher.","title":"Recommendations"},{"location":"rg/en/android/transmission_of_sensitive_information_in_an_http_response/#links","text":"http://thedifference.ru/chem-otlichaetsya-http-ot-https/ . https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet http://mashable.com/2011/05/31/https-web-security/ https://medium.com/@appmattus/android-security-ssl-pinning-1db8acb6621e https://developer.android.com/training/articles/security-ssl https://www.netguru.com/codestories/3-ways-how-to-implement-certificate-pinning-on-android https://developer.android.com/training/articles/security-config","title":"Links"},{"location":"rg/en/android/transmission_of_sensitive_information_in_broadcastreceiver/","text":"Transmission of sensitive information in BroadcastReceiver Severity: CRITICAL Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into an Intent to launch a private BroadcastReceiver . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used (the recipient is not specified explicitly or the broadcasting mechanism Broadcast is used), the data in such message could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations An explicit Intent , Private BroadcastReceiver or LocalBroadcastManager shall be used when sending a Broadcast to an internal BroadcastReceiver with sensitive information. Note also that an application must not include sensitive information in a Public Broadcast . To receive a Broadcast you need to create BroadcastReceiver . Risks from using BroadcastReceiver and corresponding countermeasures vary depending on the type of a Broadcast . To find out what type of BroadcastReceiver you are supposed to create, follow through the table and chart below. An application that receives a Broadcast is not able to check the name of the package from which the Broadcast has been sent, so it is not possible to create a Partner BroadcastReceiver like an Activity . In addition, BroadcastReceiver can be static or dynamic depending on the declaration method. Example of creating a Private BroadcastReceiver Private BroadcastReceiver is the safest type, because it can receive Broadcasts from the same application in which it was declared. Private BroadcastReceiver can be declared as Static only. Rules (receiving a Broadcast ): Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can put confidential information into the resulting Intent because it is sent and received within the same application. Declaring a component in AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.broadcast.privatereceiver\" > <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:allowBackup=\"false\" > <!-- Private Broadcast Receiver --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <receiver android:name=\".PrivateReceiver\" android:exported=\"false\" /> <activity android:name=\".PrivateSenderActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Receiving a Broadcast package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class PrivateReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e // Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(context, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_SHORT).show(); // *** 3 *** \u0412 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e // \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f setResultCode(Activity.RESULT_OK); setResultData(\"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\"); abortBroadcast(); } } Rules (sending a Broadcast): Use an explicit Intent indicating the name of BroadcastReceiver class within the application You can send sensitive information. Verify the received result data and handle it in a secure manner despite the fact that it was sent from BroadcastReceiver of the same application. package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.TextView; public class PrivateSenderActivity extends Activity { public void onSendNormalClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendBroadcast(intent); } public void onSendOrderedClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendOrderedBroadcast(intent, null, mResultReceiver, null, 0, null, null); } private BroadcastReceiver mResultReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // *** 3 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 // \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u0438\u0437 BroadcastReceiver // \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String data = getResultData(); PrivateSenderActivity.this.logLine( String.format(\"Received result: \\\"%s\\\"\", data)); } }; private TextView mLogView; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mLogView = (TextView)findViewById(R.id.logview); } private void logLine(String line) { mLogView.append(line); mLogView.append(\"\\n\"); } } Links https://developer.android.com/guide/components/intents-filters.html https://developer.android.com/training/basics/intents/index.html https://cwe.mitre.org/data/definitions/927.html https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-for-injection-flaws-mstg-platform-2","title":"Transmission of sensitive information in BroadcastReceiver"},{"location":"rg/en/android/transmission_of_sensitive_information_in_broadcastreceiver/#transmission-of-sensitive-information-in-broadcastreceiver","text":"Severity: CRITICAL Detection method: DAST, SENSITIVE INFO","title":"Transmission of sensitive information in BroadcastReceiver"},{"location":"rg/en/android/transmission_of_sensitive_information_in_broadcastreceiver/#description","text":"An application puts sensitive information into an Intent to launch a private BroadcastReceiver . This can lead to interception of information by external applications. Interprocess communication (IPC) on Android is performed using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest - AndroidManifest.xml or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used (the recipient is not specified explicitly or the broadcasting mechanism Broadcast is used), the data in such message could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/transmission_of_sensitive_information_in_broadcastreceiver/#recommendations","text":"An explicit Intent , Private BroadcastReceiver or LocalBroadcastManager shall be used when sending a Broadcast to an internal BroadcastReceiver with sensitive information. Note also that an application must not include sensitive information in a Public Broadcast . To receive a Broadcast you need to create BroadcastReceiver . Risks from using BroadcastReceiver and corresponding countermeasures vary depending on the type of a Broadcast . To find out what type of BroadcastReceiver you are supposed to create, follow through the table and chart below. An application that receives a Broadcast is not able to check the name of the package from which the Broadcast has been sent, so it is not possible to create a Partner BroadcastReceiver like an Activity . In addition, BroadcastReceiver can be static or dynamic depending on the declaration method. Example of creating a Private BroadcastReceiver Private BroadcastReceiver is the safest type, because it can receive Broadcasts from the same application in which it was declared. Private BroadcastReceiver can be declared as Static only. Rules (receiving a Broadcast ): Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can put confidential information into the resulting Intent because it is sent and received within the same application. Declaring a component in AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.broadcast.privatereceiver\" > <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:allowBackup=\"false\" > <!-- Private Broadcast Receiver --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <receiver android:name=\".PrivateReceiver\" android:exported=\"false\" /> <activity android:name=\".PrivateSenderActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Receiving a Broadcast package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class PrivateReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e // Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(context, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_SHORT).show(); // *** 3 *** \u0412 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e // \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f setResultCode(Activity.RESULT_OK); setResultData(\"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\"); abortBroadcast(); } } Rules (sending a Broadcast): Use an explicit Intent indicating the name of BroadcastReceiver class within the application You can send sensitive information. Verify the received result data and handle it in a secure manner despite the fact that it was sent from BroadcastReceiver of the same application. package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.TextView; public class PrivateSenderActivity extends Activity { public void onSendNormalClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendBroadcast(intent); } public void onSendOrderedClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendOrderedBroadcast(intent, null, mResultReceiver, null, 0, null, null); } private BroadcastReceiver mResultReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // *** 3 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 // \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u0438\u0437 BroadcastReceiver // \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String data = getResultData(); PrivateSenderActivity.this.logLine( String.format(\"Received result: \\\"%s\\\"\", data)); } }; private TextView mLogView; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mLogView = (TextView)findViewById(R.id.logview); } private void logLine(String line) { mLogView.append(line); mLogView.append(\"\\n\"); } }","title":"Recommendations"},{"location":"rg/en/android/transmission_of_sensitive_information_in_broadcastreceiver/#links","text":"https://developer.android.com/guide/components/intents-filters.html https://developer.android.com/training/basics/intents/index.html https://cwe.mitre.org/data/definitions/927.html https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-for-injection-flaws-mstg-platform-2","title":"Links"},{"location":"rg/en/android/transmission_of_sensitive_information_in_sql_query_parameters/","text":"Transmission of sensitive information in SQL query parameters Severity: INFO Detection method: DAST, SQL Description An application uses sensitive information when sending queries to the database. SQL query interception is not a vulnerability if measures are used to detect application tooling using tools such as Frida or Xposed, root access checks are performed, and the database storing sensitive information is encrypted using a strong password . Intercepted data is used by Mobix to search for the intercepted value in the collected data . Recommendations To protect against runtime password interception, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult. Links https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Transmission of sensitive information in SQL query parameters"},{"location":"rg/en/android/transmission_of_sensitive_information_in_sql_query_parameters/#transmission-of-sensitive-information-in-sql-query-parameters","text":"Severity: INFO Detection method: DAST, SQL","title":"Transmission of sensitive information in SQL query parameters"},{"location":"rg/en/android/transmission_of_sensitive_information_in_sql_query_parameters/#description","text":"An application uses sensitive information when sending queries to the database. SQL query interception is not a vulnerability if measures are used to detect application tooling using tools such as Frida or Xposed, root access checks are performed, and the database storing sensitive information is encrypted using a strong password . Intercepted data is used by Mobix to search for the intercepted value in the collected data .","title":"Description"},{"location":"rg/en/android/transmission_of_sensitive_information_in_sql_query_parameters/#recommendations","text":"To protect against runtime password interception, it is necessary to use protection measures to detect application tooling and root access detection. One of the good ways is to use the DetectFrida and DetectMagiskHide . These libraries implement checks in native code, which makes their analysis and modification much more difficult.","title":"Recommendations"},{"location":"rg/en/android/transmission_of_sensitive_information_in_sql_query_parameters/#links","text":"https://github.com/sqlcipher/android-database-sqlcipher https://github.com/darvincisec/DetectMagiskHide https://github.com/darvincisec/DetectFrida https://darvincitech.wordpress.com/2019/12/23/detect-frida-for-android/ https://darvincitech.wordpress.com/2019/11/04/detecting-magisk-hide/ https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted","title":"Links"},{"location":"rg/en/android/transmission_of_sensitive_information_to_a_private_broadcastreceiver/","text":"Transmission of sensitive information in a private BroadcastReceiver Severity: INFO Detection method: DAST, SENSITIVE INFO Description An application puts sensitive information into an Intent to launch a private BroadcastReceiver . Interprocess communication (IPC) in Android is conducted using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest \u2014 AndroidManifest.xml , or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used (recipient is not specified explicitly or the broadcasting mechanism Broadcast is used), data in such message could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible. Recommendations An explicit Intent , Private BroadcastReceiver , or LocalBroadcastManager should be used when sending a Broadcast with sensitive information to an internal BroadcastReceiver . Note also that an application must not include sensitive information in a Public Broadcast . To receive a Broadcast you need to create BroadcastReceiver . Risks from using BroadcastReceiver and corresponding countermeasures vary depending on the type of a Broadcast . To find out what type of BroadcastReceiver you are supposed to create, follow through the table and chart below. An application that receives a Broadcast is not able to check the name of the package from which the Broadcast has been sent, so it is not possible to create a Partner BroadcastReceiver [like an Activity]. Type of BroadcastReceiver Description Private BroadcastReceiver BroadcastReceiver that can receive a Broadcast only from the same application, and is therefore the safest type Public BroadcastReceiver BroadcastReceiver that can receive a Broadcast from any application In-house BroadcastReceiver BroadcastReceiver that can receive a Broadcast only from other applications of the same developer In addition, BroadcastReceiver can be static or dynamic depending on the declaration method. \u2014 Declaration method Characteristics Static BroadcastReceiver. By adding the \\ elements into AndroidManifest.xml \u2013 is not able to receive some system Broadcasts (such as ACTION_BATTERY_CHANGE ); \u2013 will receive Broadcasts from the moment the application is installed until it is uninstalled. Dynamic BroadcastReceiver By calling the registerReceiver() method \u2013 can receive all Broadcasts, even those not receivable by static BroadcastReceiver ; \u2013 period of receiving Broadcasts is controlled by the program logic; \u2013 Private BroadcastReceiver cannot be created Example of creating a Private BroadcastReceiver Private BroadcastReceiver is the safest type, because it can receive a Broadcast from the same application only. Private BroadcastReceiver can be declared as Static only. Rules (receiving a Broadcast ): Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can put confidential information into the resulting Intent because it is sent and received within the same application Declaring a component in AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.broadcast.privatereceiver\" > <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:allowBackup=\"false\" > <!-- Private Broadcast Receiver --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <receiver android:name=\".PrivateReceiver\" android:exported=\"false\" /> <activity android:name=\".PrivateSenderActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Receiving a Broadcast package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class PrivateReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(context, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_SHORT).show(); // *** 3 *** \u0412 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f setResultCode(Activity.RESULT_OK); setResultData(\"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\"); abortBroadcast(); } } Rules (sending a Broadcast): Use an explicit Intent indicating the name of BroadcastReceiver class within the application You can send sensitive information. Verify the received result data and handle it in a secure manner despite the fact that it was sent from BroadcastReceiver of the same application. package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.TextView; public class PrivateSenderActivity extends Activity { public void onSendNormalClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendBroadcast(intent); } public void onSendOrderedClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendOrderedBroadcast(intent, null, mResultReceiver, null, 0, null, null); } private BroadcastReceiver mResultReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // *** 3 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u0438\u0437 BroadcastReceiver \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String data = getResultData(); PrivateSenderActivity.this.logLine( String.format(\"Received result: \\\"%s\\\"\", data)); } }; private TextView mLogView; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mLogView = (TextView)findViewById(R.id.logview); } private void logLine(String line) { mLogView.append(line); mLogView.append(\"\\n\"); } } Links Intents and Intent Filters | Android Developers Interacting with Other Apps | Android Developers CWE - CWE-927: Use of Implicit Intent for Sensitive Communication (4.6) owasp-mstg/0x05h-Testing-Platform-Interaction.md at master \u00b7 OWASP/owasp-mstg","title":"Transmission of sensitive information in a private BroadcastReceiver"},{"location":"rg/en/android/transmission_of_sensitive_information_to_a_private_broadcastreceiver/#transmission-of-sensitive-information-in-a-private-broadcastreceiver","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Transmission of sensitive information in a private BroadcastReceiver"},{"location":"rg/en/android/transmission_of_sensitive_information_to_a_private_broadcastreceiver/#description","text":"An application puts sensitive information into an Intent to launch a private BroadcastReceiver . Interprocess communication (IPC) in Android is conducted using a special object \u2014 Intent . Parameters of Intent handlers are set in the main file of the application manifest \u2014 AndroidManifest.xml , or, in case of dynamic BroadcastReceivers , in the application's code. If an implicit Intent is used (recipient is not specified explicitly or the broadcasting mechanism Broadcast is used), data in such message could be compromised. Moreover, malicious applications could use mechanisms of delegation of process control, such as implicit calls to application components or objects like PendingIntent , for interception of control and fishing attacks. The following object types are dangerous: Activity , Service , BroadcastReceiver and ContentProvider , because they are open to communication with other applications and don't belong to system Android calls (such as android.intent.action.MAIN ). BroadcastReceiver is, by default, open to interaction with other applications, so the interception of control or of an Intent with confidential information is possible.","title":"Description"},{"location":"rg/en/android/transmission_of_sensitive_information_to_a_private_broadcastreceiver/#recommendations","text":"An explicit Intent , Private BroadcastReceiver , or LocalBroadcastManager should be used when sending a Broadcast with sensitive information to an internal BroadcastReceiver . Note also that an application must not include sensitive information in a Public Broadcast . To receive a Broadcast you need to create BroadcastReceiver . Risks from using BroadcastReceiver and corresponding countermeasures vary depending on the type of a Broadcast . To find out what type of BroadcastReceiver you are supposed to create, follow through the table and chart below. An application that receives a Broadcast is not able to check the name of the package from which the Broadcast has been sent, so it is not possible to create a Partner BroadcastReceiver [like an Activity]. Type of BroadcastReceiver Description Private BroadcastReceiver BroadcastReceiver that can receive a Broadcast only from the same application, and is therefore the safest type Public BroadcastReceiver BroadcastReceiver that can receive a Broadcast from any application In-house BroadcastReceiver BroadcastReceiver that can receive a Broadcast only from other applications of the same developer In addition, BroadcastReceiver can be static or dynamic depending on the declaration method. \u2014 Declaration method Characteristics Static BroadcastReceiver. By adding the \\ elements into AndroidManifest.xml \u2013 is not able to receive some system Broadcasts (such as ACTION_BATTERY_CHANGE ); \u2013 will receive Broadcasts from the moment the application is installed until it is uninstalled. Dynamic BroadcastReceiver By calling the registerReceiver() method \u2013 can receive all Broadcasts, even those not receivable by static BroadcastReceiver ; \u2013 period of receiving Broadcasts is controlled by the program logic; \u2013 Private BroadcastReceiver cannot be created Example of creating a Private BroadcastReceiver Private BroadcastReceiver is the safest type, because it can receive a Broadcast from the same application only. Private BroadcastReceiver can be declared as Static only. Rules (receiving a Broadcast ): Explicitly specify the exported=\"false\" attribute. Verify the received Intent and handle it in a secure manner despite the fact that it was sent from the same application. You can put confidential information into the resulting Intent because it is sent and received within the same application Declaring a component in AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.appsec.android.broadcast.privatereceiver\" > <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:allowBackup=\"false\" > <!-- Private Broadcast Receiver --> <!-- *** 1 *** \u042f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0439\u0442\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 exported=\"false\" --> <receiver android:name=\".PrivateReceiver\" android:exported=\"false\" /> <activity android:name=\".PrivateSenderActivity\" android:label=\"@string/app_name\" android:exported=\"true\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Receiving a Broadcast package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class PrivateReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // *** 2 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0433\u043e Intent, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0431\u044b\u043b \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0438\u0437 \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f String param = intent.getStringExtra(\"PARAM\"); Toast.makeText(context, String.format(\"Received param: \\\"%s\\\"\", param), Toast.LENGTH_SHORT).show(); // *** 3 *** \u0412 Intent \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0434\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0442.\u043a. \u0435\u0433\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f setResultCode(Activity.RESULT_OK); setResultData(\"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\"); abortBroadcast(); } } Rules (sending a Broadcast): Use an explicit Intent indicating the name of BroadcastReceiver class within the application You can send sensitive information. Verify the received result data and handle it in a secure manner despite the fact that it was sent from BroadcastReceiver of the same application. package com.appsec.android.broadcast.privatereceiver; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.TextView; public class PrivateSenderActivity extends Activity { public void onSendNormalClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendBroadcast(intent); } public void onSendOrderedClick(View view) { // *** 1 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u044f\u0432\u043d\u044b\u0439 Intent \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u043c\u0435\u043d\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 BroadcastReceiver \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Intent intent = new Intent(this, PrivateReceiver.class); // *** 2 *** \u041c\u043e\u0436\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e intent.putExtra(\"PARAM\", \"\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044f\"); sendOrderedBroadcast(intent, null, mResultReceiver, null, 0, null, null); } private BroadcastReceiver mResultReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // *** 3 *** \u041f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0438 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0443\u044e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0442\u043e, \u0447\u0442\u043e \u043e\u043d\u0438 \u0431\u044b\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b \u0438\u0437 BroadcastReceiver \u0442\u043e\u0433\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f // \u0421\u043c.\u043f. \"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0430\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" String data = getResultData(); PrivateSenderActivity.this.logLine( String.format(\"Received result: \\\"%s\\\"\", data)); } }; private TextView mLogView; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mLogView = (TextView)findViewById(R.id.logview); } private void logLine(String line) { mLogView.append(line); mLogView.append(\"\\n\"); } }","title":"Recommendations"},{"location":"rg/en/android/transmission_of_sensitive_information_to_a_private_broadcastreceiver/#links","text":"Intents and Intent Filters | Android Developers Interacting with Other Apps | Android Developers CWE - CWE-927: Use of Implicit Intent for Sensitive Communication (4.6) owasp-mstg/0x05h-Testing-Platform-Interaction.md at master \u00b7 OWASP/owasp-mstg","title":"Links"},{"location":"rg/en/android/url_spoofing_possibility/","text":"Possibility of URL spoofing Severity: MEDIUM Detection method: IAST Description The vulnerability allows an attacker to control a URL in an instance of the java.net.URL class. Depending on how a URL is used, this vulnerability can be exploited in different attack vectors. Vulnerability is present if an instance of the java.net.URL class is created based on a string obtained from an untrusted source. For example, a vulnerable application can use this code: if(\"https\".equals(uri.getScheme()) && \"vuln.app.pkg\".equals(uri.getHost())) { String path = uri.getPath(); if(\"/login\".equals(path)) { String urlStr = uri.getQueryParameter(\"url\"); if(urlStr != null) { try { URL url = new URL(urlStr); /* .. */ } catch (MalformedURLException e) { e.printStackTrace(); } } finish(); } } Recommendations Perform URL validation: Allow access only to company resources, i.e., maintain a \"white list\" of URLs and check the created URL instance against it. Allow access only to particular origin, i.e. check scheme and domain of the URL. The generated URL should also be checked before use. List<String> whiteHosts = Arrays.asList(\"stackoverflow.com\", \"stackexchange.com\", \"google.com\"); public boolean isValid(String url) { String host = Uri.parse(url).getHost(); if(whiteHosts.contains(host) { return true; } return false; } Links Input Validation - OWASP Cheat Sheet Series UrlQuerySanitizer | Android Developers","title":"Possibility of URL spoofing"},{"location":"rg/en/android/url_spoofing_possibility/#possibility-of-url-spoofing","text":"Severity: MEDIUM Detection method: IAST","title":"Possibility of URL spoofing"},{"location":"rg/en/android/url_spoofing_possibility/#description","text":"The vulnerability allows an attacker to control a URL in an instance of the java.net.URL class. Depending on how a URL is used, this vulnerability can be exploited in different attack vectors. Vulnerability is present if an instance of the java.net.URL class is created based on a string obtained from an untrusted source. For example, a vulnerable application can use this code: if(\"https\".equals(uri.getScheme()) && \"vuln.app.pkg\".equals(uri.getHost())) { String path = uri.getPath(); if(\"/login\".equals(path)) { String urlStr = uri.getQueryParameter(\"url\"); if(urlStr != null) { try { URL url = new URL(urlStr); /* .. */ } catch (MalformedURLException e) { e.printStackTrace(); } } finish(); } }","title":"Description"},{"location":"rg/en/android/url_spoofing_possibility/#recommendations","text":"Perform URL validation: Allow access only to company resources, i.e., maintain a \"white list\" of URLs and check the created URL instance against it. Allow access only to particular origin, i.e. check scheme and domain of the URL. The generated URL should also be checked before use. List<String> whiteHosts = Arrays.asList(\"stackoverflow.com\", \"stackexchange.com\", \"google.com\"); public boolean isValid(String url) { String host = Uri.parse(url).getHost(); if(whiteHosts.contains(host) { return true; } return false; }","title":"Recommendations"},{"location":"rg/en/android/url_spoofing_possibility/#links","text":"Input Validation - OWASP Cheat Sheet Series UrlQuerySanitizer | Android Developers","title":"Links"},{"location":"rg/en/android/using_a_file_keystore/","text":"Using a file keystore Severity: LOW Detection method: DAST, KEY INFORMATION Description An application uses a file key storage. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Links https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Using a file keystore"},{"location":"rg/en/android/using_a_file_keystore/#using-a-file-keystore","text":"Severity: LOW Detection method: DAST, KEY INFORMATION","title":"Using a file keystore"},{"location":"rg/en/android/using_a_file_keystore/#description","text":"An application uses a file key storage. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations\u2014the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. There are several ways to store the keys depending on a version of the operating system: in the AndroidKeyStore storage or in the application's directory in BKS. The most secure option, without a doubt, is to store keys in AndroidKeyStore. If there is a need to store the keys in BKS, you should ensure that the storage itself as well as all keys are protected by a strong password. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/android/using_a_file_keystore/#recommendations","text":"Encryption keys must not be stored in a location with public access, even if this is the application's directory on an SD-card. There are several ways to store the keys depending on a version of the operating system: On Android API\\<18 the encryption keys must be stored inside the application's directory in BKS. On Android API>=18 RSA keys must be stored in AndroidKeyStore, and AES keys\u2014in BKS. On Android API>=23 RSA and AES keys must be stored in AndroidKeyStore. Also, don't forget that when using the BKS in the internal application's directory, an additional strong password is required to protect the keystore and the keys within it. A good idea would be to check the generated password against a database for most common passwords and ensure that the password meets minimum requirements: The password is at least 20 characters in length. At least one lower-case letter is required. At least one upper-case letter is required. At least one numeric character is required. At least one special character is required. Generation of a password-protected BKS storage containing a key protected with an additional password: keytool -importcert -v -trustcacerts -file \"C:\\Users\\Indra\\Documents\\myapp.com.cer\" -alias IntermediateCA -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass StorePass123 keytool -list -keystore \"C:\\Users\\Indra\\Documents\\appKeyStore.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" -storetype BKS -storepass \"StorePass123\" ------------------------------------------------------------------------------------------------ openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out testkeystore.p12 Export password : exportpass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\testkeystore.p12\" -srcstoretype pkcs12 -destkeystore \"\"C:\\Users\\Indra\\myapp\\wso2carbon.jks\" -deststoretype JKS Destination keystore password : exportpass123 ----------------------------------------------------- Final JKS Keystore generation ------------ # openssl pkcs12 -export -in \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -inkey \"/home/myapp/myapp_cert_2016/domainname.key\" -certfile \"/home/myapp/myapp_cert_2016/ssl_certificate.crt\" -out myapp_cert.p12 Export Password : StorePass123 keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_cert.p12\" -srcstoretype pkcs12 -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks\" -deststoretype JKS Import Password : StorePass123 ----------------------------------------------------- Final BKS Keystore generation ------------ keytool -importkeystore -srckeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.jks -deststoretype JKS\" -destkeystore \"C:\\Users\\Indra\\myapp\\myapp_keystore.bks\" -srcstoretype JKS -deststoretype BKS -srcstorepass StorePass123 -deststorepass StorePass123 -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"C:\\Users\\Indra\\Downloads\\bcprov-jdk15on-154.jar\" On error or exception steps to be taken - Comment above line and add the new line in java.security file in jre/lib/security #security.provider.7=com.sun.security.sasl.Provider security.provider.7=org.bouncycastle.jce.provider.BouncyCastleProvider - You need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy To interact with AndroidKeyStore you can use an auxiliary library or create your own implementation. See below an example of essential code fragments needed to encrypt and store the key in AndroidKeyStore. Adding a new key into KeyStore public void createNewKeys(View view) { String alias = aliasText.getText().toString(); try { // Create new key if needed if (!keyStore.containsAlias(alias)) { Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); end.add(Calendar.YEAR, 1); KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this) .setAlias(alias) .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\")) .setSerialNumber(BigInteger.ONE) .setStartDate(start.getTime()) .setEndDate(end.getTime()) .build(); KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); generator.initialize(spec); KeyPair keyPair = generator.generateKeyPair(); } } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } refreshKeys(); } Deleting a key from KeyStore public void deleteKey(final String alias) { AlertDialog alertDialog =new AlertDialog.Builder(this) .setTitle(\"Delete Key\") .setMessage(\"Do you want to delete the key \\\"\" + alias + \"\\\" from the keystore?\") .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { try { keyStore.deleteEntry(alias); refreshKeys(); } catch (KeyStoreException e) { Toast.makeText(MainActivity.this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } dialog.dismiss(); } }) .setNegativeButton(\"No\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create(); alertDialog.show(); } Using a key for encryption public void encryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey(); // Encrypt the text String initialText = startText.getText().toString(); if(initialText.isEmpty()) { Toast.makeText(this, \"Enter text in the 'Initial Text' widget\", Toast.LENGTH_LONG).show(); return; } Cipher input = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); input.init(Cipher.ENCRYPT_MODE, publicKey); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); CipherOutputStream cipherOutputStream = new CipherOutputStream( outputStream, input); cipherOutputStream.write(initialText.getBytes(\"UTF-8\")); cipherOutputStream.close(); byte [] vals = outputStream.toByteArray(); encryptedText.setText(Base64.encodeToString(vals, Base64.DEFAULT)); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } } Using a key for decryption public void decryptString(String alias) { try { KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null); RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey(); Cipher output = Cipher.getInstance(\"RSA/CBC/PKCS7Padding\", \"AndroidOpenSSL\"); output.init(Cipher.DECRYPT_MODE, privateKey); String cipherText = encryptedText.getText().toString(); CipherInputStream cipherInputStream = new CipherInputStream( new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output); ArrayList values = new ArrayList<>(); int nextByte; while ((nextByte = cipherInputStream.read()) != -1) { values.add((byte)nextByte); } byte[] bytes = new byte[values.size()]; for(int i = 0; i < bytes.length; i++) { bytes[i] = values.get(i).byteValue(); } String finalText = new String(bytes, 0, bytes.length, \"UTF-8\"); decryptedText.setText(finalText); } catch (Exception e) { Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show(); Log.e(TAG, Log.getStackTraceString(e)); } }","title":"Recommendations"},{"location":"rg/en/android/using_a_file_keystore/#links","text":"https://developer.android.com/training/articles/keystore#kotlin https://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/ https://developer.android.com/guide/topics/security/cryptography https://developer.android.com/reference/androidx/security/crypto/EncryptedFile https://security.stackexchange.com/questions/128003/does-the-use-of-a-smartphones-secure-element-really-offer-security-benefits-to https://github.com/Q42/Qlassified-Android","title":"Links"},{"location":"rg/en/android/weak_database_encryption_password/","text":"Weak database encryption password Severity: MEDIUM Detection method: DAST, API Description The password used to encrypt the database does not meet the criteria of length, simplicity or frequency of use. The main parameter for the security of data storage in an encrypted database on a device is the password that is used for encryption. If the chosen password is too simple or is present in the database of the most common passwords, there is a high probability of finding a password and compromising the information. Recommendations When using a password to encrypt the database, there exists the question of how to store it securely. Upon successful authentication in the application, there are several options for the server part to send a secret that forms the password used to open or encrypt the database. Another option is to generate an encryption key (that can be used as a database password) based on the user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mSalt = null; public byte[] getSalt() { return mSalt; } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } } In the future, the resulting key value can be used as a password to encrypt the database and there is no need to store it. Links https://github.com/sqlcipher/android-database-sqlcipher https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted https://cwe.mitre.org/data/definitions/521.html","title":"Weak database encryption password"},{"location":"rg/en/android/weak_database_encryption_password/#weak-database-encryption-password","text":"Severity: MEDIUM Detection method: DAST, API","title":"Weak database encryption password"},{"location":"rg/en/android/weak_database_encryption_password/#description","text":"The password used to encrypt the database does not meet the criteria of length, simplicity or frequency of use. The main parameter for the security of data storage in an encrypted database on a device is the password that is used for encryption. If the chosen password is too simple or is present in the database of the most common passwords, there is a high probability of finding a password and compromising the information.","title":"Description"},{"location":"rg/en/android/weak_database_encryption_password/#recommendations","text":"When using a password to encrypt the database, there exists the question of how to store it securely. Upon successful authentication in the application, there are several options for the server part to send a secret that forms the password used to open or encrypt the database. Another option is to generate an encryption key (that can be used as a database password) based on the user password. In this case, there is no need to store the encryption key, as it is generated \"on the fly\" based on the password entered by the user: Rules: Explicitly define the encryption mode and block padding. Use crypto-resistant encryption technologies including algorithm, block encryption mode, and block padding mode. Use \"salt\" when generating a password-based key. Use a sufficient number of hashing iterations while generating the key based on the password. Use a key with a length that ensures cryptographic strength of the encryption. package com.appsec.android.cryptsymmetricpasswordbasedkey; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; public final class AesCryptoPBEKey { // *** 1 *** \u042f\u0432\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0439\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432. // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u0432 \u043c\u0435\u0442\u043e\u0434 getInstance \u043a\u043b\u0430\u0441\u0441\u0430 Cipher: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=AES, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f=CBC, \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432=PKCS7Padding private static final String TRANSFORMATION = \"AES/CBC/PKCS7Padding\"; // \u0421\u0442\u0440\u043e\u043a\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u044e\u0447 private static final String KEY_GENERATOR_MODE = \"PBEWITHSHA256AND128BITAES-CBC-BC\"; // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0438 \"\u0441\u043e\u043b\u0438\" \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 public static final int SALT_LENGTH_BYTES = 20; // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0423\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e PBE private static final int KEY_GEN_ITERATION_COUNT = 1024; // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f // \u0414\u043b\u0438\u043d\u0430 \u043a\u043b\u044e\u0447\u0430 \u0432 \u0431\u0438\u0442\u0430\u0445 private static final int KEY_LENGTH_BITS = 128; private byte[] mSalt = null; public byte[] getSalt() { return mSalt; } private void initSalt() { mSalt = new byte[SALT_LENGTH_BYTES]; SecureRandom sr = new SecureRandom(); sr.nextBytes(mSalt); } private static final SecretKey generateKey(final char[] password, final byte[] salt) { SecretKey secretKey = null; PBEKeySpec keySpec = null; try { // *** 2 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u0438\u0435 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0449\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0440\u0435\u0436\u0438\u043c \u0431\u043b\u043e\u0447\u043d\u043e\u0433\u043e \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0431\u043b\u043e\u043a\u043e\u0432 // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 // \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043b\u0430\u0441\u0441 KeyFactory, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c SHA256 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 AES-CBC 128-\u0431\u0438\u0442\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KEY_GENERATOR_MODE); // *** 3 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \"\u0441\u043e\u043b\u044c\" (salt) // *** 4 *** \u0412 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043b\u044e\u0447\u0430 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f // *** 5 *** \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043b\u044e\u0447 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u043a\u0440\u0438\u043f\u0442\u043e\u0441\u0442\u043e\u0439\u043a\u043e\u0441\u0442\u044c \u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f keySpec = new PBEKeySpec(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u043f\u0430\u0440\u043e\u043b\u044f - \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u044b \u043e\u0442\u043b\u0430\u0434\u043a\u0438 \u0438 \u043d\u0435\u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f \u0432 \u0434\u0430\u043c\u043f \u043f\u0430\u043c\u044f\u0442\u0438 Arrays.fill(password, '?'); // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043a\u043b\u044e\u0447\u0430 secretKey = secretKeyFactory.generateSecret(keySpec); } catch (NoSuchAlgorithmException e) { } catch (InvalidKeySpecException e) { } finally { keySpec.clearPassword(); } return secretKey; } } In the future, the resulting key value can be used as a password to encrypt the database and there is no need to store it.","title":"Recommendations"},{"location":"rg/en/android/weak_database_encryption_password/#links","text":"https://github.com/sqlcipher/android-database-sqlcipher https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#sqlite-databases-encrypted https://cwe.mitre.org/data/definitions/521.html","title":"Links"},{"location":"rg/en/ios/","text":"iOS Storing keys/certificates Storing a key/certificate in the directory/resources of the application Storing a private key/certificate protected by a password in the directory/resources of the application Storing a public key/certificate in the directory/resources of the application Storing a private key/certificate that is not protected by a password in the directory/resources of the application Insecure storage of cryptographic key information A writable keystore A writable keystore protected by a weak password A readable file keystore A readable keystore, protected by a weak password, with private keys A readable keystore, protected by a weak password, with public keys A readable keystore containing private keys protected by a weak password Using a file keystore A keystore containing private keys protected by a weak password A keystore, protected by a weak password, containing public keys A keystore containing private keys protected by a weak password Enabled caching of network requests Output of sensitive information into the system log Insecure App Transport Security configuration Application does not use overflow protection features Presence of build scripts in the built application package Presence of Podfile in the built application package Storing sensitive information in the keyboard cache Storing sensitive information in NSUserDefaults Storing sensitive information in a private file Storing sensitive information in the application source code Storing sensitive information in Binary Cookies Storage or use of previously found sensitive information","title":"iOS"},{"location":"rg/en/ios/#ios","text":"Storing keys/certificates Storing a key/certificate in the directory/resources of the application Storing a private key/certificate protected by a password in the directory/resources of the application Storing a public key/certificate in the directory/resources of the application Storing a private key/certificate that is not protected by a password in the directory/resources of the application Insecure storage of cryptographic key information A writable keystore A writable keystore protected by a weak password A readable file keystore A readable keystore, protected by a weak password, with private keys A readable keystore, protected by a weak password, with public keys A readable keystore containing private keys protected by a weak password Using a file keystore A keystore containing private keys protected by a weak password A keystore, protected by a weak password, containing public keys A keystore containing private keys protected by a weak password Enabled caching of network requests Output of sensitive information into the system log Insecure App Transport Security configuration Application does not use overflow protection features Presence of build scripts in the built application package Presence of Podfile in the built application package Storing sensitive information in the keyboard cache Storing sensitive information in NSUserDefaults Storing sensitive information in a private file Storing sensitive information in the application source code Storing sensitive information in Binary Cookies Storage or use of previously found sensitive information","title":"iOS"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/","text":"A keystore containing private keys protected by a weak password Severity: MEDIUM Detection method: DAST, SENSITIVE INFORMATION Description An application uses a keystore containing private keys protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A keystore containing private keys protected by a weak password"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#a-keystore-containing-private-keys-protected-by-a-weak-password","text":"Severity: MEDIUM Detection method: DAST, SENSITIVE INFORMATION","title":"A keystore containing private keys protected by a weak password"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#description","text":"An application uses a keystore containing private keys protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_private_keys_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/","text":"A keystore, protected by a weak password, containing public keys Severity: LOW Detection method: DAST, KEY INFORMATION Description An application uses a keystore, protected by a weak password, containing public keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } Showing certificates func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A keystore, protected by a weak password, containing public keys"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#a-keystore-protected-by-a-weak-password-containing-public-keys","text":"Severity: LOW Detection method: DAST, KEY INFORMATION","title":"A keystore, protected by a weak password, containing public keys"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#description","text":"An application uses a keystore, protected by a weak password, containing public keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#showing-certificates","text":"func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Showing certificates"},{"location":"rg/en/ios/a_keystore%2C_protected_by_weak_password%2C_containing_public_keys_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/","text":"A keystore containing private keys protected by a weak password Severity: HIGH Detection method: DAST, KEY INFORMATION Description An application uses a keystore, protected by a weak password, containing private keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } Showing certificates func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A keystore containing private keys protected by a weak password"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#a-keystore-containing-private-keys-protected-by-a-weak-password","text":"Severity: HIGH Detection method: DAST, KEY INFORMATION","title":"A keystore containing private keys protected by a weak password"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#description","text":"An application uses a keystore, protected by a weak password, containing private keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#showing-certificates","text":"func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Showing certificates"},{"location":"rg/en/ios/a_keystore_containing_private_keys_protected_by_a_weak_password_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/","text":"A writable keystore protected by a weak password Severity: \u041a\u0420\u0418\u0422\u0418\u0427\u0415\u0421\u041a\u0418\u0419 Detection method: DAST, KEY INFORMATION Description An application uses a writable keystore protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 \u0432 Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A writable keystore protected by a weak password"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/#a-writable-keystore-protected-by-a-weak-password","text":"Severity: \u041a\u0420\u0418\u0422\u0418\u0427\u0415\u0421\u041a\u0418\u0419 Detection method: DAST, KEY INFORMATION","title":"A writable keystore protected by a weak password"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/#description","text":"An application uses a writable keystore protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 \u0432 Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_keystore_with_write_permission_protected_by_a_weak_password_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/","text":"A readable keystore, protected by a weak password, with private keys Severity: HIGH Detection method: DAST, KEY INFORMATION Description An application uses a readable keystore, protected by a weak password, with private keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A readable keystore, protected by a weak password, with private keys"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#a-readable-keystore-protected-by-a-weak-password-with-private-keys","text":"Severity: HIGH Detection method: DAST, KEY INFORMATION","title":"A readable keystore, protected by a weak password, with private keys"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#description","text":"An application uses a readable keystore, protected by a weak password, with private keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_private_keys_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/","text":"A readable keystore, protected by a weak password, with public keys Severity: LOW Detection method: DAST, KEY INFORMATION Description An application uses a readable keystore, protected by a weak password, with public keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } Showing certificates func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A readable keystore, protected by a weak password, with public keys"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#a-readable-keystore-protected-by-a-weak-password-with-public-keys","text":"Severity: LOW Detection method: DAST, KEY INFORMATION","title":"A readable keystore, protected by a weak password, with public keys"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#description","text":"An application uses a readable keystore, protected by a weak password, with public keys. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#showing-certificates","text":"func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Showing certificates"},{"location":"rg/en/ios/a_readable_keystore%2C_protected_by_a_weak_password%2C_with_public_keys_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/","text":"A readable keystore containing private keys protected by a weak password Severity: \u041a\u0420\u0418\u0422\u0418\u0427\u0415\u0421\u041a\u0418\u0419 Detection method: DAST, KEY INFORMATION Description An application uses a readable keystore containing private keys protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } Showing certificates func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A readable keystore containing private keys protected by a weak password"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#a-readable-keystore-containing-private-keys-protected-by-a-weak-password","text":"Severity: \u041a\u0420\u0418\u0422\u0418\u0427\u0415\u0421\u041a\u0418\u0419 Detection method: DAST, KEY INFORMATION","title":"A readable keystore containing private keys protected by a weak password"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#description","text":"An application uses a readable keystore containing private keys protected by a weak password. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#showing-certificates","text":"func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Showing certificates"},{"location":"rg/en/ios/a_readable_keystore_containing_private_keys_protected_by_a_weak_password_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/a_writable_keystore_ios/","text":"A writable keystore Severity: HIGH Detection method: DAST, KEY INFORMATION Description An application uses a writable keystore. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A writable keystore"},{"location":"rg/en/ios/a_writable_keystore_ios/#a-writable-keystore","text":"Severity: HIGH Detection method: DAST, KEY INFORMATION","title":"A writable keystore"},{"location":"rg/en/ios/a_writable_keystore_ios/#description","text":"An application uses a writable keystore. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/a_writable_keystore_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/a_writable_keystore_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/a_writable_keystore_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/a_writable_keystore_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/a_writable_keystore_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/a_writable_keystore_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/","text":"Application does not use overflow protection features Severity: MEDIUM Detection method: SAST, NETWORK Description iOS provides several ways to protect against exploiting overflow vulnerabilities. Disabling or not using the suggested protections can lead to opportunities to exploit vulnerabilities in an easier way. Although all security features are enabled by default in Xcode, it is recommended that you check the compilation options additionally. The following functions can be used: ARC - Automatic Reference Counting (memory management feature), adds save and free messages if necessary; Stack Canary - helps to prevent buffer overflow attacks; PIE - Position Independent Executable - includes the full ASLR. Recommendations Below is a description of each method of protection and the risks that may arise from disabling them. Automatic reference counting Automatic reference counting - tracking and managing the memory of your application. In most cases this means that memory management \"just works\" and you don't have to think about managing the memory yourself. ARC automatically frees memory used by class instances when those instances are no longer needed. \"Targets\" > \"Build Settings\u201c > \"Objective-C Automatic Reference Counting\" = \u201cYES\u201d Stack smashing protection The ipa archive of the assembled application contains an executable binary file in the mach-o format. It contains the following sections: static application information (text, constants, etc.), executable code, included static libraries and a list of dynamically loaded resources. Along with the table of partitioning and locations (addresses) of these sections there is data area with the flags of the compilation stage and peculiarities of its operation for the OS loader. One of these flags is the application protection mode flag against stack overflow and control interception. It is also called a canary-protection and consists of adding bit flags at the stack frame bounds. When trying to go beyond stack bounds and overwrite the return address from the function with an arbitrary value, the signal bit itself will also be overwritten. The operating system will be notified and the application process will stop. Compilation mode with stack overflow protection is set in the Xcode IDE environment, in the compilation settings menu with the \"-fstack-protector-all\" directive. The \u2018OTHER_CFLAGS = \"-fstack-protector-all\"\u2019 option is mandatory for projects written in languages with manual memory management, such as C / C++ / Objective-C. Manual analysis You can check the availability of this mode in the compiled application by unpacking the ipa-archive and analyzing the binary file stored in it with the utility \"otool\" for the existence of this setting. To do this, you can use the following command: otool -Iv DVIA | grep stack In the picture you can see the presence of signs of stack protection. You can also use the objection utility to get more information. Features of Swift applications Swift is a language with a \"strong typing\" paradigm and object boundary checking at compile time. This minimizes the risk of stack overflows and process control interception due to the language architecture itself and the LLVM compiler checks at compile time. The compiler does not leave information about stack protection directives in the binary file when it is built. For projects written only in Swift, there will be no flag in the resulting binary! Because it makes no sense for executable files written in pure Swift. So, to reliably determine if stack overflow protection mode is enabled, it is necessary to analyze the source code of the Xcode project and its compilation settings, see above. If this flag is triggered, you need to determine if Objective-C is being used in development. ASLR (Address space layout randomization) Address space layout randomization is a technology that randomly changes location of important data structures in the process address space, namely, executable file images, loaded libraries, heap and stack. ASLR is designed to make it harder to exploit several types of vulnerabilities. For example, if with a buffer overflow or other method an attacker is able to transfer control to an arbitrary address, he or she needs to guess which address is the stack, heap or other data structures where the code can be placed. \"Targets\" > \"Generate Position-Dependent Code\u201c = \"NO\" \"Targets\" > \"Don't Create Position Independent Executables \u201c = \"NO\" The picture below clearly shows how the application data is placed in memory with and without randomization: Links https://ru.bmstu.wiki/PIE_(Position_Independent_Execution) https://access.redhat.com/blogs/766093/posts/3548631 https://ru.bmstu.wiki/ASLR_(Address_Space_Layout_Randomization) https://bellis1000.medium.com/aslr-the-ios-kernel-how-virtual-address-spaces-are-randomised-d76d14dc7ebb https://developer.apple.com/forums/thread/86355 https://developer.apple.com/forums/thread/106300 https://sensepost.com/blog/2021/on-ios-binary-protections/ https://resources.infosecinstitute.com/topic/penetration-testing-for-iphone-applications-part-5/","title":"Application does not use overflow protection features"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#application-does-not-use-overflow-protection-features","text":"Severity: MEDIUM Detection method: SAST, NETWORK","title":"Application does not use overflow protection features"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#description","text":"iOS provides several ways to protect against exploiting overflow vulnerabilities. Disabling or not using the suggested protections can lead to opportunities to exploit vulnerabilities in an easier way. Although all security features are enabled by default in Xcode, it is recommended that you check the compilation options additionally. The following functions can be used: ARC - Automatic Reference Counting (memory management feature), adds save and free messages if necessary; Stack Canary - helps to prevent buffer overflow attacks; PIE - Position Independent Executable - includes the full ASLR.","title":"Description"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#recommendations","text":"Below is a description of each method of protection and the risks that may arise from disabling them.","title":"Recommendations"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#automatic-reference-counting","text":"Automatic reference counting - tracking and managing the memory of your application. In most cases this means that memory management \"just works\" and you don't have to think about managing the memory yourself. ARC automatically frees memory used by class instances when those instances are no longer needed. \"Targets\" > \"Build Settings\u201c > \"Objective-C Automatic Reference Counting\" = \u201cYES\u201d Stack smashing protection The ipa archive of the assembled application contains an executable binary file in the mach-o format. It contains the following sections: static application information (text, constants, etc.), executable code, included static libraries and a list of dynamically loaded resources. Along with the table of partitioning and locations (addresses) of these sections there is data area with the flags of the compilation stage and peculiarities of its operation for the OS loader. One of these flags is the application protection mode flag against stack overflow and control interception. It is also called a canary-protection and consists of adding bit flags at the stack frame bounds. When trying to go beyond stack bounds and overwrite the return address from the function with an arbitrary value, the signal bit itself will also be overwritten. The operating system will be notified and the application process will stop. Compilation mode with stack overflow protection is set in the Xcode IDE environment, in the compilation settings menu with the \"-fstack-protector-all\" directive. The \u2018OTHER_CFLAGS = \"-fstack-protector-all\"\u2019 option is mandatory for projects written in languages with manual memory management, such as C / C++ / Objective-C.","title":"Automatic reference counting"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#manual-analysis","text":"You can check the availability of this mode in the compiled application by unpacking the ipa-archive and analyzing the binary file stored in it with the utility \"otool\" for the existence of this setting. To do this, you can use the following command: otool -Iv DVIA | grep stack In the picture you can see the presence of signs of stack protection. You can also use the objection utility to get more information.","title":"Manual analysis"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#features-of-swift-applications","text":"Swift is a language with a \"strong typing\" paradigm and object boundary checking at compile time. This minimizes the risk of stack overflows and process control interception due to the language architecture itself and the LLVM compiler checks at compile time. The compiler does not leave information about stack protection directives in the binary file when it is built. For projects written only in Swift, there will be no flag in the resulting binary! Because it makes no sense for executable files written in pure Swift. So, to reliably determine if stack overflow protection mode is enabled, it is necessary to analyze the source code of the Xcode project and its compilation settings, see above. If this flag is triggered, you need to determine if Objective-C is being used in development.","title":"Features of Swift applications"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#aslr-address-space-layout-randomization","text":"Address space layout randomization is a technology that randomly changes location of important data structures in the process address space, namely, executable file images, loaded libraries, heap and stack. ASLR is designed to make it harder to exploit several types of vulnerabilities. For example, if with a buffer overflow or other method an attacker is able to transfer control to an arbitrary address, he or she needs to guess which address is the stack, heap or other data structures where the code can be placed. \"Targets\" > \"Generate Position-Dependent Code\u201c = \"NO\" \"Targets\" > \"Don't Create Position Independent Executables \u201c = \"NO\" The picture below clearly shows how the application data is placed in memory with and without randomization:","title":"ASLR (Address space layout randomization)"},{"location":"rg/en/ios/application_does_not_use_overflow_protection_features_ios/#links","text":"https://ru.bmstu.wiki/PIE_(Position_Independent_Execution) https://access.redhat.com/blogs/766093/posts/3548631 https://ru.bmstu.wiki/ASLR_(Address_Space_Layout_Randomization) https://bellis1000.medium.com/aslr-the-ios-kernel-how-virtual-address-spaces-are-randomised-d76d14dc7ebb https://developer.apple.com/forums/thread/86355 https://developer.apple.com/forums/thread/106300 https://sensepost.com/blog/2021/on-ios-binary-protections/ https://resources.infosecinstitute.com/topic/penetration-testing-for-iphone-applications-part-5/","title":"Links"},{"location":"rg/en/ios/enabled_caching_of_network_requests_ios/","text":"Enabled caching of network requests Severity: HIGH Detection method: DAST, SENSITIVE INFO Description When using the standard library for networking in iOS, all network requests are cached in the file system of the device. These cache files may contain interesting information, including authentication requests containing all user credentials. Despite the fact that this file is located in the internal directory of the application, it is not recommended to store session IDs and other sensitive data related to the authentication process in an open form. Recommendations To disable caching of network requests, use one of the suggested methods, depending on the implementation: Delete the shared cache at any time (for example, when you launch an application): URLCache.shared.removeAllCachedResponses() Disable cache on a global level: let theURLCache = URLCache(memoryCapacity: 0, diskCapacity: 0, diskPath: nil) URLCache.shared = theURLCache If you use a NSURLConnection object with a delegate, you can disable cache using the following method: func connection(_ connection: NSURLConnection, willCacheResponse cachedResponse: CachedURLResponse) -> CachedURLResponse? { return nil } Create a URL request that does not use cache: var request = NSMutableURLRequest(url: theUrl, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: urlTimeoutTime) Also, the NSURLRequest object has an attribute cachePolicy, which defines the work with cache: UseProtocolCachePolicy \u2014 default value, caching depends on HTTP headers. ReloadIgnoringLocalCacheData \u2014 cache is not used. Finally, one of the easiest options is to simply clear the network query database or delete this file when opening/closing the application. Links https://codewithchris.com/preventing-nsurlconnection-cache-issues/ https://developer.apple.com/forums/thread/45794 https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Concepts/CachePolicies.html","title":"Enabled caching of network requests"},{"location":"rg/en/ios/enabled_caching_of_network_requests_ios/#enabled-caching-of-network-requests","text":"Severity: HIGH Detection method: DAST, SENSITIVE INFO","title":"Enabled caching of network requests"},{"location":"rg/en/ios/enabled_caching_of_network_requests_ios/#description","text":"When using the standard library for networking in iOS, all network requests are cached in the file system of the device. These cache files may contain interesting information, including authentication requests containing all user credentials. Despite the fact that this file is located in the internal directory of the application, it is not recommended to store session IDs and other sensitive data related to the authentication process in an open form.","title":"Description"},{"location":"rg/en/ios/enabled_caching_of_network_requests_ios/#recommendations","text":"To disable caching of network requests, use one of the suggested methods, depending on the implementation: Delete the shared cache at any time (for example, when you launch an application): URLCache.shared.removeAllCachedResponses() Disable cache on a global level: let theURLCache = URLCache(memoryCapacity: 0, diskCapacity: 0, diskPath: nil) URLCache.shared = theURLCache If you use a NSURLConnection object with a delegate, you can disable cache using the following method: func connection(_ connection: NSURLConnection, willCacheResponse cachedResponse: CachedURLResponse) -> CachedURLResponse? { return nil } Create a URL request that does not use cache: var request = NSMutableURLRequest(url: theUrl, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: urlTimeoutTime) Also, the NSURLRequest object has an attribute cachePolicy, which defines the work with cache: UseProtocolCachePolicy \u2014 default value, caching depends on HTTP headers. ReloadIgnoringLocalCacheData \u2014 cache is not used. Finally, one of the easiest options is to simply clear the network query database or delete this file when opening/closing the application.","title":"Recommendations"},{"location":"rg/en/ios/enabled_caching_of_network_requests_ios/#links","text":"https://codewithchris.com/preventing-nsurlconnection-cache-issues/ https://developer.apple.com/forums/thread/45794 https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Concepts/CachePolicies.html","title":"Links"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/","text":"Insecure App Transport Security configuration Severity: HIGH Detection method: SAST, NETWORK Description The application uses an insecurely configured App Transport Security networking configuration. With the release of iOS 9.0, Apple introduced App Transport Security (ATS) as a mandatory setting for all applications. ATS configuration is a separate section inside the main Info.plist file of the application. The networking parameters are configured here. The ATS configuration has the following structure: NSAppTransportSecurity : Dictionary { NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean NSExceptionDomains : Dictionary { : Dictionary { NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean NSRequiresCertificateTransparency : Boolean } } } An incorrect networking implementation makes the Man In The Middle attacks easier and decreases the security of your application. Recommendations Below is a description of each of the parameters and the risks that can result from disabling each of the parameters. In this case, it is recommended to fully enable ATS at the application level and without exceptions for domains. Recommended configuration: <key>NSAppTransportSecurity</key> <dict> <key>NSAllowsArbitraryLoads</key> <false/> <key>NSAllowsArbitraryLoadsForMedia</key> <false/> <key>NSAllowsArbitraryLoadsInWebContent</key> <false/> </dict> Apple originally planned to require all apps on the App Store to support ATS by January 2017. Then Apple extended the deadline, but has yet to announce a new date. NSAllowArbitraryLoads The NSAllowArbitraryLoads key defines the state of ATS in general - whether it is on or off for the application. NSAllowArbitraryLoads is set to NO by default. Setting the key to YES will completely disable ATS. This means that ATS will not prevent your application from communicating with any HTTP domains and no security checks will be applied. It is strongly not recommended to disable ATS, especially for the entire application. If for some reason it is necessary to disable ATS, it is recommended to check additionally: Ciphers used for application networking (and that they are secure); The protocols used to send and receive data (and that they are secure); Whether there is a vulnerability in the application that allows switching to an earlier version of the encryption protocol; Whether the application checks the certificates used for TLS connections; NSAllowsLoadsForMedia This exception applies to multimedia content protected by digital rights management (DRM) or encryption. NSAllowsLoadsForMedia is set to NO by default. If the NSAllowsLoadsForMedia key is set to YES, ATS is disabled for content sent using the AVFoundation framework. This usually happens with applications that have the ability to handle video or audio content. If for some reason it is necessary to disable ATS, it is recommended to check additionally: The multimedia data sent by the application contains no confidential content and is protected by DRM or encryption; It is better to implement these protection measures even if the content is transmitted over HTTPS, because it is very easy to intercept content transmitted over HTTP or other insecure protocols. NSAllowsArbitraryLoadsInWebContent The NSAllowsArbitraryLoadsInWebContent key determines if it is possible to connect using insecure protocols from WebView components. NSAllowsArbitraryLoadsInWebContent is set to NO by default. If the key is set to YES, ATS will be disabled for WebView . Incorrect use of WebView can lead to various vulnerabilities in the application, so it is extremely important to secure these WebViews. For example, WebView can be vulnerable to a number of common web vulnerabilities, such as SQL injection, cross-site request forgery (CSRF), and cross-site scripting attacks (XSS). For more information about security when using WebView , see additional guidelines. NSAllowsLocalNetworking The NSAllowsLocalNetworking key defines the ATS operation in the local network. NSAllowsLocalNetworking is set to NO by default. Typically, applications that connect to a local device to provide an Internet of Things (IoT) network use this exception. If you disable ATS, make sure that no sensitive data is transmitted on the local network and that a secure TLS connection is used. NSExceptionDomains If you use the NSExceptionDomains key, you can configure ATS exceptions for specific domains. Remember that ATS subsections inside NSExceptionDomains replace other primary keys. For example, if an application loads media from a specific domain and both the top-level NSAllowsLoadsForMedia exception and the NSExceptionDomains configuration are used for that specific domain, then the NSExceptionDomains parameters take precedence. That is, they replace the top-level NSAllowsLoadsForMedia for that particular domain. Second point: if a domain is specified in exceptions without any configuration, that domain will get full ATS protection even if NSAllowsArbitraryLoads is set to YES. That is, developer can disable ATS globally, but enable it for specific domains by specifying them in the NSExceptionDomains key. Disabling ATS for the entire application and enabling it only for certain domains is a configuration error. If you want to use insecure protocols for known domains, you have to add them to exceptions, and enable ATS globally for the entire application. If you specify domain exceptions, ATS ignores any global configuration keys for that domain, such as NSAllowsArbitraryLoads. This works even if you leave the dictionary for the domain empty and rely entirely on the default values of its keys. NSIncludesSubdomains This key defines whether the ATS policy will be applied to all subdomains. NSIncludesSubdomains is set to NO by default. If the key is set to YES, any ATS configuration enabled for a particular domain will be used for all subdomains. If a domain is set, but no additional keys other than NSIncludesSubdomains are configured, that domain and its subdomains will use ATS. NSExceptionAllowsInsecureHTTPLoads The NSExceptionAllowsInsecureHTTPLoad key defines whether insecure HTTP traffic can be transmitted to the specified domain. NSExceptionAllowsInsecureHTTPLoad is set to NO by default. If the key is set to YES, the application will be allowed to send HTTP traffic to this domain. NSExceptionMinimumTLSVersion This key allows you to decrease the minimum allowable version of TLS. By default, valid versions are TLS 1.2 and higher. NSExceptionRequiresForwardSecrecy This key defines use of Forward Secrecy for a specific domain. NSExceptionAllowsInsecureHTTPLoad is set to YES by default. If the key is set to NO, Forward Secrecy will be disabled for a particular domain. NSRequiresCertificateTransparency This key defines use of Certificate Transparency for a specific domain. NSExceptionAllowsInsecureHTTPLoad is set to NO by default. If the key is set to YES, the domain certificate will require a Certificate Transparency timestamp. Certificate Transparency is a Google project aimed at improving security of the SSL certificate issuance system. If your organization or the target domain supports Certificate Transparency, it is recommended that you enable this option. Certificate Transparency helps to identify fraudulent certificate authorities. It also helps prevent man-in-the-middle attacks by notifying the owner if the certificate has been compromised. If this key is enabled, Certificate Transparency related certificate checks will be performed before a connection is established. ATS is not a silver bullet ATS is a client-side security measure that does not replace server-side security. Client-side security can be bypassed if an attacker has physical access to the device. While ATS protects iOS applications and their users by helping to prevent attacks on an earlier version of SSL and the use of weak ciphers, companies still need to protect the server side of the application. For example, by implementing HTTP Strict Transport Security (HSTS), disabling weak ciphers, etc. Client-side security reinforces server-side security and is just one layer of comprehensive mobile application security. Links https://developer.apple.com/documentation/security/preventing_insecure_network_connections https://books.nowsecure.com/secure-mobile-development/en/webviews/ https://developer.apple.com/documentation/security/preventing_insecure_network_connections https://www.certificate-transparency.org/ https://developer.apple.com/documentation/avfoundation https://developer.apple.com/news/?id=12212016b https://www.owasp.org/index.php/Mobile_Top_10_2016-M3-Insecure_Communication https://cwe.mitre.org/data/definitions/319.html","title":"Insecure App Transport Security configuration"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#insecure-app-transport-security-configuration","text":"Severity: HIGH Detection method: SAST, NETWORK","title":"Insecure App Transport Security configuration"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#description","text":"The application uses an insecurely configured App Transport Security networking configuration. With the release of iOS 9.0, Apple introduced App Transport Security (ATS) as a mandatory setting for all applications. ATS configuration is a separate section inside the main Info.plist file of the application. The networking parameters are configured here. The ATS configuration has the following structure: NSAppTransportSecurity : Dictionary { NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean NSExceptionDomains : Dictionary { : Dictionary { NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean NSRequiresCertificateTransparency : Boolean } } } An incorrect networking implementation makes the Man In The Middle attacks easier and decreases the security of your application.","title":"Description"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#recommendations","text":"Below is a description of each of the parameters and the risks that can result from disabling each of the parameters. In this case, it is recommended to fully enable ATS at the application level and without exceptions for domains. Recommended configuration: <key>NSAppTransportSecurity</key> <dict> <key>NSAllowsArbitraryLoads</key> <false/> <key>NSAllowsArbitraryLoadsForMedia</key> <false/> <key>NSAllowsArbitraryLoadsInWebContent</key> <false/> </dict> Apple originally planned to require all apps on the App Store to support ATS by January 2017. Then Apple extended the deadline, but has yet to announce a new date.","title":"Recommendations"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsallowarbitraryloads","text":"The NSAllowArbitraryLoads key defines the state of ATS in general - whether it is on or off for the application. NSAllowArbitraryLoads is set to NO by default. Setting the key to YES will completely disable ATS. This means that ATS will not prevent your application from communicating with any HTTP domains and no security checks will be applied. It is strongly not recommended to disable ATS, especially for the entire application. If for some reason it is necessary to disable ATS, it is recommended to check additionally: Ciphers used for application networking (and that they are secure); The protocols used to send and receive data (and that they are secure); Whether there is a vulnerability in the application that allows switching to an earlier version of the encryption protocol; Whether the application checks the certificates used for TLS connections;","title":"NSAllowArbitraryLoads"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsallowsloadsformedia","text":"This exception applies to multimedia content protected by digital rights management (DRM) or encryption. NSAllowsLoadsForMedia is set to NO by default. If the NSAllowsLoadsForMedia key is set to YES, ATS is disabled for content sent using the AVFoundation framework. This usually happens with applications that have the ability to handle video or audio content. If for some reason it is necessary to disable ATS, it is recommended to check additionally: The multimedia data sent by the application contains no confidential content and is protected by DRM or encryption; It is better to implement these protection measures even if the content is transmitted over HTTPS, because it is very easy to intercept content transmitted over HTTP or other insecure protocols.","title":"NSAllowsLoadsForMedia"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsallowsarbitraryloadsinwebcontent","text":"The NSAllowsArbitraryLoadsInWebContent key determines if it is possible to connect using insecure protocols from WebView components. NSAllowsArbitraryLoadsInWebContent is set to NO by default. If the key is set to YES, ATS will be disabled for WebView . Incorrect use of WebView can lead to various vulnerabilities in the application, so it is extremely important to secure these WebViews. For example, WebView can be vulnerable to a number of common web vulnerabilities, such as SQL injection, cross-site request forgery (CSRF), and cross-site scripting attacks (XSS). For more information about security when using WebView , see additional guidelines.","title":"NSAllowsArbitraryLoadsInWebContent"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsallowslocalnetworking","text":"The NSAllowsLocalNetworking key defines the ATS operation in the local network. NSAllowsLocalNetworking is set to NO by default. Typically, applications that connect to a local device to provide an Internet of Things (IoT) network use this exception. If you disable ATS, make sure that no sensitive data is transmitted on the local network and that a secure TLS connection is used.","title":"NSAllowsLocalNetworking"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsexceptiondomains","text":"If you use the NSExceptionDomains key, you can configure ATS exceptions for specific domains. Remember that ATS subsections inside NSExceptionDomains replace other primary keys. For example, if an application loads media from a specific domain and both the top-level NSAllowsLoadsForMedia exception and the NSExceptionDomains configuration are used for that specific domain, then the NSExceptionDomains parameters take precedence. That is, they replace the top-level NSAllowsLoadsForMedia for that particular domain. Second point: if a domain is specified in exceptions without any configuration, that domain will get full ATS protection even if NSAllowsArbitraryLoads is set to YES. That is, developer can disable ATS globally, but enable it for specific domains by specifying them in the NSExceptionDomains key. Disabling ATS for the entire application and enabling it only for certain domains is a configuration error. If you want to use insecure protocols for known domains, you have to add them to exceptions, and enable ATS globally for the entire application. If you specify domain exceptions, ATS ignores any global configuration keys for that domain, such as NSAllowsArbitraryLoads. This works even if you leave the dictionary for the domain empty and rely entirely on the default values of its keys.","title":"NSExceptionDomains"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsincludessubdomains","text":"This key defines whether the ATS policy will be applied to all subdomains. NSIncludesSubdomains is set to NO by default. If the key is set to YES, any ATS configuration enabled for a particular domain will be used for all subdomains. If a domain is set, but no additional keys other than NSIncludesSubdomains are configured, that domain and its subdomains will use ATS.","title":"NSIncludesSubdomains"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsexceptionallowsinsecurehttploads","text":"The NSExceptionAllowsInsecureHTTPLoad key defines whether insecure HTTP traffic can be transmitted to the specified domain. NSExceptionAllowsInsecureHTTPLoad is set to NO by default. If the key is set to YES, the application will be allowed to send HTTP traffic to this domain.","title":"NSExceptionAllowsInsecureHTTPLoads"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsexceptionminimumtlsversion","text":"This key allows you to decrease the minimum allowable version of TLS. By default, valid versions are TLS 1.2 and higher.","title":"NSExceptionMinimumTLSVersion"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsexceptionrequiresforwardsecrecy","text":"This key defines use of Forward Secrecy for a specific domain. NSExceptionAllowsInsecureHTTPLoad is set to YES by default. If the key is set to NO, Forward Secrecy will be disabled for a particular domain.","title":"NSExceptionRequiresForwardSecrecy"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#nsrequirescertificatetransparency","text":"This key defines use of Certificate Transparency for a specific domain. NSExceptionAllowsInsecureHTTPLoad is set to NO by default. If the key is set to YES, the domain certificate will require a Certificate Transparency timestamp. Certificate Transparency is a Google project aimed at improving security of the SSL certificate issuance system. If your organization or the target domain supports Certificate Transparency, it is recommended that you enable this option. Certificate Transparency helps to identify fraudulent certificate authorities. It also helps prevent man-in-the-middle attacks by notifying the owner if the certificate has been compromised. If this key is enabled, Certificate Transparency related certificate checks will be performed before a connection is established.","title":"NSRequiresCertificateTransparency"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#ats-is-not-a-silver-bullet","text":"ATS is a client-side security measure that does not replace server-side security. Client-side security can be bypassed if an attacker has physical access to the device. While ATS protects iOS applications and their users by helping to prevent attacks on an earlier version of SSL and the use of weak ciphers, companies still need to protect the server side of the application. For example, by implementing HTTP Strict Transport Security (HSTS), disabling weak ciphers, etc. Client-side security reinforces server-side security and is just one layer of comprehensive mobile application security.","title":"ATS is not a silver bullet"},{"location":"rg/en/ios/insecure_app_transport_security_configuration_ios/#links","text":"https://developer.apple.com/documentation/security/preventing_insecure_network_connections https://books.nowsecure.com/secure-mobile-development/en/webviews/ https://developer.apple.com/documentation/security/preventing_insecure_network_connections https://www.certificate-transparency.org/ https://developer.apple.com/documentation/avfoundation https://developer.apple.com/news/?id=12212016b https://www.owasp.org/index.php/Mobile_Top_10_2016-M3-Insecure_Communication https://cwe.mitre.org/data/definitions/319.html","title":"Links"},{"location":"rg/en/ios/output_of_sensitive_information_into_the_system_log_ios/","text":"Output of sensitive information into the system log Severity: HIGH Detection method: DAST, SENSITIVE INFO Description iOS provides an option for applications to output information into a system log. Applications can send information to the system log using the following: the NSLog macro the printf family of functions the NSAssert family of functions Macros In the process of developing an application, sections of code with logging of sensitive information (passwords, personal data, encryption keys) can get into the final version. Recommendations Changing the behavior of logging macros depending on the type of application build. Code Example: #ifdef DEBUG # define NSLog (...) NSLog(__VA_ARGS__) #else # define NSLog (...) #endif Using the OSLogPrivacy framework to differentiate the output depending on the sensitivity of the data. Code Example: @frozen struct OSLogPrivacy ... Logger().info(\"User bank account number: \\(accountNumber, privacy: .private)\") Links Poor Logging Practice | OWASP CWE-215: Insertion of Sensitive Information Into Debugging Code OSLogPrivacy","title":"Output of sensitive information into the system log"},{"location":"rg/en/ios/output_of_sensitive_information_into_the_system_log_ios/#output-of-sensitive-information-into-the-system-log","text":"Severity: HIGH Detection method: DAST, SENSITIVE INFO","title":"Output of sensitive information into the system log"},{"location":"rg/en/ios/output_of_sensitive_information_into_the_system_log_ios/#description","text":"iOS provides an option for applications to output information into a system log. Applications can send information to the system log using the following: the NSLog macro the printf family of functions the NSAssert family of functions Macros In the process of developing an application, sections of code with logging of sensitive information (passwords, personal data, encryption keys) can get into the final version.","title":"Description"},{"location":"rg/en/ios/output_of_sensitive_information_into_the_system_log_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/output_of_sensitive_information_into_the_system_log_ios/#changing-the-behavior-of-logging-macros-depending-on-the-type-of-application-build","text":"Code Example: #ifdef DEBUG # define NSLog (...) NSLog(__VA_ARGS__) #else # define NSLog (...) #endif","title":"Changing the behavior of logging macros depending on the type of application build."},{"location":"rg/en/ios/output_of_sensitive_information_into_the_system_log_ios/#using-the-oslogprivacy-framework-to-differentiate-the-output-depending-on-the-sensitivity-of-the-data","text":"Code Example: @frozen struct OSLogPrivacy ... Logger().info(\"User bank account number: \\(accountNumber, privacy: .private)\")","title":"Using the OSLogPrivacy framework to differentiate the output depending on the sensitivity of the data."},{"location":"rg/en/ios/output_of_sensitive_information_into_the_system_log_ios/#links","text":"Poor Logging Practice | OWASP CWE-215: Insertion of Sensitive Information Into Debugging Code OSLogPrivacy","title":"Links"},{"location":"rg/en/ios/presence_of_build_scripts_in_the_built_application_package_ios/","text":"Presence of build scripts in the built application package Severity: INFO Detection method: DAST, SENSITIVE INFO, FILES Description The application package contains the script files used to build the application. The presence of such files can help an attacker to determine the specifics of the build process. It may also disclose information about internal repositories (if internal components are used). Recommendations If files are not needed for operation of the application and are needed only during the build process, it is recommended to exclude them from the final build. If there is no user-defined settings file for the build, you need to create one. Add the EXCLUDED_SOURCE_FILE_NAMES setting key if it is missing. Add to the setting key value those files and folders that you want to exclude from the final application build.","title":"Presence of build scripts in the built application package"},{"location":"rg/en/ios/presence_of_build_scripts_in_the_built_application_package_ios/#presence-of-build-scripts-in-the-built-application-package","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO, FILES","title":"Presence of build scripts in the built application package"},{"location":"rg/en/ios/presence_of_build_scripts_in_the_built_application_package_ios/#description","text":"The application package contains the script files used to build the application. The presence of such files can help an attacker to determine the specifics of the build process. It may also disclose information about internal repositories (if internal components are used).","title":"Description"},{"location":"rg/en/ios/presence_of_build_scripts_in_the_built_application_package_ios/#recommendations","text":"If files are not needed for operation of the application and are needed only during the build process, it is recommended to exclude them from the final build. If there is no user-defined settings file for the build, you need to create one. Add the EXCLUDED_SOURCE_FILE_NAMES setting key if it is missing. Add to the setting key value those files and folders that you want to exclude from the final application build.","title":"Recommendations"},{"location":"rg/en/ios/presence_of_podfile_in_the_built_application_package_ios/","text":"Presence of Podfile in the built application package Severity: INFO Detection method: DAST, SENSITIVE INFO, FILES Description The application package contains a file describing the libraries used for the build. The presence of such a file can help in identifying vulnerabilities in the libraries used. It may also disclose information about internal repositories (if internal components are used). Recommendations If files are not needed for operation of the application and are needed only during the build process, it is recommended to exclude them from the final build. If there is no user-defined settings file for the build, you need to create one. Add the EXCLUDED_SOURCE_FILE_NAMES setting key if it is missing. Add to the setting key value those files and folders that you want to exclude from the final application build.","title":"Presence of Podfile in the built application package"},{"location":"rg/en/ios/presence_of_podfile_in_the_built_application_package_ios/#presence-of-podfile-in-the-built-application-package","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO, FILES","title":"Presence of Podfile in the built application package"},{"location":"rg/en/ios/presence_of_podfile_in_the_built_application_package_ios/#description","text":"The application package contains a file describing the libraries used for the build. The presence of such a file can help in identifying vulnerabilities in the libraries used. It may also disclose information about internal repositories (if internal components are used).","title":"Description"},{"location":"rg/en/ios/presence_of_podfile_in_the_built_application_package_ios/#recommendations","text":"If files are not needed for operation of the application and are needed only during the build process, it is recommended to exclude them from the final build. If there is no user-defined settings file for the build, you need to create one. Add the EXCLUDED_SOURCE_FILE_NAMES setting key if it is missing. Add to the setting key value those files and folders that you want to exclude from the final application build.","title":"Recommendations"},{"location":"rg/en/ios/readable_file_keystore_ios/","text":"A readable file keystore Severity: MEDIUM Detection method: DAST, KEY INFORMATION Description An application uses a readable file key storage. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } Showing certificates func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"A readable file keystore"},{"location":"rg/en/ios/readable_file_keystore_ios/#a-readable-file-keystore","text":"Severity: MEDIUM Detection method: DAST, KEY INFORMATION","title":"A readable file keystore"},{"location":"rg/en/ios/readable_file_keystore_ios/#description","text":"An application uses a readable file key storage. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/readable_file_keystore_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/readable_file_keystore_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/readable_file_keystore_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/readable_file_keystore_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/readable_file_keystore_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/readable_file_keystore_ios/#showing-certificates","text":"func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Showing certificates"},{"location":"rg/en/ios/readable_file_keystore_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/storage_or_use_of_previously_found_sensitive_information_ios/","text":"Storage or use of previously found sensitive information Severity: MEDIUM Detection method: DAST, API Description An application stores or uses sensitive information in its operation. During its operation, an application often handles sensitive information such as passwords, various tokens, encryption keys, etc. During the analysis of the application Mobix detects such information according to the search rules and additionally checks if the found sensitive information is stored unchanged or is used by the application in other functions or is \u201cembedded\u201c in the source code of application . Recommendations If you need to use sensitive information in the application, make sure that it is stored correctly and does not escape to public places, such as system logs. If it is necessary to store such information, it is recommended to use encryption. To ensure privacy, iOS is equipped with many cryptographic features and methods that allow iOS applications to securely encrypt and decrypt (to ensure privacy), as well as perform message authentication (MAC) and digital signatures (to verify integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following scheme: Encryption/decryption using Keychain As an example, let's consider encryption/decryption using Keychain. This mechanism allows you to generate and use keys generated in the iOS hardware key storage. This approach is the most secure in terms of key storage because the private key never appears in memory, which minimizes the risk of leakage or compromise.","title":"Storage or use of previously found sensitive information"},{"location":"rg/en/ios/storage_or_use_of_previously_found_sensitive_information_ios/#storage-or-use-of-previously-found-sensitive-information","text":"Severity: MEDIUM Detection method: DAST, API","title":"Storage or use of previously found sensitive information"},{"location":"rg/en/ios/storage_or_use_of_previously_found_sensitive_information_ios/#description","text":"An application stores or uses sensitive information in its operation. During its operation, an application often handles sensitive information such as passwords, various tokens, encryption keys, etc. During the analysis of the application Mobix detects such information according to the search rules and additionally checks if the found sensitive information is stored unchanged or is used by the application in other functions or is \u201cembedded\u201c in the source code of application .","title":"Description"},{"location":"rg/en/ios/storage_or_use_of_previously_found_sensitive_information_ios/#recommendations","text":"If you need to use sensitive information in the application, make sure that it is stored correctly and does not escape to public places, such as system logs. If it is necessary to store such information, it is recommended to use encryption. To ensure privacy, iOS is equipped with many cryptographic features and methods that allow iOS applications to securely encrypt and decrypt (to ensure privacy), as well as perform message authentication (MAC) and digital signatures (to verify integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following scheme:","title":"Recommendations"},{"location":"rg/en/ios/storage_or_use_of_previously_found_sensitive_information_ios/#encryptiondecryption-using-keychain","text":"As an example, let's consider encryption/decryption using Keychain. This mechanism allows you to generate and use keys generated in the iOS hardware key storage. This approach is the most secure in terms of key storage because the private key never appears in memory, which minimizes the risk of leakage or compromise.","title":"Encryption/decryption using Keychain"},{"location":"rg/en/ios/storing_a_key_certificate_in_the_directory_resources_of_the_application_ios/","text":"Storing a key/certificate in the directory/resources of the application Severity: INFO Detection method: DAST, SENSITIVE INFO Description The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below. Recommendations The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data. The key generation/data encryption/data decryption structure import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } } Usage let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256) Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Storing a key/certificate in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_key_certificate_in_the_directory_resources_of_the_application_ios/#storing-a-keycertificate-in-the-directoryresources-of-the-application","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Storing a key/certificate in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_key_certificate_in_the_directory_resources_of_the_application_ios/#description","text":"The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below.","title":"Description"},{"location":"rg/en/ios/storing_a_key_certificate_in_the_directory_resources_of_the_application_ios/#recommendations","text":"The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data.","title":"Recommendations"},{"location":"rg/en/ios/storing_a_key_certificate_in_the_directory_resources_of_the_application_ios/#the-key-generationdata-encryptiondata-decryption-structure","text":"import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } }","title":"The key generation/data encryption/data decryption structure"},{"location":"rg/en/ios/storing_a_key_certificate_in_the_directory_resources_of_the_application_ios/#usage","text":"let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256)","title":"Usage"},{"location":"rg/en/ios/storing_a_key_certificate_in_the_directory_resources_of_the_application_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application_ios/","text":"Storing a private key/certificate protected by a password in the directory/resources of the application Severity: LOW Detection method: DAST, SENSITIVE INFO Description The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below. Recommendations The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data. The key generation/data encryption/data decryption structure import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } } Usage let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256) Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Storing a private key/certificate protected by a password in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#storing-a-private-keycertificate-protected-by-a-password-in-the-directoryresources-of-the-application","text":"Severity: LOW Detection method: DAST, SENSITIVE INFO","title":"Storing a private key/certificate protected by a password in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#description","text":"The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below.","title":"Description"},{"location":"rg/en/ios/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#recommendations","text":"The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data.","title":"Recommendations"},{"location":"rg/en/ios/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#the-key-generationdata-encryptiondata-decryption-structure","text":"import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } }","title":"The key generation/data encryption/data decryption structure"},{"location":"rg/en/ios/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#usage","text":"let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256)","title":"Usage"},{"location":"rg/en/ios/storing_a_private_key_certificate_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application_ios/","text":"Storing a private key/certificate that is not protected by a password in the directory/resources of the application Severity: \u041a\u0420\u0418\u0422\u0418\u0427\u0415\u0421\u041a\u0418\u0419 Detection method: DAST, SENSITIVE INFO Description The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below. Recommendations The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data. The key generation/data encryption/data decryption structure import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } } Usage let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256) Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Storing a private key/certificate that is not protected by a password in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#storing-a-private-keycertificate-that-is-not-protected-by-a-password-in-the-directoryresources-of-the-application","text":"Severity: \u041a\u0420\u0418\u0422\u0418\u0427\u0415\u0421\u041a\u0418\u0419 Detection method: DAST, SENSITIVE INFO","title":"Storing a private key/certificate that is not protected by a password in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#description","text":"The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below.","title":"Description"},{"location":"rg/en/ios/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#recommendations","text":"The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data.","title":"Recommendations"},{"location":"rg/en/ios/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#the-key-generationdata-encryptiondata-decryption-structure","text":"import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } }","title":"The key generation/data encryption/data decryption structure"},{"location":"rg/en/ios/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#usage","text":"let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256)","title":"Usage"},{"location":"rg/en/ios/storing_a_private_key_certificate_that_is_not_protected_by_a_password_in_the_directory_resources_of_the_application_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/storing_a_public_key_certificate_in_the_directory_resources_of_the_application_ios/","text":"Storing a public key/certificate in the directory/resources of the application Severity: INFO Detection method: DAST, SENSITIVE INFO Description The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below. Recommendations The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data. The key generation/data encryption/data decryption structure import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } } Usage let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256) Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Storing a public key/certificate in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_public_key_certificate_in_the_directory_resources_of_the_application_ios/#storing-a-public-keycertificate-in-the-directoryresources-of-the-application","text":"Severity: INFO Detection method: DAST, SENSITIVE INFO","title":"Storing a public key/certificate in the directory/resources of the application"},{"location":"rg/en/ios/storing_a_public_key_certificate_in_the_directory_resources_of_the_application_ios/#description","text":"The system was unable to identify the type of key or certificate stored in the application's directory/resources and determine its security. However, it is recommended to additionally check where and how this key is used and to ensure that this process is secure. Approaches to the secure use and storage of keys are described below.","title":"Description"},{"location":"rg/en/ios/storing_a_public_key_certificate_in_the_directory_resources_of_the_application_ios/#recommendations","text":"The recommended way to store keys is to use Keychain. Keychain provides several basic features that greatly simplify the work with cryptographic keys: Random key generation. Secure key storage. All you need to do is: Generate a random key when you run the application for the first time. If you want to encrypt data, get the key from Keychain, encrypt the data with it, and save the encrypted data. If you want to decrypt data, get the key from Keychain and use it to decrypt the data.","title":"Recommendations"},{"location":"rg/en/ios/storing_a_public_key_certificate_in_the_directory_resources_of_the_application_ios/#the-key-generationdata-encryptiondata-decryption-structure","text":"import Foundation import CommonCrypto struct AES { // MARK: - Value // MARK: Private private let key: Data private let iv: Data // MARK: - Initialzier init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { debugPrint(\"Error: Failed to set a key.\") return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { debugPrint(\"Error: Failed to set an initial vector.\") return nil } self.key = keyData self.iv = ivData } // MARK: - Function // MARK: Public func encrypt(string: String) -> Data? { return crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -> String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -> Data? { guard let data = data else { return nil } let cryptLength = data.count + kCCBlockSizeAES128 var cryptData = Data(count: cryptLength) let keyLength = key.count let options = CCOptions(kCCOptionPKCS7Padding) var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes.baseAddress, keyLength, ivBytes.baseAddress, dataBytes.baseAddress, data.count, cryptBytes.baseAddress, cryptLength, &bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { debugPrint(\"Error: Failed to crypt data. Status \\(status)\") return nil } cryptData.removeSubrange(bytesLength..<cryptData.count) return cryptData } }","title":"The key generation/data encryption/data decryption structure"},{"location":"rg/en/ios/storing_a_public_key_certificate_in_the_directory_resources_of_the_application_ios/#usage","text":"let password = \"UserPassword1!\" let key128 = \"1234567890123456\" // 16 bytes for AES128 let key256 = \"12345678901234561234567890123456\" // 32 bytes for AES256 let iv = \"abcdefghijklmnop\" // 16 bytes for AES128 let aes128 = AES(key: key128, iv: iv) let aes256 = AES(key: key256, iv: iv) let encryptedPassword128 = aes128?.encrypt(string: password) aes128?.decrypt(data: encryptedPassword128) let encryptedPassword256 = aes256?.encrypt(string: password) aes256?.decrypt(data: encryptedPassword256)","title":"Usage"},{"location":"rg/en/ios/storing_a_public_key_certificate_in_the_directory_resources_of_the_application_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"rg/en/ios/storing_sensitive_information_in_a_private_file_ios/","text":"Storing sensitive information in a private file Severity: INFO Detection method: DAST, \u0424\u0410\u0419\u041b\u042b \u041f\u0420\u0418\u041b\u041e\u0416\u0415\u041d\u0418\u042f Description An application stores sensitive information in a private file inside the application's directory. To understand exactly what needs to be protected, you have to analyze what kind of data is being handled and stored by the application and what part of that data is confidential. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force user to enter a complex password every time the application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. Application can store data in different formats, in databases, cached network queries and many more. A value from an application's internal directory can be obtained through local or cloud backups, or by exploiting various vulnerabilities. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Recommendations Any sensitive information that is stored on the device must be encrypted. This can be done in many ways. One such way is encryption based on the keys generated in Security Enclave. Apple has put a lot of effort into making the encryption process easier and more convenient. The process of creating keys in Security Enclave: The steps for creating a private key in Secure Enclave (and the corresponding public key) are almost the same as creating a key in a regular situation: let access = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, .privateKeyUsage, nil)! // Ignore error Create a dictionary using the access control object: let attributes: [String: Any] = [ kSecAttrKeyType as String: type, kSecAttrKeySizeInBits as String: 256, kSecAttrTokenID as String: kSecAttrTokenIDSecureEnclave, kSecPrivateKeyAttrs as String: [ kSecAttrIsPermanent as String: true, kSecAttrApplicationTag as String: <# a tag #>, kSecAttrAccessControl as String: access ] ] Now that we have the dictionary, let's create a key pair in the same way as outside of Security Enclave - by calling SecKeyCreateRandomKey(): var error: Unmanaged<CFError>? guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else { throw error!.takeRetainedValue() as Error } Now you can use the created keys to encrypt or sign data. But only elliptic algorithms can be applied, since Security Enclave only supports elliptic keys: var error: Unmanaged<CFError>? guard let cipherText = SecKeyCreateEncryptedData(publicKey, algorithm, plainText as CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } This order of creation and use is described in the official documentation. You can also use wrappers to simplify all procedures, for example, the EllipticCurveKeyPair library. In addition, you can use algorithms that do not require the key storage at all, but create it \"on the fly\" from some user data (for example, from a password or pin code). Such algorithms are called the key expansion procedure. They allow you to get a long key for encryption from a small amount of information. For example, this mechanism can be used in the KEK\\&DEK (Key Encryption Key \\& Data Encryption Key) approach. This approach is easiest to show in a block diagram: \u041f\u0440\u0438\u043c\u0435\u0440\u043d\u0430\u044f \u0441\u0445\u0435\u043c\u0430 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0434\u0432\u0443\u0445 \u043a\u043b\u044e\u0447\u0435\u0439 In this approach, we first create a key for data encryption (Data Encryption Key), then encrypt the data on it and then encrypt this key with a new key (Key Encryption Key). This KEK can either be saved in the Keystore/Security Enclave or it can be generated each time (for example, based on the user's password). With this mechanism, we get rid of re-encryption of data in case the key is changed/compromised. We only need to re-encrypt DEK and not touch the data (of course, this is not the case if we have compromised DEK, but this is unlikely). In this case, no matter how much data needs to be kept secret, the encryption time will always be the same, since we do not touch the encrypted data itself. By the way, this approach is used in iPhone to encrypt data in the file system. Of course, it is much more complicated there, but the principle is exactly the same. Links https://developer.apple.com/documentation/security/keychain_services https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_secure_enclave https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/using_keys_for_encryption https://github.com/agens-no/EllipticCurveKeyPair","title":"Storing sensitive information in a private file"},{"location":"rg/en/ios/storing_sensitive_information_in_a_private_file_ios/#storing-sensitive-information-in-a-private-file","text":"Severity: INFO Detection method: DAST, \u0424\u0410\u0419\u041b\u042b \u041f\u0420\u0418\u041b\u041e\u0416\u0415\u041d\u0418\u042f","title":"Storing sensitive information in a private file"},{"location":"rg/en/ios/storing_sensitive_information_in_a_private_file_ios/#description","text":"An application stores sensitive information in a private file inside the application's directory. To understand exactly what needs to be protected, you have to analyze what kind of data is being handled and stored by the application and what part of that data is confidential. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force user to enter a complex password every time the application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. Application can store data in different formats, in databases, cached network queries and many more. A value from an application's internal directory can be obtained through local or cloud backups, or by exploiting various vulnerabilities. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected!","title":"Description"},{"location":"rg/en/ios/storing_sensitive_information_in_a_private_file_ios/#recommendations","text":"Any sensitive information that is stored on the device must be encrypted. This can be done in many ways. One such way is encryption based on the keys generated in Security Enclave. Apple has put a lot of effort into making the encryption process easier and more convenient.","title":"Recommendations"},{"location":"rg/en/ios/storing_sensitive_information_in_a_private_file_ios/#the-process-of-creating-keys-in-security-enclave","text":"The steps for creating a private key in Secure Enclave (and the corresponding public key) are almost the same as creating a key in a regular situation: let access = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, .privateKeyUsage, nil)! // Ignore error Create a dictionary using the access control object: let attributes: [String: Any] = [ kSecAttrKeyType as String: type, kSecAttrKeySizeInBits as String: 256, kSecAttrTokenID as String: kSecAttrTokenIDSecureEnclave, kSecPrivateKeyAttrs as String: [ kSecAttrIsPermanent as String: true, kSecAttrApplicationTag as String: <# a tag #>, kSecAttrAccessControl as String: access ] ] Now that we have the dictionary, let's create a key pair in the same way as outside of Security Enclave - by calling SecKeyCreateRandomKey(): var error: Unmanaged<CFError>? guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else { throw error!.takeRetainedValue() as Error } Now you can use the created keys to encrypt or sign data. But only elliptic algorithms can be applied, since Security Enclave only supports elliptic keys: var error: Unmanaged<CFError>? guard let cipherText = SecKeyCreateEncryptedData(publicKey, algorithm, plainText as CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } This order of creation and use is described in the official documentation. You can also use wrappers to simplify all procedures, for example, the EllipticCurveKeyPair library. In addition, you can use algorithms that do not require the key storage at all, but create it \"on the fly\" from some user data (for example, from a password or pin code). Such algorithms are called the key expansion procedure. They allow you to get a long key for encryption from a small amount of information. For example, this mechanism can be used in the KEK\\&DEK (Key Encryption Key \\& Data Encryption Key) approach. This approach is easiest to show in a block diagram: \u041f\u0440\u0438\u043c\u0435\u0440\u043d\u0430\u044f \u0441\u0445\u0435\u043c\u0430 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0434\u0432\u0443\u0445 \u043a\u043b\u044e\u0447\u0435\u0439 In this approach, we first create a key for data encryption (Data Encryption Key), then encrypt the data on it and then encrypt this key with a new key (Key Encryption Key). This KEK can either be saved in the Keystore/Security Enclave or it can be generated each time (for example, based on the user's password). With this mechanism, we get rid of re-encryption of data in case the key is changed/compromised. We only need to re-encrypt DEK and not touch the data (of course, this is not the case if we have compromised DEK, but this is unlikely). In this case, no matter how much data needs to be kept secret, the encryption time will always be the same, since we do not touch the encrypted data itself. By the way, this approach is used in iPhone to encrypt data in the file system. Of course, it is much more complicated there, but the principle is exactly the same.","title":"The process of creating keys in Security Enclave:"},{"location":"rg/en/ios/storing_sensitive_information_in_a_private_file_ios/#links","text":"https://developer.apple.com/documentation/security/keychain_services https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_secure_enclave https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/using_keys_for_encryption https://github.com/agens-no/EllipticCurveKeyPair","title":"Links"},{"location":"rg/en/ios/storing_sensitive_information_in_binary_cookies_ios/","text":"Storing sensitive information in Binary Cookies Severity: INFO Detection method: DAST, \u0424\u0410\u0419\u041b\u042b \u041f\u0420\u0418\u041b\u041e\u0416\u0415\u041d\u0418\u042f Description Application does not disable storage of Cookies when working with WebView . When using WebView , you need to remember that Cookies values received when visiting a web site are saved locally in a file with a special format Cookies.binarycookies . This applies to both UIWebView and WKWebView. These Cookies values can also contain sensitive data, such as session IDs or tokens for accessing a service. Recommendations For proper use, it is necessary to limit storage of Cookies to the time of their use. Usually when you close WebView this data is no longer needed. Better yet, disable Cookies altogether. Below is an example with storage disabled: import UIKit import WebKit class ViewController: UIViewController, WKUIDelegate { var webView: WKWebView! override func loadView() let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.uiDelegate = self view = webView } override func viewDidLoad() { super.viewDidLoad() let myURL = URL(string: \"http://example.com\") var myRequest = URLRequest(url: myURL!) myRequest.httpShouldHandleCookies = false webView.load(myRequest) } } To delete Cookie values (e.g. when logging out of an application or closing/opening it): let storage = HTTPCookieStorage.shared if let cookies = storage.cookies{ for cookie in cookies { storage.deleteCookie(cookie) } } Links https://book.hacktricks.xyz/mobile-apps-pentesting/ios-pentesting#cookies https://developer.apple.com/forums/thread/81874","title":"Storing sensitive information in Binary Cookies"},{"location":"rg/en/ios/storing_sensitive_information_in_binary_cookies_ios/#storing-sensitive-information-in-binary-cookies","text":"Severity: INFO Detection method: DAST, \u0424\u0410\u0419\u041b\u042b \u041f\u0420\u0418\u041b\u041e\u0416\u0415\u041d\u0418\u042f","title":"Storing sensitive information in Binary Cookies"},{"location":"rg/en/ios/storing_sensitive_information_in_binary_cookies_ios/#description","text":"Application does not disable storage of Cookies when working with WebView . When using WebView , you need to remember that Cookies values received when visiting a web site are saved locally in a file with a special format Cookies.binarycookies . This applies to both UIWebView and WKWebView. These Cookies values can also contain sensitive data, such as session IDs or tokens for accessing a service.","title":"Description"},{"location":"rg/en/ios/storing_sensitive_information_in_binary_cookies_ios/#recommendations","text":"For proper use, it is necessary to limit storage of Cookies to the time of their use. Usually when you close WebView this data is no longer needed. Better yet, disable Cookies altogether. Below is an example with storage disabled: import UIKit import WebKit class ViewController: UIViewController, WKUIDelegate { var webView: WKWebView! override func loadView() let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.uiDelegate = self view = webView } override func viewDidLoad() { super.viewDidLoad() let myURL = URL(string: \"http://example.com\") var myRequest = URLRequest(url: myURL!) myRequest.httpShouldHandleCookies = false webView.load(myRequest) } } To delete Cookie values (e.g. when logging out of an application or closing/opening it): let storage = HTTPCookieStorage.shared if let cookies = storage.cookies{ for cookie in cookies { storage.deleteCookie(cookie) } }","title":"Recommendations"},{"location":"rg/en/ios/storing_sensitive_information_in_binary_cookies_ios/#links","text":"https://book.hacktricks.xyz/mobile-apps-pentesting/ios-pentesting#cookies https://developer.apple.com/forums/thread/81874","title":"Links"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/","text":"Storing sensitive information in NSUserDefaults Severity: MEDIUM Detection method: DAST, \u0424\u0410\u0419\u041b\u042b \u041f\u0420\u0418\u041b\u041e\u0416\u0415\u041d\u0418\u042f Description An application stores sensitive information in a private file inside the application's directory. To understand exactly what needs to be protected, you have to analyze what kind of data is being handled and stored by the application and what part of that data is confidential. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force user to enter a complex password every time the application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. Application can store data in different formats, one of which is NSUserDefaults. NSUserDefaults is designed to store relatively small amounts of frequently requested and rarely modified data. Other ways of using it may result in slower performance or more memory consumption than more appropriate solutions. Storing sensitive data using the NSUserDefaults mechanism in a public domain is not recommended. Since its physical representation is just a file in the file system of the device, located inside the application directory at the relative path /Library/Preferences/com.yourcompany.appName.plist . Values from this file can be obtained through local or cloud backups, or by exploiting various vulnerabilities. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected! Recommendations Any sensitive information that is stored on the device must be encrypted. This can be done in many ways. One of them is encryption based on a key derived from user data (password, pin code, etc.) using key strengthening algorithms ( Key Stretching ). This allows you to get an encryption key from a fairly simple password by applying the hash function to it several times along with a salt. The salt is a certain sequence of random data. A common mistake is to exclude salt from the algorithm. Salt gives the key much more entropy. Without it, it is much easier to retrieve/recover/find the key. Moreover, without using salt, two identical passwords will have the same hash value and, consequently, the same final encryption key value. In this case, since the key strengthening algorithm is used, there is no need to store the key somewhere. Each time the need for a key arises, it is enough to use the user's data to generate it. To encrypt and decrypt use the CCCrypt function with kCCEncrypt or kCCDecrypt . Since a block cipher is used, it is necessary to pad the message if it does not match the multiplicity of the block size. Using the KCCOptionPKCS7Padding parameter, define the padding type as PKCS7: Encryption class func encryptData(_ clearTextData : Data, withPassword password : String) -> Dictionary<String, Data> { var setupSuccess = true var outDictionary = Dictionary<String, Data>.init() var key = Data(repeating:0, count:kCCKeySizeAES256) var salt = Data(count: 8) salt.withUnsafeMutableBytes { (saltBytes: UnsafeMutablePointer<UInt8>) -> Void in let saltStatus = SecRandomCopyBytes(kSecRandomDefault, salt.count, saltBytes) if saltStatus == errSecSuccess { let passwordData = password.data(using:String.Encoding.utf8)! key.withUnsafeMutableBytes { (keyBytes : UnsafeMutablePointer<UInt8>) in let derivationStatus = CCKeyDerivationPBKDF(CCPBKDFAlgorithm(kCCPBKDF2), password, passwordData.count, saltBytes, salt.count, CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA512), 14271, keyBytes, key.count) if derivationStatus != Int32(kCCSuccess) { setupSuccess = false } } } else { setupSuccess = false } } var iv = Data.init(count: kCCBlockSizeAES128) iv.withUnsafeMutableBytes { (ivBytes : UnsafeMutablePointer<UInt8>) in let ivStatus = SecRandomCopyBytes(kSecRandomDefault, kCCBlockSizeAES128, ivBytes) if ivStatus != errSecSuccess { setupSuccess = false } } if (setupSuccess) { var numberOfBytesEncrypted : size_t = 0 let size = clearTextData.count + kCCBlockSizeAES128 var encrypted = Data.init(count: size) let cryptStatus = iv.withUnsafeBytes {ivBytes in encrypted.withUnsafeMutableBytes {encryptedBytes in clearTextData.withUnsafeBytes {clearTextBytes in key.withUnsafeBytes {keyBytes in CCCrypt(CCOperation(kCCEncrypt), CCAlgorithm(kCCAlgorithmAES), CCOptions(kCCOptionPKCS7Padding + kCCModeCBC), keyBytes, key.count, ivBytes, clearTextBytes, clearTextData.count, encryptedBytes, size, &numberOfBytesEncrypted) } } } } if cryptStatus == Int32(kCCSuccess) { encrypted.count = numberOfBytesEncrypted outDictionary[\"EncryptionData\"] = encrypted outDictionary[\"EncryptionIV\"] = iv outDictionary[\"EncryptionSalt\"] = salt } } return outDictionary; } And, accordingly, the decryption function: Decryption class func decryp(fromDictionary dictionary : Dictionary<String, Data>, withPassword password : String) -> Data { var setupSuccess = true let encrypted = dictionary[\"EncryptionData\"] let iv = dictionary[\"EncryptionIV\"] let salt = dictionary[\"EncryptionSalt\"] var key = Data(repeating:0, count:kCCKeySizeAES256) salt?.withUnsafeBytes { (saltBytes: UnsafePointer<UInt8>) -> Void in let passwordData = password.data(using:String.Encoding.utf8)! key.withUnsafeMutableBytes { (keyBytes : UnsafeMutablePointer<UInt8>) in let derivationStatus = CCKeyDerivationPBKDF(CCPBKDFAlgorithm(kCCPBKDF2), password, passwordData.count, saltBytes, salt!.count, CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA512), 14271, keyBytes, key.count) if derivationStatus != Int32(kCCSuccess) { setupSuccess = false } } } var decryptSuccess = false let size = (encrypted?.count)! + kCCBlockSizeAES128 var clearTextData = Data.init(count: size) if (setupSuccess) { var numberOfBytesDecrypted : size_t = 0 let cryptStatus = iv?.withUnsafeBytes {ivBytes in clearTextData.withUnsafeMutableBytes {clearTextBytes in encrypted?.withUnsafeBytes {encryptedBytes in key.withUnsafeBytes {keyBytes in CCCrypt(CCOperation(kCCDecrypt), CCAlgorithm(kCCAlgorithmAES128), CCOptions(kCCOptionPKCS7Padding + kCCModeCBC), keyBytes, key.count, ivBytes, encryptedBytes, (encrypted?.count)!, clearTextBytes, size, &numberOfBytesDecrypted) } } } } if cryptStatus! == Int32(kCCSuccess) { clearTextData.count = numberOfBytesDecrypted decryptSuccess = true } } return decryptSuccess ? clearTextData : Data.init(count: 0) } To verify that these functions work and that the encryption/decryption is correct, you can use a simple example: Example class func encryptionTest() { let clearTextData = \"some clear text to encrypt\".data(using:String.Encoding.utf8)! let dictionary = encryptData(clearTextData, withPassword: \"123456\") let decrypted = decryp(fromDictionary: dictionary, withPassword: \"123456\") let decryptedString = String(data: decrypted, encoding: String.Encoding.utf8) print(\"decrypted cleartext result - \", decryptedString ?? \"Error: Could not convert data to string\") } In this example, we package all the necessary information and return it as a dictionary, so that all the pieces can later be used to successfully decrypt data. This requires storing initialization vector (IV) and salt either in Keychain or on the server. Links https://developer.apple.com/ https://en.wikipedia.org/wiki/Key_stretching https://en.wikipedia.org/wiki/PBKDF2 https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7","title":"Storing sensitive information in NSUserDefaults"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/#storing-sensitive-information-in-nsuserdefaults","text":"Severity: MEDIUM Detection method: DAST, \u0424\u0410\u0419\u041b\u042b \u041f\u0420\u0418\u041b\u041e\u0416\u0415\u041d\u0418\u042f","title":"Storing sensitive information in NSUserDefaults"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/#description","text":"An application stores sensitive information in a private file inside the application's directory. To understand exactly what needs to be protected, you have to analyze what kind of data is being handled and stored by the application and what part of that data is confidential. In such a situation, it is common to rely on legislation and common sense. There is no point in encrypting absolutely all the information the application stores. This can affect speed and stability of the application. Instead, you should clearly define what exactly is sensitive data for your application or company, and focus your attention on that data. It is generally assumed that as few confidential information as possible should be stored in a local storage (both internal and external). However, in most cases storing such information cannot be avoided. For example, in terms of usability, you should not force user to enter a complex password every time the application is launched. Most applications have to cache some authentication token locally. Personally identifiable information (PII) and other types of confidential data could also be retained if a specific scenario calls for it. Application can store data in different formats, one of which is NSUserDefaults. NSUserDefaults is designed to store relatively small amounts of frequently requested and rarely modified data. Other ways of using it may result in slower performance or more memory consumption than more appropriate solutions. Storing sensitive data using the NSUserDefaults mechanism in a public domain is not recommended. Since its physical representation is just a file in the file system of the device, located inside the application directory at the relative path /Library/Preferences/com.yourcompany.appName.plist . Values from this file can be obtained through local or cloud backups, or by exploiting various vulnerabilities. !!! note \"Note!\" Very often it is mistakenly thought that the data stored in the internal directory of an application is already protected by the sandbox mechanism and an attacker cannot get to it. There are many ways, ranging from a simple local or cloud-based application backup to physical access to the device and exploitation of various vulnerabilities. Plain text information put into the application's directory is not protected!","title":"Description"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/#recommendations","text":"Any sensitive information that is stored on the device must be encrypted. This can be done in many ways. One of them is encryption based on a key derived from user data (password, pin code, etc.) using key strengthening algorithms ( Key Stretching ). This allows you to get an encryption key from a fairly simple password by applying the hash function to it several times along with a salt. The salt is a certain sequence of random data. A common mistake is to exclude salt from the algorithm. Salt gives the key much more entropy. Without it, it is much easier to retrieve/recover/find the key. Moreover, without using salt, two identical passwords will have the same hash value and, consequently, the same final encryption key value. In this case, since the key strengthening algorithm is used, there is no need to store the key somewhere. Each time the need for a key arises, it is enough to use the user's data to generate it. To encrypt and decrypt use the CCCrypt function with kCCEncrypt or kCCDecrypt . Since a block cipher is used, it is necessary to pad the message if it does not match the multiplicity of the block size. Using the KCCOptionPKCS7Padding parameter, define the padding type as PKCS7:","title":"Recommendations"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/#encryption","text":"class func encryptData(_ clearTextData : Data, withPassword password : String) -> Dictionary<String, Data> { var setupSuccess = true var outDictionary = Dictionary<String, Data>.init() var key = Data(repeating:0, count:kCCKeySizeAES256) var salt = Data(count: 8) salt.withUnsafeMutableBytes { (saltBytes: UnsafeMutablePointer<UInt8>) -> Void in let saltStatus = SecRandomCopyBytes(kSecRandomDefault, salt.count, saltBytes) if saltStatus == errSecSuccess { let passwordData = password.data(using:String.Encoding.utf8)! key.withUnsafeMutableBytes { (keyBytes : UnsafeMutablePointer<UInt8>) in let derivationStatus = CCKeyDerivationPBKDF(CCPBKDFAlgorithm(kCCPBKDF2), password, passwordData.count, saltBytes, salt.count, CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA512), 14271, keyBytes, key.count) if derivationStatus != Int32(kCCSuccess) { setupSuccess = false } } } else { setupSuccess = false } } var iv = Data.init(count: kCCBlockSizeAES128) iv.withUnsafeMutableBytes { (ivBytes : UnsafeMutablePointer<UInt8>) in let ivStatus = SecRandomCopyBytes(kSecRandomDefault, kCCBlockSizeAES128, ivBytes) if ivStatus != errSecSuccess { setupSuccess = false } } if (setupSuccess) { var numberOfBytesEncrypted : size_t = 0 let size = clearTextData.count + kCCBlockSizeAES128 var encrypted = Data.init(count: size) let cryptStatus = iv.withUnsafeBytes {ivBytes in encrypted.withUnsafeMutableBytes {encryptedBytes in clearTextData.withUnsafeBytes {clearTextBytes in key.withUnsafeBytes {keyBytes in CCCrypt(CCOperation(kCCEncrypt), CCAlgorithm(kCCAlgorithmAES), CCOptions(kCCOptionPKCS7Padding + kCCModeCBC), keyBytes, key.count, ivBytes, clearTextBytes, clearTextData.count, encryptedBytes, size, &numberOfBytesEncrypted) } } } } if cryptStatus == Int32(kCCSuccess) { encrypted.count = numberOfBytesEncrypted outDictionary[\"EncryptionData\"] = encrypted outDictionary[\"EncryptionIV\"] = iv outDictionary[\"EncryptionSalt\"] = salt } } return outDictionary; } And, accordingly, the decryption function:","title":"Encryption"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/#decryption","text":"class func decryp(fromDictionary dictionary : Dictionary<String, Data>, withPassword password : String) -> Data { var setupSuccess = true let encrypted = dictionary[\"EncryptionData\"] let iv = dictionary[\"EncryptionIV\"] let salt = dictionary[\"EncryptionSalt\"] var key = Data(repeating:0, count:kCCKeySizeAES256) salt?.withUnsafeBytes { (saltBytes: UnsafePointer<UInt8>) -> Void in let passwordData = password.data(using:String.Encoding.utf8)! key.withUnsafeMutableBytes { (keyBytes : UnsafeMutablePointer<UInt8>) in let derivationStatus = CCKeyDerivationPBKDF(CCPBKDFAlgorithm(kCCPBKDF2), password, passwordData.count, saltBytes, salt!.count, CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA512), 14271, keyBytes, key.count) if derivationStatus != Int32(kCCSuccess) { setupSuccess = false } } } var decryptSuccess = false let size = (encrypted?.count)! + kCCBlockSizeAES128 var clearTextData = Data.init(count: size) if (setupSuccess) { var numberOfBytesDecrypted : size_t = 0 let cryptStatus = iv?.withUnsafeBytes {ivBytes in clearTextData.withUnsafeMutableBytes {clearTextBytes in encrypted?.withUnsafeBytes {encryptedBytes in key.withUnsafeBytes {keyBytes in CCCrypt(CCOperation(kCCDecrypt), CCAlgorithm(kCCAlgorithmAES128), CCOptions(kCCOptionPKCS7Padding + kCCModeCBC), keyBytes, key.count, ivBytes, encryptedBytes, (encrypted?.count)!, clearTextBytes, size, &numberOfBytesDecrypted) } } } } if cryptStatus! == Int32(kCCSuccess) { clearTextData.count = numberOfBytesDecrypted decryptSuccess = true } } return decryptSuccess ? clearTextData : Data.init(count: 0) } To verify that these functions work and that the encryption/decryption is correct, you can use a simple example:","title":"Decryption"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/#example","text":"class func encryptionTest() { let clearTextData = \"some clear text to encrypt\".data(using:String.Encoding.utf8)! let dictionary = encryptData(clearTextData, withPassword: \"123456\") let decrypted = decryp(fromDictionary: dictionary, withPassword: \"123456\") let decryptedString = String(data: decrypted, encoding: String.Encoding.utf8) print(\"decrypted cleartext result - \", decryptedString ?? \"Error: Could not convert data to string\") } In this example, we package all the necessary information and return it as a dictionary, so that all the pieces can later be used to successfully decrypt data. This requires storing initialization vector (IV) and salt either in Keychain or on the server.","title":"Example"},{"location":"rg/en/ios/storing_sensitive_information_in_nsuserdefaults_ios/#links","text":"https://developer.apple.com/ https://en.wikipedia.org/wiki/Key_stretching https://en.wikipedia.org/wiki/PBKDF2 https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7","title":"Links"},{"location":"rg/en/ios/storing_sensitive_information_in_the_application_source_code_ios/","text":"Storing sensitive information in the application source code Severity: CRITICAL Detection method: DAST, FILES Description The application stores sensitive information in its source code. It is often wrongly assumed that the data that is embedded in the source code of applications is protected and inaccessible after compilation and obfuscation. However, in a decompiled application, all string resources remain unchanged. Any sensitive information located in the source code of the application will be available to malefactors. It is not recommended to store in the source code any information that could help an attacker. This applies to any tokens, passwords, encryption keys, and data used for testing - test bench addresses, test credentials, etc. Such information reveals the inside structure of test benches and can be used in the future. Recommendations Although it is a time-consuming task in iOS to restore the source code from an application package, static data (strings, constants, numbers) are stored in open form and can easily be read from an executable file. If you need to store confidential information, the source code is not the best place to do it. It is recommended to get such information from the server and store it encrypted on the device, if necessary. iOS is equipped with many cryptographic features and methods to ensure data privacy. With these, iOS applications can securely perform encryption and decryption (to ensure privacy) as well as message authentication (MAC) and digital signatures (to verify integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following scheme: Links Data Storage on iOS CWE - CWE-200: Exposure of Sensitive Information to an Unauthorized Actor (4.5) CWE - CWE-311: Missing Encryption of Sensitive Data (4.5) CWE - CWE-312: Cleartext Storage of Sensitive Information (4.5) Xcode secure information","title":"Storing sensitive information in the application source code"},{"location":"rg/en/ios/storing_sensitive_information_in_the_application_source_code_ios/#storing-sensitive-information-in-the-application-source-code","text":"Severity: CRITICAL Detection method: DAST, FILES","title":"Storing sensitive information in the application source code"},{"location":"rg/en/ios/storing_sensitive_information_in_the_application_source_code_ios/#description","text":"The application stores sensitive information in its source code. It is often wrongly assumed that the data that is embedded in the source code of applications is protected and inaccessible after compilation and obfuscation. However, in a decompiled application, all string resources remain unchanged. Any sensitive information located in the source code of the application will be available to malefactors. It is not recommended to store in the source code any information that could help an attacker. This applies to any tokens, passwords, encryption keys, and data used for testing - test bench addresses, test credentials, etc. Such information reveals the inside structure of test benches and can be used in the future.","title":"Description"},{"location":"rg/en/ios/storing_sensitive_information_in_the_application_source_code_ios/#recommendations","text":"Although it is a time-consuming task in iOS to restore the source code from an application package, static data (strings, constants, numbers) are stored in open form and can easily be read from an executable file. If you need to store confidential information, the source code is not the best place to do it. It is recommended to get such information from the server and store it encrypted on the device, if necessary. iOS is equipped with many cryptographic features and methods to ensure data privacy. With these, iOS applications can securely perform encryption and decryption (to ensure privacy) as well as message authentication (MAC) and digital signatures (to verify integrity). To choose an encryption method and key type suitable for the given conditions, you can use the following scheme:","title":"Recommendations"},{"location":"rg/en/ios/storing_sensitive_information_in_the_application_source_code_ios/#links","text":"Data Storage on iOS CWE - CWE-200: Exposure of Sensitive Information to an Unauthorized Actor (4.5) CWE - CWE-311: Missing Encryption of Sensitive Data (4.5) CWE - CWE-312: Cleartext Storage of Sensitive Information (4.5) Xcode secure information","title":"Links"},{"location":"rg/en/ios/storing_sensitive_information_in_the_keyboard_cache_ios/","text":"Storing sensitive information in the keyboard cache Severity: MEDIUM Detection method: DAST, SENSITIVE INFO Description iOS has a mechanism to auto-complete words that the user enters in the text fields. In this case, if iOS does not know the word the user enters, it can cache the word (or prompt the user to add the word to the dictionary). This feature can be very useful for messenger applications, for example. However, the keyboard cache may disclose sensitive information if it is used to enter such information (credit card data, login, password or personal user information). Recommendations The autocorrectionType parameter in the UITextField object field is responsible for enabling or disabling the auto-complete option. Code Example: UITextField *textField = [[UITextField alloc] initWithFrame:frame]; textField.autocorrectionType = UITextAutocorrectionTypeNo; All input fields for sensitive information must be marked with the secureTextEntry parameter. Code Example: UITextField *textField = [[UITextField alloc] initWithFrame:frame]; textField.secureTextEntry = YES; It is recommended to use implementation of the custom keyboard for entering all sensitive data with caching of all input data disabled. It is also necessary to prohibit copying the entered information to the clipboard to access it from other applications. Code Example: - (BOOL)canPerformAction:(SEL)action withSender:(id)sender { UIMenuController *menuController = [UIMenuController sharedMenuController]; if (menuController) { menuController.menuVisible = NO; } return NO; } Links https://develoler.apple.com OWASP Mobile Top 10 owasp-mstg/0x05d-Testing-Data-Storage.md at master \u00b7 OWASP/owasp-mstg CWE - CWE-200: Exposure of Sensitive Information to an Unauthorized Actor (4.5) Custom keyboard Cache keyboard review","title":"Storing sensitive information in the keyboard cache"},{"location":"rg/en/ios/storing_sensitive_information_in_the_keyboard_cache_ios/#storing-sensitive-information-in-the-keyboard-cache","text":"Severity: MEDIUM Detection method: DAST, SENSITIVE INFO","title":"Storing sensitive information in the keyboard cache"},{"location":"rg/en/ios/storing_sensitive_information_in_the_keyboard_cache_ios/#description","text":"iOS has a mechanism to auto-complete words that the user enters in the text fields. In this case, if iOS does not know the word the user enters, it can cache the word (or prompt the user to add the word to the dictionary). This feature can be very useful for messenger applications, for example. However, the keyboard cache may disclose sensitive information if it is used to enter such information (credit card data, login, password or personal user information).","title":"Description"},{"location":"rg/en/ios/storing_sensitive_information_in_the_keyboard_cache_ios/#recommendations","text":"The autocorrectionType parameter in the UITextField object field is responsible for enabling or disabling the auto-complete option. Code Example: UITextField *textField = [[UITextField alloc] initWithFrame:frame]; textField.autocorrectionType = UITextAutocorrectionTypeNo; All input fields for sensitive information must be marked with the secureTextEntry parameter. Code Example: UITextField *textField = [[UITextField alloc] initWithFrame:frame]; textField.secureTextEntry = YES; It is recommended to use implementation of the custom keyboard for entering all sensitive data with caching of all input data disabled. It is also necessary to prohibit copying the entered information to the clipboard to access it from other applications. Code Example: - (BOOL)canPerformAction:(SEL)action withSender:(id)sender { UIMenuController *menuController = [UIMenuController sharedMenuController]; if (menuController) { menuController.menuVisible = NO; } return NO; }","title":"Recommendations"},{"location":"rg/en/ios/storing_sensitive_information_in_the_keyboard_cache_ios/#links","text":"https://develoler.apple.com OWASP Mobile Top 10 owasp-mstg/0x05d-Testing-Data-Storage.md at master \u00b7 OWASP/owasp-mstg CWE - CWE-200: Exposure of Sensitive Information to an Unauthorized Actor (4.5) Custom keyboard Cache keyboard review","title":"Links"},{"location":"rg/en/ios/using_a_file_keystore_ios/","text":"Using a file keystore Severity: LOW Detection method: DAST, KEY INFORMATION Description An application uses a file key storage. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application. Recommendations Adding a new key into Keychain import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey() Saving a new key in Keychain enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) } Reading a key from Keychain func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) } Using a key for encryption and decryption let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error } Showing certificates func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString } Links https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Using a file keystore"},{"location":"rg/en/ios/using_a_file_keystore_ios/#using-a-file-keystore","text":"Severity: LOW Detection method: DAST, KEY INFORMATION","title":"Using a file keystore"},{"location":"rg/en/ios/using_a_file_keystore_ios/#description","text":"An application uses a file key storage. This can lead to a forgery of key information. An encryption key must not be stored in a location with public access. When using cryptographic operations on a device, you need to ensure maximum security of the main secret in such operations - the encryption key. When using asymmetric encryption, you need to store the private key securely; for symmetric algorithms, though, you need to protect the key that is used both for encryption and decryption of sensitive information. The most secure option, without a doubt, is to store keys in Keychain. Compromising key information in an application could be catastrophic depending on where in the application this information is used \u2014 starting with decryption of files or traffic, to compromising a private key that functions as a signature of the application.","title":"Description"},{"location":"rg/en/ios/using_a_file_keystore_ios/#recommendations","text":"","title":"Recommendations"},{"location":"rg/en/ios/using_a_file_keystore_ios/#adding-a-new-key-into-keychain","text":"import Foundation import Security func computeSymmetricKey() -> String? { var keyData = Data(count: 32) // 32 bytes === 256 bits let result = keyData.withUnsafeMutableBytes { (mutableBytes: UnsafeMutablePointer) -> Int32 in SecRandomCopyBytes(kSecRandomDefault, keyData.count, mutableBytes) } if result == errSecSuccess { return keyData.base64EncodedString() } else { return nil } } let secretKey = computeSymmetricKey()","title":"Adding a new key into Keychain"},{"location":"rg/en/ios/using_a_file_keystore_ios/#saving-a-new-key-in-keychain","text":"enum KeychainErrors:Error { case COULDNOTINSERT case COULDNOTREAD } func store (key: String, withTag: String) throws { let fromKey = key.data(using: .utf8)! let query: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: withTag, kSecValueRef as String: fromKey ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainErrors.COULDNOTINSERT } } do { try store(key: secretKey!, withTag: \"com.myapp.keys.localStore\") } catch { print(error) }","title":"Saving a new key in Keychain"},{"location":"rg/en/ios/using_a_file_keystore_ios/#reading-a-key-from-keychain","text":"func read (tag: String) throws -> CFTypeRef { let readQuery: [String: Any] = [ kSecClass as String: kSecClassKey, kSecAttrApplicationTag as String: tag, kSecAttrKeyType as String: kSecAttrKeyTypeRSA, kSecReturnRef as String: true ] var item: CFTypeRef? let readStatus = SecItemCopyMatching(readQuery as CFDictionary, &item) guard readStatus == errSecSuccess else { throw KeychainErrors.COULDNOTREAD } return item! } do { let keyReadFromKeychain = try read(tag: \"com.myapp.keys.localStore\") print(keyReadFromKeychain) } catch { print(error) }","title":"Reading a key from Keychain"},{"location":"rg/en/ios/using_a_file_keystore_ios/#using-a-key-for-encryption-and-decryption","text":"let algorithm: SecKeyAlgorithm = .rsaEncryptionOAEPSHA256 let plainText = \"this is our golden secret. Encrypt it!\" var error: Unmanaged? guard let cipherText = SecKeyCreateEncryptedData(secretKey as! SecKey, algorithm, plainText as! CFData, &error) as Data? else { throw error!.takeRetainedValue() as Error }","title":"Using a key for encryption and decryption"},{"location":"rg/en/ios/using_a_file_keystore_ios/#showing-certificates","text":"func showCertificateInfo() -> String { var resultString = \"--- Certificates in Keychain ---\\n\" var outputACert = false let query = [kSecMatchLimit: kSecMatchLimitAll, kSecReturnRef: true, kSecClass: kSecClassCertificate] as CFDictionary var result: CFTypeRef? let resultCode = SecItemCopyMatching(query, &result) if resultCode == errSecSuccess { if CFArrayGetTypeID() == CFGetTypeID(result) { let array = (result as? NSArray) as? [SecCertificate] array?.forEach { (item) in resultString += self.displayCertificate(item) outputACert = true } } else { // swiftlint:disable force_cast resultString += self.displayCertificate(result as! SecCertificate) // swiftlint:enable force_cast outputACert = true } } if !outputACert { resultString += \"None\\n\" } resultString += \"-------------------------------\" return resultString }","title":"Showing certificates"},{"location":"rg/en/ios/using_a_file_keystore_ios/#links","text":"https://developer.apple.com/ CertificateSDK Certificates Keychain Services Basic iOS Security: Keychain and Hashing","title":"Links"},{"location":"ug/","text":"User Manual Note This manual describes how users work with Mobix through the user interface. Before users can start working, the system has to be configured by a user with the Administrator role in Mobix. See the \" Settings \" section for more information.","title":"User Manual"},{"location":"ug/#user-manual","text":"Note This manual describes how users work with Mobix through the user interface. Before users can start working, the system has to be configured by a user with the Administrator role in Mobix. See the \" Settings \" section for more information.","title":"User Manual"},{"location":"ug/documentation_and_recommendations/","text":"Documentation and Recommendations The system contains built-in documentation and recommendations on how to fix vulnerabilities. These are available without Internet if the system is installed on-premises. Hover over the Help main menu item in the upper right corner and select required section from the drop-down menu.","title":"Documentation and Recommendations"},{"location":"ug/documentation_and_recommendations/#documentation-and-recommendations","text":"The system contains built-in documentation and recommendations on how to fix vulnerabilities. These are available without Internet if the system is installed on-premises. Hover over the Help main menu item in the upper right corner and select required section from the drop-down menu.","title":"Documentation and Recommendations"},{"location":"ug/main_menu/","text":"Main Menu At the top of UI there is a main menu, which includes the following items: Projects , Scans , Test Cases , Help .","title":"Main Menu"},{"location":"ug/main_menu/#main-menu","text":"At the top of UI there is a main menu, which includes the following items: Projects , Scans , Test Cases , Help .","title":"Main Menu"},{"location":"ug/profile/","text":"Profiles Clicking on the profile name on the Projects page or on the Profiles tab of the project information page opens the profile page with detailed information about it. On the profile page you can get information about settings of scanning modules in this profile, enable, disable or configure them. You can also view and enable or disable security standards that the application analyzed by this profile is checked to comply with. At the top of the page you can find general information about the profile: Profile name. Project that the profile belongs to. Number of scans performed with the profile. Number of defects found during the lifetime of the profile. There are two tabs on this page: Modules and Standards . Their detailed description is given below in this section. Adding / Editing / Deleting a Profile Scan profiles are related to projects. The Projects page shows all existing projects in the system and their scan profiles. Each profile is presented as a card with brief information about it. For each project, a list of its profiles is displayed. On this page you can add a new scan profile for an existing project or view information about existing profiles. To add a new profile to the project, click the Add profile button on the right side of the project field. In the Add profile window that appears, enter the name of the profile and a short description, and then click the Add button in the lower right corner. The newly created profile will appear in the list of project profiles. To edit or delete a profile, click its name on the Projects page. A page with detailed information about the profile will appear. To edit the profile settings, click the Change button at the top right. In the window that appears, you can change profile name and description: To delete a profile, click the Delete button at the top right and confirm the action by clicking the Delete button in the dialog box that appears. You can add, delete and edit a profile in two ways. Lets consider the second way. The Projects page displays the project names and the list of profiles for each project. Clicking on the project name opens the Project page with the Profiles , Rules , and Access tabs. On the Profiles tab, you can add a new profile by clicking the Add profile button. In the Add profile window that appears, enter the name of the profile and a short description and click the Add button in the lower right corner of the window. The newly created profile will appear in the list of project profiles. Click the profile card in the profile list to change profile information or delete a profile. This profile page opens. Editing and deleting a profile on the profile page is described earlier in this section. Modules This tab contains settings for modules that collect information about the application for further analysis. This tab allows you to enable or disable a specific module and make the necessary settings. The system includes twenty scanning modules. A list of all modules is presented on the Modules tab on the profile page. In this list, you can select and configure the modules to be enabled when scanning an application with this profile. Further analysis and search for application vulnerabilities will be performed based on the data collected during the scan. To work effectively with the application it is possible to enable or disable each module and make the necessary settings. You can enable or disable the module using the selector to the right of its name. All enabled modules have selector in the enabled position , all disabled modules have selector in the disabled position . To change the module status from \"enabled\" to \"disabled\" and vice versa, just click the module selector. There are a number of specific settings for each module. When you select a module from the list of modules on the left side of the tab, its settings are displayed on the right side of the tab. You can change and save them by clicking the Change button at the bottom of the tab. The settings for each module include: * Name of the module. * Description of the module. * List of modules that affect the operation of this module. * Module Settings that can be configured (if applicable to this module - some modules do not have configurable settings). Some modules depend on the results of other modules. This is indicated in the list of modules on the left side by the additional information at the bottom of the module name, see figure below. If all \"parent\" modules are disabled, the module that depends on them will also be automatically disabled. Standards This tab is for managing the information security standards used by the profile to check the application. The Standards tab of the company page lists information security standards and their requirements. An application can be checked for compliance with these information security requirements. A list of all standards and requirements is also presented on the Standards tab on the profile page. In this list you can select the standards against which the results of testing an application with this profile will be checked. The list of requirements included in the standard is presented on the right. The system allows to enable or disable information security standard compliance check. The selector is in the on position for all standards enabled for checking and in the off position for all standards disabled. To change the standard status from \"enabled\" to \"disabled\" and vice versa, just click the standard selector. '","title":"Profiles"},{"location":"ug/profile/#profiles","text":"Clicking on the profile name on the Projects page or on the Profiles tab of the project information page opens the profile page with detailed information about it. On the profile page you can get information about settings of scanning modules in this profile, enable, disable or configure them. You can also view and enable or disable security standards that the application analyzed by this profile is checked to comply with. At the top of the page you can find general information about the profile: Profile name. Project that the profile belongs to. Number of scans performed with the profile. Number of defects found during the lifetime of the profile. There are two tabs on this page: Modules and Standards . Their detailed description is given below in this section.","title":"Profiles"},{"location":"ug/profile/#adding-editing-deleting-a-profile","text":"Scan profiles are related to projects. The Projects page shows all existing projects in the system and their scan profiles. Each profile is presented as a card with brief information about it. For each project, a list of its profiles is displayed. On this page you can add a new scan profile for an existing project or view information about existing profiles. To add a new profile to the project, click the Add profile button on the right side of the project field. In the Add profile window that appears, enter the name of the profile and a short description, and then click the Add button in the lower right corner. The newly created profile will appear in the list of project profiles. To edit or delete a profile, click its name on the Projects page. A page with detailed information about the profile will appear. To edit the profile settings, click the Change button at the top right. In the window that appears, you can change profile name and description: To delete a profile, click the Delete button at the top right and confirm the action by clicking the Delete button in the dialog box that appears. You can add, delete and edit a profile in two ways. Lets consider the second way. The Projects page displays the project names and the list of profiles for each project. Clicking on the project name opens the Project page with the Profiles , Rules , and Access tabs. On the Profiles tab, you can add a new profile by clicking the Add profile button. In the Add profile window that appears, enter the name of the profile and a short description and click the Add button in the lower right corner of the window. The newly created profile will appear in the list of project profiles. Click the profile card in the profile list to change profile information or delete a profile. This profile page opens. Editing and deleting a profile on the profile page is described earlier in this section.","title":"Adding / Editing / Deleting a Profile"},{"location":"ug/profile/#modules","text":"This tab contains settings for modules that collect information about the application for further analysis. This tab allows you to enable or disable a specific module and make the necessary settings. The system includes twenty scanning modules. A list of all modules is presented on the Modules tab on the profile page. In this list, you can select and configure the modules to be enabled when scanning an application with this profile. Further analysis and search for application vulnerabilities will be performed based on the data collected during the scan. To work effectively with the application it is possible to enable or disable each module and make the necessary settings. You can enable or disable the module using the selector to the right of its name. All enabled modules have selector in the enabled position , all disabled modules have selector in the disabled position . To change the module status from \"enabled\" to \"disabled\" and vice versa, just click the module selector. There are a number of specific settings for each module. When you select a module from the list of modules on the left side of the tab, its settings are displayed on the right side of the tab. You can change and save them by clicking the Change button at the bottom of the tab. The settings for each module include: * Name of the module. * Description of the module. * List of modules that affect the operation of this module. * Module Settings that can be configured (if applicable to this module - some modules do not have configurable settings). Some modules depend on the results of other modules. This is indicated in the list of modules on the left side by the additional information at the bottom of the module name, see figure below. If all \"parent\" modules are disabled, the module that depends on them will also be automatically disabled.","title":"Modules"},{"location":"ug/profile/#standards","text":"This tab is for managing the information security standards used by the profile to check the application. The Standards tab of the company page lists information security standards and their requirements. An application can be checked for compliance with these information security requirements. A list of all standards and requirements is also presented on the Standards tab on the profile page. In this list you can select the standards against which the results of testing an application with this profile will be checked. The list of requirements included in the standard is presented on the right. The system allows to enable or disable information security standard compliance check. The selector is in the on position for all standards enabled for checking and in the off position for all standards disabled. To change the standard status from \"enabled\" to \"disabled\" and vice versa, just click the standard selector. '","title":"Standards"},{"location":"ug/projects/","text":"Projects Project List The Projects page lists all existing projects in this company and their scan profiles. For each project, its name, package name and application architecture are shown. On this page you can find brief information about existing project profiles, number of defects found over the lifetime of the project, number of scans performed, date of the last scan, and number of modules enabled. You can also add a new project or add a new scan profile for an existing project. Clicking on the project name opens the project page with general information and three tabs: Profiles , Rules , and Access . Project Information The top of the project page provides general project information, including: Project avatar. Project name. Project description. Package name. Number of scans performed in the project. Project architecture type (Android or iOS). Adding / Editing / Deleting a Project To work with projects, select Projects from the main menu at the top. To add a new project, click the Add project button at the top right of the Projects page. In the *Add project * window that appears, enter the project name, a short description, and the project architecture (Android/iOS). You can also specify the name of the application package to be scanned in the corresponding field. If you leave this field empty, it will be filled in automatically after the first scan. If you select Copy profiles from an existing project you can select a project already existing in the company in the field Copy from project. This allows you to create a new project together with the profiles already existing and configured in the project selected for copying and avoid adding and configuring them again in the new project. Click the Add button in the lower right corner. The newly created project appears on the Projects page. To edit a project, click the project name on the Projects page. On the project page that opens, click the Change button: The following parameters can be edited in the Change project data window that appears: * In the Name field, edit the project name. * Change the project description in the corresponding field. * Change the package name in the corresponding field. After editing the project information, click the Update button in the lower right corner of the window. Change the project avatar by clicking on the current avatar and selecting an image file for new avatar. You can also delete a project on its page. To do this, click the Delete button on the right side and confirm this action in the dialog box that appears. List of Project Profiles The Profiles tab allows you to manage the scan profiles that are included in this project. You can view existing profiles and add a new profile. For more information on working with profiles, see the \" Scan Profiles \" section. Rules The Rules tab allows you to manage vulnerability analysis rules that apply to this project. Please refer to the \" Rules \" section for more information. Project Access Rights The Access tab is used to assign project permissions to both users and user groups. Refer to the \" Users, groups, and projects \" section for more information about the application role model.","title":"Projects"},{"location":"ug/projects/#projects","text":"","title":"Projects"},{"location":"ug/projects/#project-list","text":"The Projects page lists all existing projects in this company and their scan profiles. For each project, its name, package name and application architecture are shown. On this page you can find brief information about existing project profiles, number of defects found over the lifetime of the project, number of scans performed, date of the last scan, and number of modules enabled. You can also add a new project or add a new scan profile for an existing project. Clicking on the project name opens the project page with general information and three tabs: Profiles , Rules , and Access .","title":"Project List"},{"location":"ug/projects/#project-information","text":"The top of the project page provides general project information, including: Project avatar. Project name. Project description. Package name. Number of scans performed in the project. Project architecture type (Android or iOS).","title":"Project Information"},{"location":"ug/projects/#adding-editing-deleting-a-project","text":"To work with projects, select Projects from the main menu at the top. To add a new project, click the Add project button at the top right of the Projects page. In the *Add project * window that appears, enter the project name, a short description, and the project architecture (Android/iOS). You can also specify the name of the application package to be scanned in the corresponding field. If you leave this field empty, it will be filled in automatically after the first scan. If you select Copy profiles from an existing project you can select a project already existing in the company in the field Copy from project. This allows you to create a new project together with the profiles already existing and configured in the project selected for copying and avoid adding and configuring them again in the new project. Click the Add button in the lower right corner. The newly created project appears on the Projects page. To edit a project, click the project name on the Projects page. On the project page that opens, click the Change button: The following parameters can be edited in the Change project data window that appears: * In the Name field, edit the project name. * Change the project description in the corresponding field. * Change the package name in the corresponding field. After editing the project information, click the Update button in the lower right corner of the window. Change the project avatar by clicking on the current avatar and selecting an image file for new avatar. You can also delete a project on its page. To do this, click the Delete button on the right side and confirm this action in the dialog box that appears.","title":"Adding / Editing / Deleting a Project"},{"location":"ug/projects/#list-of-project-profiles","text":"The Profiles tab allows you to manage the scan profiles that are included in this project. You can view existing profiles and add a new profile. For more information on working with profiles, see the \" Scan Profiles \" section.","title":"List of Project Profiles"},{"location":"ug/projects/#rules","text":"The Rules tab allows you to manage vulnerability analysis rules that apply to this project. Please refer to the \" Rules \" section for more information.","title":"Rules"},{"location":"ug/projects/#project-access-rights","text":"The Access tab is used to assign project permissions to both users and user groups. Refer to the \" Users, groups, and projects \" section for more information about the application role model.","title":"Project Access Rights"},{"location":"ug/rules/","text":"Rules This tab shows the vulnerability analysis rules that apply to this particular project. In general, the rules correspond to those defined at the company level (see the \" Company-level Analysis Rules \" section). However, it is possible to change or add rules at the project level, depending on specifics of an application being scanned. Rules added at the project level will only apply within that project. Redefinition of Analysis Rules The Rules tab on the project page provides rules for analyzing collected data to find vulnerabilities. Use this tab to add, change, disable or delete an existing analysis rule at the project level. This means that the new or changed analysis rule will be applied only to this project, but not to all projects of this company. How Analysis Rules Work The main goal of using analysis rules is to tune the system to the characteristics of the tested application in order to effectively find vulnerabilities. Each application and its data is unique in format and content. Use of customized analysis rules maximizes the system's coverage of all possible application-specific vulnerability cases. Analysis rules available to user for modification are used to search for a part of the vulnerabilities. Analysis rules for finding certain vulnerabilities are a set of strings or regular expressions to be searched in the data collected during an application scan. Each rule specifies which string or regular expression to search for, in which modules' data, and where exactly the search should take place. This approach significantly reduces the number of false positives when searching for vulnerabilities. The system contains two types of analysis rules: Internal analysis rules. They are not configurable and cannot be viewed or edited by the user. They are not presented on the Rules tab. Analysis rules intended to search for sensitive information. They are presented on the Rules tab and described in this section. These rules can be modified by the user. On the Rules tab, each analysis rule is represented as a separate line on the left side of the List of rules . The rule string has the following fields: Name of the rule. Selector of the rule status. If the selector is switched on , the rule is active and will be applied when analyzing collected data to find vulnerabilities. If the selector is switched off , the rule is inactive and will not be applied when analyzing collected data to find vulnerabilities. The selected rule is highlighted and the main information about it is displayed on the right: List of injections \u2014 A set of strings and regular expressions to search for confidential information. List of expressions \u2014 Where exactly to look for the necessary information, in what files and data formats. List of modules \u2014 Modules where this rule will be applied. Mobix supports nesting rules, as in the case of the Server keys . Let's consider how the analysis rules work on the example of one of the rules. This analysis rule is currently active and is called \"Password\". It defines that the following patterns: Regular expressions of the form (pin(?:[_-]?code)?)|([\\w]+_pin)|([\\w]+Pin) . The password string. The passphrase string. will be searched in the data collected by all modules selected in the List of modules field in the following locations (these values were selected in the List of expressions field): XML tag name. Key name in JSON or YAML. If necessary, user can disable or edit this rule. Editing Analysis Rules You can edit the analysis rules on the Rules tab. To edit, select the required rule on the left side of the List of rules . You can change and save the following parameters in the General Information field on the right: Name \u2014 the rule's name. To save the changes you made, click the Change button on the right. Description of the analysis rule To save the changes you made, click the Change button on the right. You can add a string or regular expression to the List of injections field to search for confidential information. To do this, click the Add button on the right in the List of injections field, in the Injection field that appears, specify the new string or regular expression and click Add . All previously defined regular expressions for this rule are listed in this field below. Company-level search strings can be disabled using the selector next to each string. Search strings set at project level can be disabled or deleted. To delete the search string, click the Delete button on the right. List of expressions \u2014 for active search locations selector is in position , for inactive \u2014 in position . To change, press the selector. Its position will change and a notification of a successful change will be displayed. List of modules for which this rule will be applied. Any module can be selected and added to the rule. Enabling and disabling of any module can be done similarly to the List of expressions field. Adding Analysis Rules To add a new analysis rule, click the Add rule button at the top right. In the Add rule window that appears, enter a name and description of the rule and click the Add button at the bottom right. The added rule will be displayed in the list and can be edited further. For a newly added rule, the List of injections field is empty, and in the List of expressions and List of modules fields all selectors are switched off . Deleting Analysis Rule You can delete the analysis rules on the Rules tab. To delete a rule, click the Delete button in the upper-right corner of the General Information field. In the dialog box that appears, you need to confirm or cancel the deletion. Note The system has nine preset rules, defined at the company level. At the project level, they can only be disabled, but cannot be deleted. User can only delete other rules.","title":"Rules"},{"location":"ug/rules/#rules","text":"This tab shows the vulnerability analysis rules that apply to this particular project. In general, the rules correspond to those defined at the company level (see the \" Company-level Analysis Rules \" section). However, it is possible to change or add rules at the project level, depending on specifics of an application being scanned. Rules added at the project level will only apply within that project.","title":"Rules"},{"location":"ug/rules/#redefinition-of-analysis-rules","text":"The Rules tab on the project page provides rules for analyzing collected data to find vulnerabilities. Use this tab to add, change, disable or delete an existing analysis rule at the project level. This means that the new or changed analysis rule will be applied only to this project, but not to all projects of this company.","title":"Redefinition of Analysis Rules"},{"location":"ug/rules/#how-analysis-rules-work","text":"The main goal of using analysis rules is to tune the system to the characteristics of the tested application in order to effectively find vulnerabilities. Each application and its data is unique in format and content. Use of customized analysis rules maximizes the system's coverage of all possible application-specific vulnerability cases. Analysis rules available to user for modification are used to search for a part of the vulnerabilities. Analysis rules for finding certain vulnerabilities are a set of strings or regular expressions to be searched in the data collected during an application scan. Each rule specifies which string or regular expression to search for, in which modules' data, and where exactly the search should take place. This approach significantly reduces the number of false positives when searching for vulnerabilities. The system contains two types of analysis rules: Internal analysis rules. They are not configurable and cannot be viewed or edited by the user. They are not presented on the Rules tab. Analysis rules intended to search for sensitive information. They are presented on the Rules tab and described in this section. These rules can be modified by the user. On the Rules tab, each analysis rule is represented as a separate line on the left side of the List of rules . The rule string has the following fields: Name of the rule. Selector of the rule status. If the selector is switched on , the rule is active and will be applied when analyzing collected data to find vulnerabilities. If the selector is switched off , the rule is inactive and will not be applied when analyzing collected data to find vulnerabilities. The selected rule is highlighted and the main information about it is displayed on the right: List of injections \u2014 A set of strings and regular expressions to search for confidential information. List of expressions \u2014 Where exactly to look for the necessary information, in what files and data formats. List of modules \u2014 Modules where this rule will be applied. Mobix supports nesting rules, as in the case of the Server keys . Let's consider how the analysis rules work on the example of one of the rules. This analysis rule is currently active and is called \"Password\". It defines that the following patterns: Regular expressions of the form (pin(?:[_-]?code)?)|([\\w]+_pin)|([\\w]+Pin) . The password string. The passphrase string. will be searched in the data collected by all modules selected in the List of modules field in the following locations (these values were selected in the List of expressions field): XML tag name. Key name in JSON or YAML. If necessary, user can disable or edit this rule.","title":"How Analysis Rules Work"},{"location":"ug/rules/#editing-analysis-rules","text":"You can edit the analysis rules on the Rules tab. To edit, select the required rule on the left side of the List of rules . You can change and save the following parameters in the General Information field on the right: Name \u2014 the rule's name. To save the changes you made, click the Change button on the right. Description of the analysis rule To save the changes you made, click the Change button on the right. You can add a string or regular expression to the List of injections field to search for confidential information. To do this, click the Add button on the right in the List of injections field, in the Injection field that appears, specify the new string or regular expression and click Add . All previously defined regular expressions for this rule are listed in this field below. Company-level search strings can be disabled using the selector next to each string. Search strings set at project level can be disabled or deleted. To delete the search string, click the Delete button on the right. List of expressions \u2014 for active search locations selector is in position , for inactive \u2014 in position . To change, press the selector. Its position will change and a notification of a successful change will be displayed. List of modules for which this rule will be applied. Any module can be selected and added to the rule. Enabling and disabling of any module can be done similarly to the List of expressions field.","title":"Editing Analysis Rules"},{"location":"ug/rules/#adding-analysis-rules","text":"To add a new analysis rule, click the Add rule button at the top right. In the Add rule window that appears, enter a name and description of the rule and click the Add button at the bottom right. The added rule will be displayed in the list and can be edited further. For a newly added rule, the List of injections field is empty, and in the List of expressions and List of modules fields all selectors are switched off .","title":"Adding Analysis Rules"},{"location":"ug/rules/#deleting-analysis-rule","text":"You can delete the analysis rules on the Rules tab. To delete a rule, click the Delete button in the upper-right corner of the General Information field. In the dialog box that appears, you need to confirm or cancel the deletion. Note The system has nine preset rules, defined at the company level. At the project level, they can only be disabled, but cannot be deleted. User can only delete other rules.","title":"Deleting Analysis Rule"},{"location":"ug/scan_launch/","text":"Scan Launch The scan launch can be performed in manual or automatic mode. To start a scan, select the Scans main menu item and click the Add scan button in the upper right corner. Select or drag and drop an APK or IPA file of the app you want to scan to the Add scan page that appears: Note If a package with the chosen name and hash sum is already uploaded, in order to save resources it is not downloaded again, but the file already present on the server is used. After selecting a file on the Add scan page, fields required to start scanning the application will appear: Information about the file of application under test: Package name , Version name and code , Target SDK , Min SDK , File name/size/hash , and Architecture type . Project \u2014 Name of the project where the scan is performed. Note You can select either projects with an empty Package name field (see the Projects section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty Package name field or by specifying in it the corresponding package. Profile \u2014 Scan profile used to scan the application. Scan type - manual or auto scanning. Test case \u2014 this field appears if you select auto mode. A test case to be executed should be selected from the drop-down list of available test cases. Note Only test cases of the selected project are displayed. Architecture \u2014 The architecture of the device used to launch and scan the application. Note If there are no devices available for scanning, the Architecture field displays the message ****There are no running devices for this architecture. Auto Scan To start scanning in automatic mode, perform the following steps: Select and download mobile application file with *.apk or *.ipa extension for scanning. Note If a package with the chosen name and hash sum is already uploaded, in order to save resources it is not downloaded again, but the file already present on the server is used. Select a project from the drop-down list of existing projects. Note You can select either projects with an empty Package name field (see the Projects section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty Package name field or by specifying in it the corresponding package. Select a scanning profile from the drop-down list. Select the architecture to perform the scan. Note that in this field is available for selection only the architecture active in the system, where the test was recorded. In the Scan type field, select Auto from the drop-down list. In the newly appeared field below, select the name of a test case that already exists in the system to start scanning in automatic mode. Clicking the Run button starts the scan and takes you to the Scan page . A page with the device screen without the ability to interact with it will appear. A dynamic view of the device screen is necessary to analyze the operation of the test case. During the scan, the following statuses are displayed on the screen of the device: * Searching for a free device\u2026 \u2014 the free scanning engine is searched for. * Starting application\u2026 \u2014 the application is launching. While an auto scan is in progress, a video is also recorded. After the scan is complete, it is available in the View video record tab of the Scan result page for this test. Clicking the To scan results button will take you to a page with a list of all scans. If you go to the List of scans page, you can see a new line showing the current result of the automatic scan with the Started status. If you click on the test case ID when the corresponding scan has the state of Created , Starting or Started , you are returned to the page with the device screen. Once the application scan is complete, its state will change to Analyzing while the results are being processed. Then the scan state will change to Success or Failed depending on the result. If you click on the test case ID when the scan has the status Analyzing , Success or Failed , you will be taken to a page with detailed scan results, see the \" Scan Results \" section. Manual Scan To start scanning in manual mode, select the Scans main menu item and click the Add scan button in the upper right corner. Select or drag and drop an APK or IPA file of the app you want to scan to the Add scan page that appears. When you load a file, the system will detect its architecture and filter out all the necessary values in the next fields. Note If a package with the chosen name and hash sum is already uploaded, in order to save resources it is not downloaded again, but the file already present on the server is used. To start scanning in manual mode, perform the following steps: Select a project from the drop-down list of existing projects. Note You can select either projects with an empty Package name field (see the Projects section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty Package name field or by specifying in it the corresponding package. Select a scanning profile from the drop-down list. Select the architecture to perform the scan. In the Scan type field, select Manual from the drop-down list. Clicking the Run button starts the scan and takes you to the Scan page. The page with the device screen and the running application will be displayed. Manual scanning looks like a normal user's work with the application. All user actions are recorded as a sequence of test case steps. After all the necessary steps to scan the application are done, click the Stop button at the bottom. Once clicked, scanning will stop and the system will go into data analysis mode. Clicking the To scan results button will take you to a page with a list of all scans. You can identify results of the manual scan by the data in the Modified at column. Processing the scan results takes some time. So you have to wait until the results are processed before you can view and analyze them in detail. The scan status in the State column can have several values: Created \u2014 the scan was created and placed in the scan queue. Starting \u2014 the scan is already being processed and the necessary technical preparations before the launch are underway (installation of the application, launching the application, etc.) Started \u2014 scanning process is in progress and interaction with the application is performed manually or through test cases, depending on the type of scanning. Analyzing \u2014 interaction with the application is over, analysis of the collected data is in progress. Failed \u2014 the scan was completed with an error. Success \u2014 the scan was completed successfully and without errors. Canceled \u2014 the scan is canceled using the drop-down menu on the right. Waiting for Analyzing \u2014 A re-analysis of scan results has been started and has not yet been completed. Launching a Scan from the Command Line The application scan can be launched not only from the user interface, but also from the command line. The process of forming a command line and launching a scan is described in detail in the Integrations section. Launching a Scan from Distribution Systems There exist tools for launching application scans from distribution systems that make this process much easier. Launching a scan from distribution systems is described in detail in the \" Integrations \" section.","title":"Scan Launch"},{"location":"ug/scan_launch/#scan-launch","text":"The scan launch can be performed in manual or automatic mode. To start a scan, select the Scans main menu item and click the Add scan button in the upper right corner. Select or drag and drop an APK or IPA file of the app you want to scan to the Add scan page that appears: Note If a package with the chosen name and hash sum is already uploaded, in order to save resources it is not downloaded again, but the file already present on the server is used. After selecting a file on the Add scan page, fields required to start scanning the application will appear: Information about the file of application under test: Package name , Version name and code , Target SDK , Min SDK , File name/size/hash , and Architecture type . Project \u2014 Name of the project where the scan is performed. Note You can select either projects with an empty Package name field (see the Projects section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty Package name field or by specifying in it the corresponding package. Profile \u2014 Scan profile used to scan the application. Scan type - manual or auto scanning. Test case \u2014 this field appears if you select auto mode. A test case to be executed should be selected from the drop-down list of available test cases. Note Only test cases of the selected project are displayed. Architecture \u2014 The architecture of the device used to launch and scan the application. Note If there are no devices available for scanning, the Architecture field displays the message ****There are no running devices for this architecture.","title":"Scan Launch"},{"location":"ug/scan_launch/#auto-scan","text":"To start scanning in automatic mode, perform the following steps: Select and download mobile application file with *.apk or *.ipa extension for scanning. Note If a package with the chosen name and hash sum is already uploaded, in order to save resources it is not downloaded again, but the file already present on the server is used. Select a project from the drop-down list of existing projects. Note You can select either projects with an empty Package name field (see the Projects section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty Package name field or by specifying in it the corresponding package. Select a scanning profile from the drop-down list. Select the architecture to perform the scan. Note that in this field is available for selection only the architecture active in the system, where the test was recorded. In the Scan type field, select Auto from the drop-down list. In the newly appeared field below, select the name of a test case that already exists in the system to start scanning in automatic mode. Clicking the Run button starts the scan and takes you to the Scan page . A page with the device screen without the ability to interact with it will appear. A dynamic view of the device screen is necessary to analyze the operation of the test case. During the scan, the following statuses are displayed on the screen of the device: * Searching for a free device\u2026 \u2014 the free scanning engine is searched for. * Starting application\u2026 \u2014 the application is launching. While an auto scan is in progress, a video is also recorded. After the scan is complete, it is available in the View video record tab of the Scan result page for this test. Clicking the To scan results button will take you to a page with a list of all scans. If you go to the List of scans page, you can see a new line showing the current result of the automatic scan with the Started status. If you click on the test case ID when the corresponding scan has the state of Created , Starting or Started , you are returned to the page with the device screen. Once the application scan is complete, its state will change to Analyzing while the results are being processed. Then the scan state will change to Success or Failed depending on the result. If you click on the test case ID when the scan has the status Analyzing , Success or Failed , you will be taken to a page with detailed scan results, see the \" Scan Results \" section.","title":"Auto Scan"},{"location":"ug/scan_launch/#manual-scan","text":"To start scanning in manual mode, select the Scans main menu item and click the Add scan button in the upper right corner. Select or drag and drop an APK or IPA file of the app you want to scan to the Add scan page that appears. When you load a file, the system will detect its architecture and filter out all the necessary values in the next fields. Note If a package with the chosen name and hash sum is already uploaded, in order to save resources it is not downloaded again, but the file already present on the server is used. To start scanning in manual mode, perform the following steps: Select a project from the drop-down list of existing projects. Note You can select either projects with an empty Package name field (see the Projects section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty Package name field or by specifying in it the corresponding package. Select a scanning profile from the drop-down list. Select the architecture to perform the scan. In the Scan type field, select Manual from the drop-down list. Clicking the Run button starts the scan and takes you to the Scan page. The page with the device screen and the running application will be displayed. Manual scanning looks like a normal user's work with the application. All user actions are recorded as a sequence of test case steps. After all the necessary steps to scan the application are done, click the Stop button at the bottom. Once clicked, scanning will stop and the system will go into data analysis mode. Clicking the To scan results button will take you to a page with a list of all scans. You can identify results of the manual scan by the data in the Modified at column. Processing the scan results takes some time. So you have to wait until the results are processed before you can view and analyze them in detail. The scan status in the State column can have several values: Created \u2014 the scan was created and placed in the scan queue. Starting \u2014 the scan is already being processed and the necessary technical preparations before the launch are underway (installation of the application, launching the application, etc.) Started \u2014 scanning process is in progress and interaction with the application is performed manually or through test cases, depending on the type of scanning. Analyzing \u2014 interaction with the application is over, analysis of the collected data is in progress. Failed \u2014 the scan was completed with an error. Success \u2014 the scan was completed successfully and without errors. Canceled \u2014 the scan is canceled using the drop-down menu on the right. Waiting for Analyzing \u2014 A re-analysis of scan results has been started and has not yet been completed.","title":"Manual Scan"},{"location":"ug/scan_launch/#launching-a-scan-from-the-command-line","text":"The application scan can be launched not only from the user interface, but also from the command line. The process of forming a command line and launching a scan is described in detail in the Integrations section.","title":"Launching a Scan from the Command Line"},{"location":"ug/scan_launch/#launching-a-scan-from-distribution-systems","text":"There exist tools for launching application scans from distribution systems that make this process much easier. Launching a scan from distribution systems is described in detail in the \" Integrations \" section.","title":"Launching a Scan from Distribution Systems"},{"location":"ug/scan_results/","text":"Scan Results List of Scan Results Select the Scans menu item to see a list of all scans performed. Each scan is represented by one line. Scan results are automatically updated every 10 seconds. This frees the user from having to refresh the page manually. The list shows scans sorted by the scan ID . The list contains the following information: ID \u2014 Internal scan ID. Click on the scan ID to go to detailed results of the selected scan. Project \u2014 The name of the project where the scan was performed. This value is a link, by clicking it you can go to the corresponding project. Profile \u2014 Scan profile used for application analysis. This value is a link, by clicking it you can go to the corresponding scan profile. Package name of the analyzed application. Scan type \u2014 manual test or auto test. Architecture type where the scan was performed (Android or iOS). Package name of the analyzed application. State \u2014 Scan status, can have several values: Success \u2014 The scan was completed successfully and without errors. If the scan as a whole was successful, but there were failures in some modules, the icon is displayed next to the status. If you hold the mouse cursor over it, more detailed information about the error will be displayed. Created \u2014 the scan was created and placed in the scan queue. Starting \u2014 scanning is running, the target application is being installed and launched. Started \u2014 the scanning process is in progress. Analyzing \u2014 the scanning is ended, the process of analyzing the collected information is performed. Canceled \u2014 the scan is canceled using the drop-down menu on the right. Failed \u2014 The scan was completed with an error. The icon is displayed next to the status. If you hold the mouse cursor over it, more detailed information about the error will be displayed. Waiting for Analyzing - A re-analysis of scan results has been started and has not yet been completed. Modified at \u2014 time of the last scan status change. To display only the results you want in the columns marked with the filter icon, you can set a filter. After setting a filter in the column, the icon color changes to blue . When you select multiple filters, they work together. For example, if you select the Manual scan type and the Success state, all successful manual scans will be found and displayed. To remove a filter you have set, click the filter icon and select Reset from the drop-down menu: Besides, when you are on this page, you can: Open a page with detailed scan results. Download a PDF scan report. Initiate re-analysis of the scan results. Delete scan results. Use the corresponding items of the \" \" drop-down menu on the right side of a scan string to perform these actions: Scan Result To go to the detailed scan results page, either click on the required scan string in the List of scans , or click on the \" \" drop-down menu on the right side of the scan string and select Open . This page contains all the information about the analysis of the application: general information, vulnerabilities detected, data collected during the application's operation, and compliance with standards and requirements. There are three or four tabs available for selection, depending on the type of scan: Defects , Collected data , Standards , Record scan . The last tab is present only for scans performed in auto mode. General Information General information can be found at the top of the detailed scan results page. It contains information about the performed scan and brief information about the scanned application. This tab contains general scan information, including the following: * Project where the scan was conducted. This value is a link, by clicking it you can go to the corresponding project. * Profile used for application scan. This value is a link, by clicking it you can go to the corresponding scan profile. * Test case \u2014 Name of the test case used. This value is a link, by clicking it you can go to the corresponding test case. This field is present only for scans performed in auto mode. * Modified at \u2014 Scan date. * State \u2014 Scan status. * Package name \u2014 Name of the application package in the system. * Architecture type / Architecture \u2014 Architecture of the scanned application (Android or iOS). * Version \u2014 Name and version code specified in the application manifest to better identify the analyzed application. * Target SDK/Min SDK \u2014 Target and minimum versions of the Android SDK to build the application. * File size of the application file. * MD5 \u2014 The hash sum of the application file. The buttons below the general information allow you to perform the following actions: Recalculation \u2014 Re-analyze the scan results using the latest analysis rules for the application. Download logs \u2014 Download the scan log file. Download report \u2014 Get a detailed report on the results of the scan in PDF format. Download app \u2014 Download the file of the application scanned. Defects For each vulnerability detected, the system creates a defect. All defects found during the scan are shown in the List of defects in the left half of the Defects tab. The right side of this tab provides information about the detected vulnerability with a detailed description of the vulnerability, as well as recommendations on how to fix it. For convenience of work with defects in the columns marked with the filter icon , it is possible to select and apply a filter to the displayed defects. To do this, click the filter icon and select one or more values from the drop-down lists to filter by Severity level and Detection tool . If the High severity level and the Mobix detection tool are selected, all defects detected by Mobix with a high severity level will be displayed. After setting a filter in the column, the icon color changes to blue . To remove a filter, click on the filter icon and select Reset from the drop-down menu. The Defects tab provides the following information about defects: Defect ID in the system. Name of the detected vulnerability. Severity level of the defect (Critical, High, Medium, Low, Info). Detection tool - name of the tool that detected this defect (Stingray, Appscreener, Oversecured). Status of the defect ( Not processed, Confirmed, False positive). The system automatically fills in the values of the defect fields during the analysis of the results. Click on a defect in the List of defects and you will see detailed information about it on the right side. The following information is provided: 1. Defect ID in the system. Name of the detected vulnerability. Next to the name is the Download report button. Click it to get a vulnerability report in PDF format. State of the defect : New \u2014 If the defect was first found during this scan, or if it had already occurred before, and then the problem was solved and the defect was closed, but reappeared during this scan. Recurrent \u2014 If the defect has already been found during previous scans. Fixed \u2014 Is the state for those defects that were found in previous scans, but are no longer present in the current scan. Severity level of the defect. This field displays the current value of the defect severity. It provides the opportunity to change the severity by selecting a new value from the drop-down list. Status of the defect. This field displays the current status of the defect. It is possible to change the status by selecting a new value from the drop-down list. Description of the defect briefly describes the vulnerability found. Next to the Description there is a link to the Recommendations with a detailed description of the vulnerability, recommendations on how to fix it, examples of source code, and links to materials on this vulnerability. !!! note \"Note\" Special mention should be made of the defects detected by the Search for previously found sensitive information module. In the Description field of such defects, in addition to the information mentioned above, you can find the View details link to the vulnerabilities that caused such a defect. ![](../ug/img/71.png) Location of defect. If several vulnerabilities of the same type are detected, they are grouped into one vulnerability. Arrows appear to the right of this field. You can use them to navigate between the vulnerabilities. Below is important information about the vulnerability found, such as the sensitive information found, where it was found, etc. For convenient work with the information from these fields, you can use the Copy button located on their right side. The Result field displays a code fragment or the contents of the file (up to 5000 characters) where the vulnerability was detected. If you want to download the entire file, click the Download result button on the right. If the analysis finds vulnerabilities that we define as false positives, they can be added to both project-level and company-level exceptions (for all projects in the company). To do this, select one or more detected defects, change their Status to \"False positive\" and click the Add exception button located in the upper right corner of the Defects tab. In the Add exclusions window that appears, select whether you want to add exceptions at the project or company level, and click the Add button. You can also add an exception for a particular vulnerability by clicking the Add exclusions button next to the Found by rule heading in the vulnerability description. In the Add exclusions window that appears, select whether you want to add exceptions at the project or company level, and click the Add button. By adding exceptions, such vulnerabilities will not be considered when re-analyzing the results or the next scan within this project, if the project level is selected, or for all projects of a company, if the company level is selected. Collected Data To work with the data collected during the scan, select the Collected data tab on the detailed scan results page. The Collected data tab provides access to all data collected during the application scan. The information is divided into modules that are responsible for collecting various data. For each module it is possible to download the collected data as a zip archive by clicking the Download module data button. It is also possible to download all the collected data at once in one archive using the Download all data button. This tab contains the data collected during a scan of the application by all modules included in the profile. A module for viewing the collected data can be selected in the left pane of the List of collected data field. Each of the modules collects data specific only to it. Accordingly, the format of data representation on the tab is different for each module. The figure above shows the data collected by the Networking module . In this example, the data transmitted over the network was captured, including address, protocol, time, method, port, and content of the request and response. This kind of additional \"raw\" information can be useful when working with the results of the analysis. Another example is shown in the figure below. It illustrates another area of application work, in particular, data collected by the Monitor Activity module. The term \"activity\" here refers to all the various application screens that were run during the scan. For each screen (or \"activity\") its name and launch parameters are shown. All data from different modules, i.e. from different areas of the application, are collected and available for processing in one system. This greatly simplifies data analysis compared to the usual situation where different types of data are collected by several different utilities in different formats during the scan and it is often impossible to run these utilities in parallel to collect data at once. The collected data is used to enable the user to work directly with it when analyzing the results. The system also uses it to draw conclusions about application vulnerabilities. The rules for analyzing collected data to find vulnerabilities are described in detail in the \" Rules \" and \" Company-level Analysis Rules \" sections. Standards Select the Standards tab on the detailed scan results page to work with the standards requirements. This tab displays the results of the requirements compliance check of the scanned application. The Standards tab presents compliance with the security standards selected in the scan profile. Requirements, categories of requirements and standards with identified non-compliances are marked in red. If you click on an unfulfilled requirement on the left side, the Defects tab on the right side will list the types of defects that have been checked for the selected requirement. If at least one defect of a certain type was detected during the application scanning, this type of defects is marked with the sign, and the requirement itself is considered unfulfilled and is marked in red. If no defects of a certain type were found during the requirement check, this type of defects is marked with the sign. A requirement is considered fulfilled if its inspection finds no defects among the types of defects relevant to that requirement. On the right tab Defects , click a defect marked with the sign to get the detailed information about found defects of this type: To return to the requirements list, click the button in the upper left corner. The Standards tab contains data on compliance with the requirements of all standards selected in the scan profile. Suppose one more standard was added to the scan profile. In this case, the results of all scans previously performed with this profile on the Standards tab will also show the correspondence between the previously collected scan results and the newly added standard in the profile. Record Scan This tab is only available for the results of auto scan and provides a video recording of the performed scanning. Screenshot For scans with the *Failed status that were terminated because an application could not start on a device, an additional *App screenshot tab is available as a result of the scan. It contains a screenshot of the device at the moment of the error. Scan Log An additional ****Log tab allows you to view the scan log. It is available only during analysis of scan results.","title":"Scan Results"},{"location":"ug/scan_results/#scan-results","text":"","title":"Scan Results"},{"location":"ug/scan_results/#list-of-scan-results","text":"Select the Scans menu item to see a list of all scans performed. Each scan is represented by one line. Scan results are automatically updated every 10 seconds. This frees the user from having to refresh the page manually. The list shows scans sorted by the scan ID . The list contains the following information: ID \u2014 Internal scan ID. Click on the scan ID to go to detailed results of the selected scan. Project \u2014 The name of the project where the scan was performed. This value is a link, by clicking it you can go to the corresponding project. Profile \u2014 Scan profile used for application analysis. This value is a link, by clicking it you can go to the corresponding scan profile. Package name of the analyzed application. Scan type \u2014 manual test or auto test. Architecture type where the scan was performed (Android or iOS). Package name of the analyzed application. State \u2014 Scan status, can have several values: Success \u2014 The scan was completed successfully and without errors. If the scan as a whole was successful, but there were failures in some modules, the icon is displayed next to the status. If you hold the mouse cursor over it, more detailed information about the error will be displayed. Created \u2014 the scan was created and placed in the scan queue. Starting \u2014 scanning is running, the target application is being installed and launched. Started \u2014 the scanning process is in progress. Analyzing \u2014 the scanning is ended, the process of analyzing the collected information is performed. Canceled \u2014 the scan is canceled using the drop-down menu on the right. Failed \u2014 The scan was completed with an error. The icon is displayed next to the status. If you hold the mouse cursor over it, more detailed information about the error will be displayed. Waiting for Analyzing - A re-analysis of scan results has been started and has not yet been completed. Modified at \u2014 time of the last scan status change. To display only the results you want in the columns marked with the filter icon, you can set a filter. After setting a filter in the column, the icon color changes to blue . When you select multiple filters, they work together. For example, if you select the Manual scan type and the Success state, all successful manual scans will be found and displayed. To remove a filter you have set, click the filter icon and select Reset from the drop-down menu: Besides, when you are on this page, you can: Open a page with detailed scan results. Download a PDF scan report. Initiate re-analysis of the scan results. Delete scan results. Use the corresponding items of the \" \" drop-down menu on the right side of a scan string to perform these actions:","title":"List of Scan Results"},{"location":"ug/scan_results/#scan-result","text":"To go to the detailed scan results page, either click on the required scan string in the List of scans , or click on the \" \" drop-down menu on the right side of the scan string and select Open . This page contains all the information about the analysis of the application: general information, vulnerabilities detected, data collected during the application's operation, and compliance with standards and requirements. There are three or four tabs available for selection, depending on the type of scan: Defects , Collected data , Standards , Record scan . The last tab is present only for scans performed in auto mode.","title":"Scan Result"},{"location":"ug/scan_results/#general-information","text":"General information can be found at the top of the detailed scan results page. It contains information about the performed scan and brief information about the scanned application. This tab contains general scan information, including the following: * Project where the scan was conducted. This value is a link, by clicking it you can go to the corresponding project. * Profile used for application scan. This value is a link, by clicking it you can go to the corresponding scan profile. * Test case \u2014 Name of the test case used. This value is a link, by clicking it you can go to the corresponding test case. This field is present only for scans performed in auto mode. * Modified at \u2014 Scan date. * State \u2014 Scan status. * Package name \u2014 Name of the application package in the system. * Architecture type / Architecture \u2014 Architecture of the scanned application (Android or iOS). * Version \u2014 Name and version code specified in the application manifest to better identify the analyzed application. * Target SDK/Min SDK \u2014 Target and minimum versions of the Android SDK to build the application. * File size of the application file. * MD5 \u2014 The hash sum of the application file. The buttons below the general information allow you to perform the following actions: Recalculation \u2014 Re-analyze the scan results using the latest analysis rules for the application. Download logs \u2014 Download the scan log file. Download report \u2014 Get a detailed report on the results of the scan in PDF format. Download app \u2014 Download the file of the application scanned.","title":"General Information"},{"location":"ug/scan_results/#defects","text":"For each vulnerability detected, the system creates a defect. All defects found during the scan are shown in the List of defects in the left half of the Defects tab. The right side of this tab provides information about the detected vulnerability with a detailed description of the vulnerability, as well as recommendations on how to fix it. For convenience of work with defects in the columns marked with the filter icon , it is possible to select and apply a filter to the displayed defects. To do this, click the filter icon and select one or more values from the drop-down lists to filter by Severity level and Detection tool . If the High severity level and the Mobix detection tool are selected, all defects detected by Mobix with a high severity level will be displayed. After setting a filter in the column, the icon color changes to blue . To remove a filter, click on the filter icon and select Reset from the drop-down menu. The Defects tab provides the following information about defects: Defect ID in the system. Name of the detected vulnerability. Severity level of the defect (Critical, High, Medium, Low, Info). Detection tool - name of the tool that detected this defect (Stingray, Appscreener, Oversecured). Status of the defect ( Not processed, Confirmed, False positive). The system automatically fills in the values of the defect fields during the analysis of the results. Click on a defect in the List of defects and you will see detailed information about it on the right side. The following information is provided: 1. Defect ID in the system. Name of the detected vulnerability. Next to the name is the Download report button. Click it to get a vulnerability report in PDF format. State of the defect : New \u2014 If the defect was first found during this scan, or if it had already occurred before, and then the problem was solved and the defect was closed, but reappeared during this scan. Recurrent \u2014 If the defect has already been found during previous scans. Fixed \u2014 Is the state for those defects that were found in previous scans, but are no longer present in the current scan. Severity level of the defect. This field displays the current value of the defect severity. It provides the opportunity to change the severity by selecting a new value from the drop-down list. Status of the defect. This field displays the current status of the defect. It is possible to change the status by selecting a new value from the drop-down list. Description of the defect briefly describes the vulnerability found. Next to the Description there is a link to the Recommendations with a detailed description of the vulnerability, recommendations on how to fix it, examples of source code, and links to materials on this vulnerability. !!! note \"Note\" Special mention should be made of the defects detected by the Search for previously found sensitive information module. In the Description field of such defects, in addition to the information mentioned above, you can find the View details link to the vulnerabilities that caused such a defect. ![](../ug/img/71.png) Location of defect. If several vulnerabilities of the same type are detected, they are grouped into one vulnerability. Arrows appear to the right of this field. You can use them to navigate between the vulnerabilities. Below is important information about the vulnerability found, such as the sensitive information found, where it was found, etc. For convenient work with the information from these fields, you can use the Copy button located on their right side. The Result field displays a code fragment or the contents of the file (up to 5000 characters) where the vulnerability was detected. If you want to download the entire file, click the Download result button on the right. If the analysis finds vulnerabilities that we define as false positives, they can be added to both project-level and company-level exceptions (for all projects in the company). To do this, select one or more detected defects, change their Status to \"False positive\" and click the Add exception button located in the upper right corner of the Defects tab. In the Add exclusions window that appears, select whether you want to add exceptions at the project or company level, and click the Add button. You can also add an exception for a particular vulnerability by clicking the Add exclusions button next to the Found by rule heading in the vulnerability description. In the Add exclusions window that appears, select whether you want to add exceptions at the project or company level, and click the Add button. By adding exceptions, such vulnerabilities will not be considered when re-analyzing the results or the next scan within this project, if the project level is selected, or for all projects of a company, if the company level is selected.","title":"Defects"},{"location":"ug/scan_results/#collected-data","text":"To work with the data collected during the scan, select the Collected data tab on the detailed scan results page. The Collected data tab provides access to all data collected during the application scan. The information is divided into modules that are responsible for collecting various data. For each module it is possible to download the collected data as a zip archive by clicking the Download module data button. It is also possible to download all the collected data at once in one archive using the Download all data button. This tab contains the data collected during a scan of the application by all modules included in the profile. A module for viewing the collected data can be selected in the left pane of the List of collected data field. Each of the modules collects data specific only to it. Accordingly, the format of data representation on the tab is different for each module. The figure above shows the data collected by the Networking module . In this example, the data transmitted over the network was captured, including address, protocol, time, method, port, and content of the request and response. This kind of additional \"raw\" information can be useful when working with the results of the analysis. Another example is shown in the figure below. It illustrates another area of application work, in particular, data collected by the Monitor Activity module. The term \"activity\" here refers to all the various application screens that were run during the scan. For each screen (or \"activity\") its name and launch parameters are shown. All data from different modules, i.e. from different areas of the application, are collected and available for processing in one system. This greatly simplifies data analysis compared to the usual situation where different types of data are collected by several different utilities in different formats during the scan and it is often impossible to run these utilities in parallel to collect data at once. The collected data is used to enable the user to work directly with it when analyzing the results. The system also uses it to draw conclusions about application vulnerabilities. The rules for analyzing collected data to find vulnerabilities are described in detail in the \" Rules \" and \" Company-level Analysis Rules \" sections.","title":"Collected Data"},{"location":"ug/scan_results/#standards","text":"Select the Standards tab on the detailed scan results page to work with the standards requirements. This tab displays the results of the requirements compliance check of the scanned application. The Standards tab presents compliance with the security standards selected in the scan profile. Requirements, categories of requirements and standards with identified non-compliances are marked in red. If you click on an unfulfilled requirement on the left side, the Defects tab on the right side will list the types of defects that have been checked for the selected requirement. If at least one defect of a certain type was detected during the application scanning, this type of defects is marked with the sign, and the requirement itself is considered unfulfilled and is marked in red. If no defects of a certain type were found during the requirement check, this type of defects is marked with the sign. A requirement is considered fulfilled if its inspection finds no defects among the types of defects relevant to that requirement. On the right tab Defects , click a defect marked with the sign to get the detailed information about found defects of this type: To return to the requirements list, click the button in the upper left corner. The Standards tab contains data on compliance with the requirements of all standards selected in the scan profile. Suppose one more standard was added to the scan profile. In this case, the results of all scans previously performed with this profile on the Standards tab will also show the correspondence between the previously collected scan results and the newly added standard in the profile.","title":"Standards"},{"location":"ug/scan_results/#record-scan","text":"This tab is only available for the results of auto scan and provides a video recording of the performed scanning.","title":"Record Scan"},{"location":"ug/scan_results/#screenshot","text":"For scans with the *Failed status that were terminated because an application could not start on a device, an additional *App screenshot tab is available as a result of the scan. It contains a screenshot of the device at the moment of the error.","title":"Screenshot"},{"location":"ug/scan_results/#scan-log","text":"An additional ****Log tab allows you to view the scan log. It is available only during analysis of scan results.","title":"Scan Log"},{"location":"ug/standarty/","text":"Standards To go to the Standards tab, click the company name in the upper left corner, and then select the appropriate tab on the settings page. The Standards tab contains information security standards and their requirements. An application can be checked for compliance with these information security requirements. On this tab you can add, change or delete a standard at the company level. Compliance checks for each of these standards can be performed for all projects of this company. You can use the standards requirements search field for convenience: After entering text in the search field, all categories (groups) of requirements, which include requirements containing this text, will be expanded and displayed on the left side of the Standards tab: Lets consider how to manage standards and requirements in the system. Editing an Existing Standard When editing an existing standard, several operations can be performed: Change the name of the standard. Delete the standard. Add a new category (group of requirements). Add a new requirement. Change the category name. Delete the category. Change the name of the requirement. Delete the requirement. To change the name or delete an existing standard, move the cursor over the standard name. The icon appears to the right of the standard name. Click the \" \" icon and select Change from the drop-down menu to change the name of the standard or Delete to delete it. To edit the standard name, select the Change drop-down menu item, correct the standard name in the window that appears, and click the Update button. To add a category or requirement, select the Add drop-down menu item, then Category or Requirement , accordingly, type the category or requirement name in the input field and click Save . To adjust the name or delete an existing category, move the cursor over its name. The icon appears to the right of the category name. . Click the icon and select Change from the drop-down menu to change the name of the category or Delete to delete it. To edit the category name, select the Change drop-down menu item, correct the category name in the window that appears, and click the Update button. To adjust the name or delete an existing requirement, move the cursor over its name. The \" \" icon appears to the right of the requirement name. Click the icon and select Change from the drop-down menu to change the name of the category or Delete to delete it. To edit the requirement name, select the Change drop-down menu item, correct the requirement name in the window that appears, and click the Update button. Adding a New Standard To add a new standard, click the Add standard button at the top right of the Standards tab. In the window that appears, specify the name of the new standard and click the Add button. The newly created standard will be added to the list of standards in the system. Mapping Defect Types to Requirements The system contains a certain set of requirements and a certain set of defect types. As mentioned above, there are certain types of defects associated with each requirement, and if they are found in the application, the requirement will be considered as not met. To see which defect types are associated with a requirement and/or to associate a new defect type to a requirement, select that requirement. On the right side you will see a list of defects already associated with it and a field for selecting new defect types. At the top right of the Defects area in the Select a defect to add field, you can select one of the available defect types in the system from the drop-down list. The newly selected defect type will be added to the list of defects associated with this requirement. '\"\"\"\"","title":"Standards"},{"location":"ug/standarty/#standards","text":"To go to the Standards tab, click the company name in the upper left corner, and then select the appropriate tab on the settings page. The Standards tab contains information security standards and their requirements. An application can be checked for compliance with these information security requirements. On this tab you can add, change or delete a standard at the company level. Compliance checks for each of these standards can be performed for all projects of this company. You can use the standards requirements search field for convenience: After entering text in the search field, all categories (groups) of requirements, which include requirements containing this text, will be expanded and displayed on the left side of the Standards tab: Lets consider how to manage standards and requirements in the system.","title":"Standards"},{"location":"ug/standarty/#editing-an-existing-standard","text":"When editing an existing standard, several operations can be performed: Change the name of the standard. Delete the standard. Add a new category (group of requirements). Add a new requirement. Change the category name. Delete the category. Change the name of the requirement. Delete the requirement. To change the name or delete an existing standard, move the cursor over the standard name. The icon appears to the right of the standard name. Click the \" \" icon and select Change from the drop-down menu to change the name of the standard or Delete to delete it. To edit the standard name, select the Change drop-down menu item, correct the standard name in the window that appears, and click the Update button. To add a category or requirement, select the Add drop-down menu item, then Category or Requirement , accordingly, type the category or requirement name in the input field and click Save . To adjust the name or delete an existing category, move the cursor over its name. The icon appears to the right of the category name. . Click the icon and select Change from the drop-down menu to change the name of the category or Delete to delete it. To edit the category name, select the Change drop-down menu item, correct the category name in the window that appears, and click the Update button. To adjust the name or delete an existing requirement, move the cursor over its name. The \" \" icon appears to the right of the requirement name. Click the icon and select Change from the drop-down menu to change the name of the category or Delete to delete it. To edit the requirement name, select the Change drop-down menu item, correct the requirement name in the window that appears, and click the Update button.","title":"Editing an Existing Standard"},{"location":"ug/standarty/#adding-a-new-standard","text":"To add a new standard, click the Add standard button at the top right of the Standards tab. In the window that appears, specify the name of the new standard and click the Add button. The newly created standard will be added to the list of standards in the system.","title":"Adding a New Standard"},{"location":"ug/standarty/#mapping-defect-types-to-requirements","text":"The system contains a certain set of requirements and a certain set of defect types. As mentioned above, there are certain types of defects associated with each requirement, and if they are found in the application, the requirement will be considered as not met. To see which defect types are associated with a requirement and/or to associate a new defect type to a requirement, select that requirement. On the right side you will see a list of defects already associated with it and a field for selecting new defect types. At the top right of the Defects area in the Select a defect to add field, you can select one of the available defect types in the system from the drop-down list. The newly selected defect type will be added to the list of defects associated with this requirement. '\"\"\"\"","title":"Mapping Defect Types to Requirements"},{"location":"ug/testcases/","text":"Test Cases You can work with test cases in the system using the Test cases main menu item. The Test cases page shows all previously recorded test cases for different projects and applications. Each test case is presented as a separate string. The following information is provided for each test case: ID \u2014 The test case identifier in the system. Name of the recorded test case. Description of the test case. Package name \u2014 The test case was recorded for this application package. Project \u2014 The test case was recorded for this project. Architecture type where the scan was performed (Android or iOS). State \u2014 Status of the test case recording. Created at \u2014 Date of creation of the test case. On this page, you can use the \" \" drop-down menu located on the right side of each test case string to open a page with detailed information about the test case, delete a test case, or download a log file for it: You can also open a test case by clicking on its ID in the left column. In addition, if a test case is currently being recorded, using the \" \" menu, you can open a test case or end its recording: Recording a Test Case Note Only Android test case can be recorded and saved. To record a new test case, click Add test case in the upper right corner of the Test cases page: Select or drag and drop an apk file of the application to be scanned to the Add test case page that appears: After selecting the apk file, the Add test case page will display information about the selected application and fields required to start recording a new test case: Name of the test case to be created. * Description of the test case to be created. * Project to which the test case being recorded belongs. !!! note \"Note\" You can select either projects with an empty **Package name field** (see the \"[Projects](./projects.md)\" section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty **Package name** field or by specifying in it the corresponding package. Architecture \u2014 The architecture of the device used to launch and scan the application. Note that only the architecture corresponding to the uploaded file will be available for selection in this field. Once you have filled in all the fields and clicked the Run button, the page with the device screen will be displayed. Perform all the necessary test steps manually and press the Stop record button at the bottom right. The test case recording is finished and the application scan is stopped. The system starts analyzing the collected data and switches to the Test case list page, where a newly recorded test case is displayed. Note Since the application being scanned is affected by external actions during the scan, its operation speed can be slightly reduced. For recording test cases, it is recommended to take a small delay of 2-3 seconds between actions in the application interface. Editing / Deleting a Test Case Now let's look at how test cases can be managed in the system. You can edit and/or delete a test case on the List of test cases page. To edit a test case, either click its ID in the list of test cases or click the \" \" drop-down menu on the right side of the test case string and select Open . This will open a page for viewing and editing the test case. Click the Change button. In the window that appears, you can change both the test case name and description: On this page you can view a recording of the test case and download its log file. To delete a test case, click the Delete button and confirm the test case deletion in the dialog box that appears: Alternatively, a test case can be deleted directly on the List of test cases page using the Delete item of the drop-down menu located on the right end of the test case string \" \":","title":"Test Cases"},{"location":"ug/testcases/#test-cases","text":"You can work with test cases in the system using the Test cases main menu item. The Test cases page shows all previously recorded test cases for different projects and applications. Each test case is presented as a separate string. The following information is provided for each test case: ID \u2014 The test case identifier in the system. Name of the recorded test case. Description of the test case. Package name \u2014 The test case was recorded for this application package. Project \u2014 The test case was recorded for this project. Architecture type where the scan was performed (Android or iOS). State \u2014 Status of the test case recording. Created at \u2014 Date of creation of the test case. On this page, you can use the \" \" drop-down menu located on the right side of each test case string to open a page with detailed information about the test case, delete a test case, or download a log file for it: You can also open a test case by clicking on its ID in the left column. In addition, if a test case is currently being recorded, using the \" \" menu, you can open a test case or end its recording:","title":"Test Cases"},{"location":"ug/testcases/#recording-a-test-case","text":"Note Only Android test case can be recorded and saved. To record a new test case, click Add test case in the upper right corner of the Test cases page: Select or drag and drop an apk file of the application to be scanned to the Add test case page that appears: After selecting the apk file, the Add test case page will display information about the selected application and fields required to start recording a new test case: Name of the test case to be created. * Description of the test case to be created. * Project to which the test case being recorded belongs. !!! note \"Note\" You can select either projects with an empty **Package name field** (see the \"[Projects](./projects.md)\" section), or projects that have the package selected in the previous step in this field. Thus, it is possible that there will be no items available for selection in this field. In this case, you should create a new project with an empty **Package name** field or by specifying in it the corresponding package. Architecture \u2014 The architecture of the device used to launch and scan the application. Note that only the architecture corresponding to the uploaded file will be available for selection in this field. Once you have filled in all the fields and clicked the Run button, the page with the device screen will be displayed. Perform all the necessary test steps manually and press the Stop record button at the bottom right. The test case recording is finished and the application scan is stopped. The system starts analyzing the collected data and switches to the Test case list page, where a newly recorded test case is displayed. Note Since the application being scanned is affected by external actions during the scan, its operation speed can be slightly reduced. For recording test cases, it is recommended to take a small delay of 2-3 seconds between actions in the application interface.","title":"Recording a Test Case"},{"location":"ug/testcases/#editing-deleting-a-test-case","text":"Now let's look at how test cases can be managed in the system. You can edit and/or delete a test case on the List of test cases page. To edit a test case, either click its ID in the list of test cases or click the \" \" drop-down menu on the right side of the test case string and select Open . This will open a page for viewing and editing the test case. Click the Change button. In the window that appears, you can change both the test case name and description: On this page you can view a recording of the test case and download its log file. To delete a test case, click the Delete button and confirm the test case deletion in the dialog box that appears: Alternatively, a test case can be deleted directly on the List of test cases page using the Delete item of the drop-down menu located on the right end of the test case string \" \":","title":"Editing / Deleting a Test Case"},{"location":"ug/user_authentication/","text":"User Authentication A link to access the Mobix web interface shall be provided by an administrator. Click the link to open the authentication window. To sign in, select the authorization method, enter your user name (login) and password, and then click the Login button. If the credentials are not entered correctly, a message about an invalid user name or password will be displayed. Note A temporary password is provided along with the access link, which must be changed by the user the first time the user logs in. A newly set password must be at least 8 characters long and contain at least one lowercase letter, one uppercase letter, one number and one special character. After changing the temporary password, the user is prompted to accept the user agreement and privacy policy. The user is then redirected to the login page, enters the account and new password, and signs in. If the password is entered incorrectly five times, further authorization attempts require the entry of a security code (captcha). If two-factor authentication is enabled in your user profile, see the \" User Profile \" section, an additional window appears after you enter your login. In this window, you should enter the code that appears in the Google Authenticator app (download from Google Play or App Store ). If the two-factor authentication code is entered incorrectly three times, the user is blocked for 5 minutes.","title":"User Authentication"},{"location":"ug/user_authentication/#user-authentication","text":"A link to access the Mobix web interface shall be provided by an administrator. Click the link to open the authentication window. To sign in, select the authorization method, enter your user name (login) and password, and then click the Login button. If the credentials are not entered correctly, a message about an invalid user name or password will be displayed. Note A temporary password is provided along with the access link, which must be changed by the user the first time the user logs in. A newly set password must be at least 8 characters long and contain at least one lowercase letter, one uppercase letter, one number and one special character. After changing the temporary password, the user is prompted to accept the user agreement and privacy policy. The user is then redirected to the login page, enters the account and new password, and signs in. If the password is entered incorrectly five times, further authorization attempts require the entry of a security code (captcha). If two-factor authentication is enabled in your user profile, see the \" User Profile \" section, an additional window appears after you enter your login. In this window, you should enter the code that appears in the Google Authenticator app (download from Google Play or App Store ). If the two-factor authentication code is entered incorrectly three times, the user is blocked for 5 minutes.","title":"User Authentication"},{"location":"ug/user_profile/","text":"User Profile To go to the user profile settings page, click user name in the upper right corner and select Settings from the drop-down menu. Besides, using this drop-down menu, you can log out of the system. The page that opens contains information about the user: * User avatar . * Username (in e-mail address format). * User's company in the system. * Role \u2014 user's role in the system. * System language for this user. The following settings are available: Changing user's avatar. Changing username (login). Change the system interface language. Change password. Enable or disable two-factor authentication. Changing password. Click the Change button to save user information updates. Two-Factor Authentication To switch on two-factor authentication, click the Enable 2FA selector. The system then prompts you to enter the current user password. After entering the password, scan the QR code that appears using Google Authenticator (download it from Google Play or App Store ) and enter the code that appears in the app. If the code is correct, a confirmation message will appear at the bottom of the system UI. To switch off two-factor authentication, click the Enable 2FA selector. In the window that appears, enter the code displayed in the Google Authenticator app (you can download it from Google Play or App Store ). The change of the user profile will also be confirmed by a message at the top of the system UI. Changing a User Password It is possible to change the user's password. Open the user profile, see \" User Profile \". In the Password field, enter the current password, and then enter the new password twice, and finally click the Edit button. If necessary, you can enable displaying of passwords by clicking the icon . &&","title":"User Profile"},{"location":"ug/user_profile/#user-profile","text":"To go to the user profile settings page, click user name in the upper right corner and select Settings from the drop-down menu. Besides, using this drop-down menu, you can log out of the system. The page that opens contains information about the user: * User avatar . * Username (in e-mail address format). * User's company in the system. * Role \u2014 user's role in the system. * System language for this user. The following settings are available: Changing user's avatar. Changing username (login). Change the system interface language. Change password. Enable or disable two-factor authentication. Changing password. Click the Change button to save user information updates.","title":"User Profile"},{"location":"ug/user_profile/#two-factor-authentication","text":"To switch on two-factor authentication, click the Enable 2FA selector. The system then prompts you to enter the current user password. After entering the password, scan the QR code that appears using Google Authenticator (download it from Google Play or App Store ) and enter the code that appears in the app. If the code is correct, a confirmation message will appear at the bottom of the system UI. To switch off two-factor authentication, click the Enable 2FA selector. In the window that appears, enter the code displayed in the Google Authenticator app (you can download it from Google Play or App Store ). The change of the user profile will also be confirmed by a message at the top of the system UI.","title":"Two-Factor Authentication"},{"location":"ug/user_profile/#changing-a-user-password","text":"It is possible to change the user's password. Open the user profile, see \" User Profile \". In the Password field, enter the current password, and then enter the new password twice, and finally click the Edit button. If necessary, you can enable displaying of passwords by clicking the icon . &&","title":"Changing a User Password"}]}